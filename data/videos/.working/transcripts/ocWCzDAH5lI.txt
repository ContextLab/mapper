We have a group of related data that models some real-world concept, like a weather forecast, a user account, or a game character. Each character is made up of multiple attributes, like its color, its health, and whether or not its shell has spikes. We can certainly store all of those as separate variables, or we can use a data structure like a list or dictionary to bundle those values together. Great, but what if my program needs to represent tons of shell guys? We can make a separate dictionary record for each shell guy, but nothing in that code enforces that every shell guy has the same structure. All it takes is one little typo somewhere in those hundreds of shell guys, and now our program is broken. To solve this, we can create our own custom data type using classes. A class is a template for a data type. It defines what kind of thing it is and what data it can store. The class sets the rule that every shell guy must have a color, health, and has spikes attribute. Each shell guy we create must follow that rule, but each shell guy is his own unique thing. So this shell guy might store green, eight, and false, whereas this shell guy over here stores blue for his color attribute, 50 for his health, and true for has spikes. We call these actual shell guy things we create instances of the class shell guy, otherwise known as objects. Unfortunately, the syntax for this in Python is where it all gets a little weird. So let's break it down step by step. To define a new type, we use a class definition. We put the keyword class, the name of our type, and then a colon. Like everything in Python, the rest of the definition needs to be indented inside this, which we'll talk more about in a minute. Okay, we defined a new shell guy type. But like a function definition, a class definition doesn't do anything on its own. We need to call the class just like we call a function. Calling the class creates a new object of type shell guy, which right now is just an empty data container. We can then store data on that object using dot syntax. So this attaches a color variable to this specific shell guy, we call these variables stored on an object attributes. So now this shell guy is keeping track of his data. And I can create other shell guy objects and have them store their data. Now I'm seeing some repeated code here. After I create a shell guy object, I'm then immediately assigning these same three attributes. How do we clean up repeated code? We use a function. So let's write a function initialize that takes in a shell guy object, we'll name that parameter self and assigns that object's color, health and has spikes attributes. That means instead of guard dot color, we'll have self dot color. So after we create the first shell guy guard, we'll initialize him. And then the same for the shell guy object boss. But right now we're just hard coding the attributes to the same three values. That means every shell guy gets initialized to the color green. Instead, I want to pass in values for those attributes. So I can initialize my shell guys with different data. So we'll add a parameter for each of these and we'll store its value in the corresponding attribute. Then we can easily initialize our guard show guy to be green have eight HP and no spikes. Whereas we can give our boss shell guy the color blue 50 HP and yes, spikes. This is all great. But I just wrote my own arbitrary function. Wasn't the whole point of a class supposed to be that it enforces objects of that type have the same attributes. Well, the people who created the Python programming language realize that programmers always want to create the object and then immediately initialize it. So they got a bit fancy with the syntax shortcuts here. Python classes have a special initializer function, or technically we would say initializer method, since the function definition goes inside the class definition. This method must be named underscore underscore, init underscore underscore. The magic is that Python secretly automatically executes the initializer method when an object of that type gets created. We can see that in action by adding a print statement here. This init method is executing twice. Once when we create this shell guy object, and once when we create this shell guy object. The other piece of auto magic is that Python passes in the object as the first argument when it calls init. Since we're in the middle of creating the object, we don't have a variable that stores it yet. There is no guard that we can pass in. So Python handles that plumbing for us and passes in the object it's currently initializing, meaning that empty shell guy it just created. By convention, we named this first parameter self, as in me, myself, the object we're acting on. The name self has no special power. We could name this potato. What's important is that this is a knit first parameter. There's nothing truly magic here. We can call a knit manually after the object's created and pass in the object directly. There's just no need to since Python already called a knit automatically. With the auto magic out of the way, we can just move our earlier initialize function body into our special init method. Adding those parameters to a knit as well. Here's the question. Since we don't call a knit directly, how do we pass in those other arguments? You might have guessed this one, but we just pass them in when we instantiate the object. When Python automatically calls init, it will automatically pass those arguments through in the same order, except it adds the object as the first argument. That means we, as the programmer, don't pass in an argument for self. A knit has four parameters, but we only pass in arguments for the last three. And one small cleanup. By convention, we name our parameters the same as the attributes that store them, just to keep things simple. Okay, let's sum up what we did here. Our original initialize function and our special init method do the exact same thing. They set up or store these three attributes on the object that was passed in. The special class magic is that Python automatically executes the init method when we create a new shell guy object. Thus, carrying out our design method, we can do that without stringing out our desired rule that every object of type shell guy has the attributes, color, health, and has spikes.
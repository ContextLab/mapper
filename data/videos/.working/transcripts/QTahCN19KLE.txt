How can programs make our lives easier? While technology exists in almost everything nowadays, the first computers were built to automate complex, repetitive, and time-consuming calculations. They were used to calculate trajectories for spacecraft, analyze huge amounts of census data, and decode encrypted communications during wartime. Now, there's nothing special to these calculations per se. I could manually solve some version of these equations to calculate the trajectory myself. In fact, all of these calculations used to be performed by teams of humans. But with the sheer complexity and amount of data to process, these tasks take humans a lot of time. Computers, on the other hand, can process huge amounts of data in milliseconds. Modern computers automate tasks beyond just mathematical calculations. They can count the words in an essay, generate captions for a video, or clean up old photos. We often call these types of programs scripts. A script is a small, single-purpose program that we run on demand to perform a specific task. For example, every time I finish a video, I might run a script to generate captions for it. A script differs from an app or game in that those tend to be more complex and long-running. They're not just triggered ones to get a result. The logic in a script just comes from functions, loops, and conditionals. The only thing we're missing is a better way to store and organize large amounts of data, because our script needs data to operate on. That data could be an article, it could be a table from a spreadsheet, or it could be a series of readings from a device. We call data that has a meaningful ordering a sequence. So for example, the letters and words of an article need to be in that specified order. If I jumble them all up, I don't have the same article. In Python, our two fundamental types of sequences are strings and lists. A list is a type of data structure. Data structures allow us to organize and access data efficiently. Like functions organize our code, data structures organize our data. So what tedious digital tasks clutter up your everyday life? Think about the data that that task operates on. With the power of our first data structure, lists, you might just be able to automate that task for good by writing a script. Say your program manages a bunch of related data, like a user's favorite songs. You start by creating a variable for each song name, but that quickly gets out of hand. You might have five songs, then 100 songs, then 1,000. How can you keep track of all those variable names? This calls for our first data structure, lists. A list allows us to store a bunch of data in a single container, which we can then refer to with a single variable name. To define a new list in Python, we use square brackets. This creates an empty list named songs. Then we can just stick data in here, separating each individual piece of data or element with a comma. Here, our elements are strings, but lists can hold values of any data type. They can also hold duplicate elements. So this song can appear in the list twice. In Python, a list can even hold values of different data types. Lists store data in an ordered sequence, which means the ordering of the data in the list matters. This list and this list are not equivalent. Even though the data is the same, it's in a different order. Okay, we've organized the data into a nice container, but what if I wanna access the individual songs? Remember when I said the order is relevant? We refer to the individual elements based on their position in the list. This is the first element, the second element, the third element, and the fourth or last element. But in computer land, instead of starting our count at one, we start counting at zero. We call these positions list indices. So the element espresso is at index zero. This is at index one, index two, and index three. The syntax for accessing an element at a specific index also uses square brackets. We take the variable name of the list, square bracket, index, square bracket. So this accesses the element at index zero. Back to our program. If I access an index that doesn't exist, then I get an index error, which is a type of runtime error. This list only has four elements. So if I try to access the element at index seven, there is none. So the computer rightfully throws up its hands and says, I don't know. To protect against this, we can always compare an index to the number of elements in the list. If we remember our built-in length function, which we use with strings, we can also take the length of a list. Which just returns the number of elements. So the length of this list is four. Since we start counting indices at zero, however, that means the last element of a list is at the index length of the list minus one, in this case, three. So if we want to know if an index is valid, we just need to check if it's between zero and the length of the list minus one, inclusive. Okay, what about replacing values? Is what we call a mutable data structure, which means we can modify it after it's been defined. We can update the value at a specific index using an assignment statement. On the left-hand side of the equal sign, we put the name of the list, square brackets and the index we want to mutate. Just like any other assignment statement, on the right-hand side, we put the value we want to store. And we can also write a self-referencing assignment statement where we grab the current value, modify it, and store it back in the same location, which we can also write with our plus equal syntax shortcut. Either way we write it, we can see that we modified the element at index three. We concatenated those exclamation marks. To review, we can use a list to store multiple values in a defined order. We access values based on their position or index, which we start counting at zero. We can get the number of elements in a list using the built-in length function, where the last element of a list is at the index length of the list minus one. And if we access an index beyond that, we get an index error. Let's trace how the computer stores and updates a list in memory. Here we have an assignment statement with a list definition on the right-hand side. So just like when we defined variables before that held primitive data types, the computer goes off to short-term memory, allocates space for the new list and tags it with the variable name wave. But how exactly does the computer represent that list in memory? In Python, lists can hold values of any data type. Your elements might be integers, strings, or even other lists. We'll also learn that you can add new elements to a list after it's defined, so the length of your list may change as the program runs. All that to say, the computer has no idea how much space is going to need in memory to store that list over the course of the program. So instead of allocating a giant chunk of memory and storing all the elements of the list there, the computer instead just stores the individual elements wherever it wants. This is more efficient because depending on the program, other things may already be stored in memory. And it's easy to find a bunch of small chunks of memory scattered around, but it may be hard to find a giant contiguous chunk. It's like if you're packing a suitcase. It's easy to find small bits of space for a phone charger or an extra pair of socks, but it might be hard to find a contiguous chunk of space to throw in a pair of boots. You might have to shuffle everything else around first. Okay, but then how does it find all those elements if they're scattered around in memory? Well, it allocates a separate small chunk of memory whose job is to point to the locations where the elements are stored, just like a directory. The variable name then points here. Specifically, it points to the first slot, which contains the location for the element at index zero. That's why indices start counting at zero. They're offsets from this location in memory. Phew, okay, so we know how that list is stored. Let's move to the next line. We always evaluate inside the parentheses first. So here we're accessing the variable wave. The computer looks that up in memory. And then the index in the square brackets tells us the offset from this initial location. So two means we're two slots over. That slot, again, just contains the location where the actual element is stored. So we follow that way down here and grab the actual value. We substitute that in back up here. And now we just have a print statement. So we print that value to the console. Next line, we have an assignment statement. So we simplify the expression on the right-hand side first. We can see that we're referencing the element at index one on both the left-hand and the right-hand side of the equal sign. So this is a self-referencing assignment. We're grabbing the current value, adding 0.3 to it, and then storing it back. Our access here goes off to find the variable wave, moves over by an offset of one this time, and then follows that pointer to where the value is actually stored. We substitute that value in, add 0.3, and get a single value, which means we're ready to store. To start, the computer allocates a new chunk of memory and stores the float 0.72. But now it needs to tell the list about it. The assignment statement wants to update the element at index one. So we go to our variable wave, move over one, and then update that memory address to point to the new location where we just stored 0.72. Done. And now that that old value has nothing pointing to it anymore, the computer will come back in and clear out that memory. We load in our next assignment statement, and we simplify down the right-hand side. In the order of operations, the computer treats square brackets basically the same as parentheses. So we start evaluation with the innermost set. First, the computer evaluates this length function call. The length of a list is just the number of elements in it. So here we have one, two, three, four. Note that while the indices start counting at zero, the number of elements is still four. Anyway, we substitute in that four here and we subtract one. Now we just have a standard access. We find the variable wave, move an offset of three, follow that pointer, and end up here. But instead of duplicating that value and copying it to a second location in memory, the computer optimizes, and it just has the variable sample point to the same location. Okay, now what do you think happens here? It's just a standard variable assignment. So we allocate a new chunk of memory, store the float 0.65, and then move the variable sample to point to this location. Important point, notice that this does not affect the list wave. At index three, our little directory up here still points to the value 0.4. We only moved the pointer for sample. Last line, we grabbed the value for sample and substituted in. We're ready to store, but where? Well, the left-hand side tells us to go find the variable wave and then move an offset of eight. One, two, three. Okay, and we ran out of slots. So what happens? That's gonna be an index error. So the computer will display that in the console and then immediately terminate the program because it doesn't know what to do. And as always, when we terminate a program, the short-term memory gets cleared. Zooming out, the computer does make a few other optimizations here and there when storing lists in memory. For example, it actually pre-calculates and stores the length of a list, so it doesn't have to count the number of elements each time. There is a whole field of study in computer science dedicated to optimizing, evaluating, and comparing the efficiency of data structures, like lists. But for now, let's focus on how to use lists in our programs before we go too deep on the theory. You have a list of related data, but now what? Well, in most cases, you want to operate on every element in the list, whether that's searching for particular values or modifying every element. Let's start by doing this the hard way. Say I have a list of test scores and I want to count how many are above or equal to 90. Well, certainly I can access the test at every index individually and do that comparison. But I'm repeating myself a lot. And if I add more test scores, then I'll have to go in and add another one of these checks. This problem kind of looks familiar. How did we solve it before? We use loops. All right, so let's apply what we know about loops to iterate over the elements of my list. We want to go through every possible list index and access the element there. Indices start at zero, so let's initialize our loop variable to zero. And on each iteration, we'll increment the index by one. A quick reminder on our plus equals syntax shortcut for self-referencing assignment statements. This is equivalent to index equals index plus one. Okay, but when do we stop? Well, when we get to the end of the list. We know that the last element of a list is at the index length of the list minus one. So that should be our last iteration, which means we want to stop when index equals the length of the list. Then we just move that conditional inside the loop body. So we do that comparison on every iteration. And since I generalized my loop to stop based on the length of the list and not a hard code of value like four, my calculations still work no matter how many tests I have in my list. Now, if you're like, hey, why you making me use while loops? You're absolutely right. We typically do list iteration using for loops because it's less code. You may have wondered before why range starts at zero by default and why its stop value is exclusive. It's because it was invented for this exact situation, lists. Instead of putting a hard code of value as the stop argument to the range function, we can pass it the length of the list. So it'll start at zero and it'll stop when the loop variable index reaches the length of the list. Wow. By convention, we shorten the loop variable name to I if it represents the index of a list. We move that conditional inside the loop body. And once again, we have an equivalent program but with even less code. But can we go deeper? Programming language developers recognize that programmers will very frequently wanna iterate over the elements of a list. So many of them invented a syntax shortcut called a for each loop. That is for each element in the list. In Python, we have the syntax, the keyword for, the loop variable name, the keyword in, and the list to iterate over followed by a colon. We call this iterating by element versus iterating by index like we did before because here we're not using the index directly. The for each loop automatically updates the loop variable to contain the next element in the list on each iteration. So on the first iteration, the loop variable grade will contain the element at index zero. On the second iteration, grade will contain the element at index one and so on and so on until it reaches the end of the list where it automatically terminates the loop. Note that the loop variable here represents an element of the list, not an index. So we wanna make sure we name it descriptively based on what each element represents, not I. If we move our conditional inside the loop body, we have an equivalent program again. So now that we know this, why would we ever wanna iterate by index? Behind the scenes, the for each loop is copying the value of the element into the loop variable. It's not keeping a two way link back to that location in the list. So if I wanna modify all the values in the list, I can't use a for each loop. All this does is update the value stored in the variable grade. It doesn't modify the original list. To modify the actual list, the left hand side of the assignment statement must be a reference to the list itself. That means we need to iterate by index if we wanna modify the list. That way we can use the indices to access specific locations in the list and reassign their values. Like maybe the teacher decided to curve every test score by five points. You might also wanna iterate by index if the indices of the list are relevant to the calculations. Like maybe you only care about every other test score. But whether you're iterating by index or by element, loops give us the power to easily go through every element of a list. Let's design a program with lists. Say we've been tracking our screen time usage on our phone and we wanna take a closer look at that data to better understand our usage patterns. I wanna know how many minutes I spend on my phone every day and how many separate times I pick up my phone to do something, which I'll call screen time sessions. The tracking software I'm using formats my data in a list where each element represents a minute of the day. Each minute it records the name of the app that I'm using. Or if my phone is idle, it records an empty string. Here I've downloaded the data for a single day. I can split a long list like this over multiple lines as long as I start and end with a square bracket, just like we do with parentheses. This quickly clutters up our program. So it's good practice to put our data in a separate file. Then anyone who needs the data can just import the module. Now for our data analysis, let's create a new module to put all of our functions. We'll start with a function to count our total minutes of screen time. It should take in as a parameter, a list of that raw usage data. And it should return out a count of the active minutes. Now the total number of minutes of course is just the length of the list, but we don't wanna count minutes where the phone is idle. So we'll start by iterating over the list and keeping a basic count. Since we don't care about the particular index, we can just iterate by element. We'll initialize our count to zero before the loop, increment it on each iteration and return its final value. But we don't wanna count every element. We only wanna count the minutes where we're using an app. So if the element is equal to the empty string, we can skip it using the continue statement, meaning we immediately jump to the next iteration without executing this increment line. Okay, let's test our function. We'll go back to the main file and import our screen time module. We can call our count minutes function on our real usage data, but how do we know if this number makes sense? Instead, let's try calling it with some smaller test cases where we can actually verify the answer. If every minute is idle, we should get back a count of zero. If some minutes have an app name, we should count just those. And if all minutes are active, we should count all of them. One quick thought though, is that some of my screen time is mandated. Like I have to be on the Zoom call for work. I'm mostly interested in my personal screen time. So what if I had the option to specify apps to exclude from my count? I can add a second parameter that takes in a list of apps. And if I wanna count all apps like before, I can pass in an empty list. So back to my function definition, I'll add that new parameter. And then during our list iteration, we wanna skip that element if it's one of these apps. We can use the in operator to check if our current app is in the list of excluded apps. All right, next analysis. Let's write a count sessions function. It should take in our list of usage data and return out the number of distinct phone sessions. So if I check my email, listen to some music, watch some videos, message a friend all in a row, that all counts as a single session. Until I take a break from my phone. As we iterate over the list then, we know we started a new session if our current element is an app name and our previous element was an empty string. There are several different ways to implement that logic. Here, I'm gonna use a variable to keep track of the previous element. At the end of each iteration then, we just set that variable to the current element. But what do we initialize previous activity to? Well, our interesting test cases here will be when there's idle time at the beginning or end of the list versus when the first or last element is an app name. Does our function correctly count the first and last sessions? If the first element is an empty string, we don't wanna count a new session. Log not equal to the empty string will evaluate to false. So we'll correctly not execute this increment. However, if the first element is an app name, we've started a new session. So we do wanna increment the count. That means we need this condition to evaluate to true on the first iteration. We're covered on the current element not equaling the empty string. But if we want this whole expression to be true, we need to initialize previous activity to the empty string. Then we just need to verify that those two test cases with the last element work. And our function is done. Last piece, I wanna know my average session length. That is how many minutes I spend on my phone at a time. To calculate that, I can justify my total minutes of screen time by my number of sessions, which conveniently I already have functions for. So we'll nest both of those function calls, divide them and return the result, which I'll round to the nearest whole number. Let's run through our test cases again. And we have a zero division error. So if we're dividing by zero, that must mean our number of sessions is zero, which might be a valid case if we're offline for a while. To avoid the error, we can just check if the number of sessions is zero, in which case the average session length should just be zero. Based on this day's results, maybe I decide I wanna spend less time on my phone per session, or maybe I decide to expand my analysis, whether that's excluding work apps from my session calculations too, or downloading more of my usage data to compare results across multiple days. Now that we know we can iterate over the characters of a string, we have the power to perform all kinds of operations. We can count how many times a specific character appears in a string, or replace all occurrences of one character with another. Of course, we can always write our own function that iterates over the string and performs that count operation, but why not let someone else do the work? For common operations like this, Python provides built-in functionality. In the form of string methods. A method is just a special kind of function. All methods are functions, but not all functions are methods. Instead of packaging our functionality into arbitrary modules, we can attach them directly to the type that they operate on. In this case, the string type. A string knows how to count, replace, lower, strip, but an integer type does not. The major visible difference with methods is that we call them using dot syntax. Instead of passing the string we wanna operate on as an argument to the method, we call the method on that string. So we have the string, dot, method name, parentheses, and then any additional arguments we wanna pass in. So this counts how many times the character, lowercase a, appears in the string bananas. The string before the dot is also being passed into the method, but in its own special way. We'll trace how this works in more detail when we learn to write our own types and our own methods. For now, the important thing to remember is that the string to operate on goes before the dot. Hoo, okay, all that syntax out of the way, what string methods does Python give us? To start, we have the lower and upper methods. These take the string and convert it to either all lowercase or all uppercase. Any number or symbol characters, it leaves the same. Now you might recall that strings are an immutable type, which means the computer can't mutate or change the characters of a string after it's defined. That means the lower and upper methods, like all string methods, do not modify the original string. They return a new string. So I need to store the return value, either in a new variable or back in the same variable. The lower method can be especially useful for case insensitive matching. That is, if we want to consider all different capitalizations of a string as equivalent, we convert all the strings to lowercase first and then compare them. We also might want to normalize our string by removing any irrelevant punctuation at the start or end. For this, we have the strip method. The strip method strips away or removes any leading or trailing occurrences of the given characters. It doesn't remove all occurrences, only the ones at the start or end of the string. So this would remove any combination of periods, question marks, and exclamation marks that appear on either end. If we don't pass in any arguments to the strip method, by default, it removes any leading or trailing white space. Note that white space includes more than just space characters. Some strings can have tabs or line breaks. So this and this are not equivalent. Let's talk about two more common string methods, split and join. The split method splits up a string into a list of strings. By default, it splits based on white space. So we can take a text and split it into a list of words. We can also pass in an argument to specify a different separator, like we could split based on the substring the. Another common use case for the split method is CSV strings, which stands for comma separated values. When you download tabular data from a spreadsheet tool, the computer typically puts it in CSV format. A CSV file is essentially one giant string where each line represents a row in the table. Within each row, the individual values or columns are separated by commas. We can speed up a lot of analyses by downloading the CSV file and then writing our own program to process it. To get a list of the individual data fields in a row, we can call the split method with a comma separator. But what about putting that string back together? We call the join method on a separator string and pass as an argument a list of strings. The join method joins or concatenates all the strings in the list into a single string, inserting that separator string in between each one. So to join our CSV row back together, we might call the join method on a comma string. We also commonly call this on a space character to join a list of words back together. But we can call the join method on any arbitrary separator string we want. Just note that this still is a string method, so we need to call it on the string, not the list. In total, Python has over 40 different string methods, but lower, upper, strip, split, and join are likely to be some of your most commonly used. If you find yourself writing a function that operates on a string in some other standard way, you should look up if there's a string method for it. Just remember to call it using dot syntax. And keep in mind that string methods never modify the original string. If lists are mutable, what happens when we pass a list argument to a function? To answer this, it's time to get precise about how argument passing works in Python. For the most part, we've been passing primitive data types as arguments, that is strings, integers, floats, and Booleans. And we've seen that if we reassign the parameter inside the function body, that only modifies the variable in local scope. It does not affect the value of the variable that we passed in. In Python, however, it's not quite true that the computer makes a copy of the value when it passes it into the function. Instead, Python passes all arguments into functions by assignment. Passed by assignment means that the computer passes a reference to the original value, not a copy of it. So our local parameter variable initially points to that same location in memory. However, this doesn't form a permanent two-way link. If we later reassign that parameter inside the function body, it doesn't affect that original variable. The computer allocates a new chunk of memory in local scope, stores the new value there, and then moves the parameter variable to point to that new location. Now, if we pass a list as an argument instead, the same thing happens. Instead of copying the entire list, which could be very expensive if the list has thousands of elements, the computer passes a reference to where that list is stored. If we fully reassign that parameter variable, just like before, the computer allocates a new chunk of memory in local scope, stores the new list there, and then moves the parameter variable to point to that new location. But what if instead of reassigning the parameter variable, we just mutated it? Since lists are a mutable data type, we can update them in place. So if I were to update the element at index zero, this mutates the existing list. It doesn't create a new one. If I put that mutation instead inside the function body, the same thing happens. Notice, however, that with pass by assignment, my parameter variable and that original variable are both pointing to the same location in memory. So any mutations I make inside the function body also affect the value of the original variable. This is a key property of pass by assignment. With immutable types like floats, we can never mutate the original value. All operations always create a new float. So when we pass them as arguments to a function, our function doesn't affect the original variable. With mutable types, however, like lists, we do have operations that can modify the original value. So when we pass them as arguments to a function, any mutations we make inside the function body also affect the original variable. Cool, so what do I do with this information? Well, this property puts our programs at risk of bugs because our functions can now have unexpected side effects. I may pass my list into a function, but still want to use it later. And you never know if that function passes the list into another function, to another function, into another function. If somewhere along the line, one of those functions secretly mutates my list, the list that I'm operating on over here may no longer be the version of the list that I wanted. And now my calculations are off. Because function side effects make it more unpredictable for the programmer, it's a best practice to avoid mutating list arguments inside of functions. Where possible, we should accumulate a new list and return it, leaving the original list parameter unchanged. For example, if we want to modify the elements of a list, we might instead create a new empty list, iterate over the original list parameter, and then append a modified version of each element to our new list. Now, in some cases, it's true, we may need our function to mutate the list parameter, either because the purpose of the function is to have that side effect, or maybe we're operating on a list with millions of values and copying or iterating over that list would be prohibitively expensive. In these cases, we need to make sure to clearly document the side effect and to make the side effect apparent in the function name. In summary, Python passes arguments to functions by assignment. If your argument is an immutable type, there's nothing to worry about. But if your argument is a mutable type, any updates you make to the list parameter inside the function body carry over to the original variable you passed in. Let's design a program with lists, the accumulator pattern, and string methods. We've collected flight data from several different airports. We wanted to do some analysis here to understand if there's any patterns in a particular airport's delays, and maybe to see which airline is the biggest offender. Before we try processing it, let's understand our data format. Here we have a table of past flights. For each flight, we have the date, the airline, the flight number, and a bunch of delay fields. The delays are all represented in minutes. For now, we're mostly interested in departure delays. That is, how long after the scheduled time the flight took off. When we download this data, the computer puts it in CSV format, where the columns of each row are separated by commas. I did some quick work to get that data into my Python program, and now I have a list of CSV strings. Each element represents a row of the table. To start, let's create a new module to hold all of my analysis functions. I think I want to calculate the average delay time per airline. So I probably want a function that takes in the name of an airline, our flight data, and returns out the average delay for that airline in minutes. To make this easy, I can just accumulate a list of all of that airline's delays. The average then is just the sum of that list, divided by the length of that list. Remember that each element of flights is a CSV string. So I need to parse that string to get the airline and delay info. To get a list of all the fields, I can split my string based on the comma separator. And if I check my data format real quick, I can see that the airline is in the second column. So that'll be index one. If the airline doesn't match, we skip it. Otherwise, we need to know the flight delay. The departure delay field is going to be index zero, one, two, three, four. So I extract that field and append it to my list. Let's go back to the main file and test it. We import both our modules and then pass the flight data into our get average function. For now, we'll just pick a test airline, let's say Delta. Whoop, that's a type barrier. The stack tray says it's coming from the return statement in my get average function. Weird, let's print the state of my list right before that line. Okay, these are strings, not integers. And also weird that there are some negative numbers in here. But one thing at a time, the type error is definitely coming from the string thing. So if we want all these values to be integers, we should cast them before we append them to the list. Great, now where are those negative numbers coming from? It looks like our data does have some negative numbers in the departure delay column. My guess is that maybe this means that the flight left early. But if I'm talking about delays, I don't care if the flight left early. I don't want negative numbers to be skewing my delay average. So I think I wanna treat those as zeros. If the flight left early, there was no delay. All right, we have this working for one airline, but I wanna compare the delays for all airlines. How do I know which airlines to check? Well, I'm gonna run this analysis on data from a bunch of different airports. And the airlines that fly out of each airport are different. So the best source of truth is the data itself. Let's write a function that iterates over the flight data and collects a list of unique airline names. So we start with an empty list, we accumulate inside the loop, and we return the final list at the end. Okay, and on each iteration, we extract the airline name, which we know is at index one, and then we append it to the list. But this is just a list of each row's airline. We wanna list of the unique airlines that fly out of a given airport. So if an airline already exists in the list, we don't wanna append it again. Better, but not best. It looks like maybe our data has some different capitalizations of airline names. So they're getting counted as separate airlines. Now we could just convert all the airlines to the same case inside the find airlines function, but the get average function is also using the airline name. So it must be affected by the same issue. Instead of forcing every analysis function to recognize and handle this data inconsistency, we can use a step called pre-processing. This normalizes our data once upfront. So the rest of our code doesn't have to think about it. We'll create a new module for this, since this is a different class of functionality. We iterate through each flight, normalize it, and append it back. To normalize, I'm gonna convert every airline name to all uppercase. Now, one other thing. We also had all those negative delays that we converted to zero inside the get average function. Now, I think for all calculations I'm gonna do, I don't care about early departures. So I'm gonna move that zero conversion out to the pre-processing step too. That way no one else has to worry about it. We call this pattern separation of concerns, because each piece of code can focus on a single task. Our analysis shows that JetBlue has the worst average delay at this airport. To continue on, we can analyze the delays at other airports or maybe add a function to learn more about delay causes. What data structure would you use to represent a tic-tac-toe board? The ordering of the squares is important because I need to know if I have three symbols in a row, not just anywhere on the board. But if I put all of these squares in a long sequential list, I'm not clearly representing the structure of the board. So what if instead I had a list of lists where each nested list represents a row of the board? We call this a 2D list because it's two-dimensional. Each element of my outer list is itself a list. So the element at index zero is the whole first row of the board. If I wanna access an element in that row, I just index into it again. So this gives us the first element of the first row, which would be the uppermost left square of the board. We can also collapse that whole access into a single expression. We evaluate from left to right, so board zero gives us that first nested list and the zeroth element of that list is an X. When using double indices like this, programmers often think of it in terms of row and column. The first index accesses the nested list or row. And then the second index accesses a column of that row. Just remember that the indices start at zero. So this is row zero one two and then column zero one. Okay, what else do programmers use 2D lists for? First off, pretty much anything that maps to a grid. We see this a lot in games, from a chessboard to the map of terrain that a character walks on. The front end can then use that data representation to figure out which graphic to render where. String grass becomes this nice little textured green square and the string water becomes a blue square. Some specialized programmers also use 2D lists for mathematical matrices and linear algebra, like 3D animation and even large language models. But probably the most common use case of 2D lists are images. Digital images are made up of thousands of tiny squares called pixels, which together form the image, kind of like a mosaic. In grayscale images, each pixel is represented by an integer from zero to 255. Zero is the least brightness or black and 255 is the most brightness or white. Now, what if I wanna iterate over every element of my 2D list? If we start with a standard for each loop, our loop variable would hold the next row of pixels in our image. But then what if I wanna iterate over the pixels in that row? I can nest another for loop inside this outer for loop. And this time, instead of iterating over the whole image, I'm iterating over my outer loop variable row. Whew, this gets a little confusing. So let's trace through this with a smaller example. On the first iteration, the loop variable row holds the first nested list. Then we execute the loop body. And the first line inside the loop body is this nested for statement. This for loop iterates over the elements in row. So on the first iteration of this loop, the loop variable column holds the element zero. Then we execute this loop body, which is any lines of code that are indented inside of it. We just have this one print statement that prints the value of column, which is zero. And then we're out of loop body. So we go back to the top of the closest enclosing loop. Column now contains the next element in the row, which is one. You print one, you go back to the top of the loop. And now there are no more elements in row. So this loop terminates. And we return execution back to the outer loop body. There are no lines of code left that are indented inside that outer loop. So we go back to the top of the loop and start the next iteration. Row now contains the next element of our 2D list, which is the inner list two, three. We enter the loop body again, and then we hit the inner for loop, which again iterates over the elements in row. So the first time we print two, the second time we print three, and now we're at the end of the list. So we terminate the loop, which brings us to the end of our outer loop body. So we loop back to the top and start on the next row. We do all of that again. And when we get back to the top of the outer loop this time, we are out of rows. So the outer loop terminates. And you can see that we printed every element in order of the 2D list. So the outer loop iterates over the rows and the inner loop iterates over the columns of each row. But what if we want to mutate our list? We can't just reassign these loop variables. Just like with one dimensional lists, if we want to mutate, we need to iterate by index. The range for outer loop is just the length of the image, which is the number of rows. And then the range for the inner loop is just the number of columns. So we take the length of the current row, but our loop variable row is an index now. So to get the actual list, we need to access the element of image at index row. Inside the inner loop body, we now have the index for the current row and the current column, which we can use to reassign the element at that exact position. So if, for example, I want to take the negative of that image, I just need to invert each pixel, which means subtracting the current pixels value from 255. Not all 2D lists are a uniform grid. Each nested list or row can have a different length. So make sure to pay attention to the length of whatever list you're working with so you don't get an index error. But no matter what size 2D list you have, the first index always accesses the row or inner list. And the second index always accesses the column or element within the inner list.
Let's design a program that imports functionality from another file. When programming teams collaborate on projects, they're often writing code across multiple files. They package their work into functions and then share them for other team members to use. This is just another form of a module. Here, my teammate wrote a module for simulating a robot's movement. We can open up the file and take a look at the code, but we may not always have the background knowledge or time to understand the details of how it works. The good news is, that doesn't matter. The only thing I need to understand is the documentation of how to use it. If you notice up here, we've been writing our code in a file called main.py. The .py is the file extension for Python code, just like jpeg is for images. Then, by convention in Python, we name the file with our main logic, main. In the Khan Academy IDE, when we press the run button, it runs the code in main.py. However, we can add other files or modules to our program, then import them into main.py and use their functions there. So if we go back to our main.py file, we can import the robot module and then call one of these functions. Okay, so let's start with the first function in the robot module, which is called reverse. It takes one input, or argument, the direction, and from the docstring here, I see that it rotates the robot 180 degrees and returns its new direction. It also says the direction can either be left or right. So if I go back to main.py, I can call this function using the module name robot.reverse. Its argument can be the string left or right, so let's say left for now. And then we know it returns the new direction, so I want to store that value in a variable. Let's run it and see what it does. Nice. So this function is returning right because it's reversing left. And then if I swap that and I try and reverse right, it returns left. Okay, not that interesting by itself. Let's see what this draw function does. It takes three inputs, the position, direction, and grid size, and it says it displays the robot's position and direction on the grid. Note that it doesn't say that it returned something, so it might just display and not return an output value. Back to main.py, let's call robot.draw. And we want to give it a position, I don't know, let's say three, and then let's pass in the direction we got back from reverse, and it needs a grid size, which I guess needs to be bigger than the position, so let's say 10. Okay, nice. It looks like it's printing a little representation of the robot, and we can see that the arrow is pointing left because the robot is facing left. Let's draw the robot before we reversed it, too. The position and grid size will be the same, but the direction will be right, so let's actually store that in the variable up here. And actually, let's store the position and grid size in a variable as well, so we're not repeating 3 3 10 10. Note that I'm not making any changes to the robot.py file, I'm just using this module. All of my code is going in main.py. Let's try one more function, moveForward. We see that it takes a position, direction, and grid size, and it returns the robot's new position. So back to main.py, we call robot.moveForward, and we pass in the robot position, the direction, and the size. And since it returns the new position, we're going to store the result of that function call in the robot position variable. And so we can see what happens, let's call draw afterward. Now that we've experimented, we've got a good sense for how the robot module works, so let's try building this into a more interesting program. Maybe we want the robot to randomly decide whether it moves forward or reverses at any point. So I could generate a random number, and depending on the result, decide which function to call. That means I'm going to need the random module. By convention, usually we alphabetize our imports, so I'm going to put random first. And because there are two possible outcomes, I'll generate a random number between 1 and 2. If I get a 1, I'll have the robot move forward, and if I get a 2, I'll have it reverse. Now I want to generate three random numbers because I want the robot to take three random actions. I don't want it to perform the same one random action three times. So I need to have three separate randint function calls. In fact, I'll just copy this whole block of code, because I want all of this functionality to repeat. Now if I run the program a few times, I can see that the robot's moving randomly. One last thing, maybe let's have the robot start at a random position each time too. The robot's got to start on the grid, so the start should be 1, and the stop should be the grid size. And now when I run the program, the robot's starting at a random position each time. Pretty cool how quickly we were able to get a complex program like that up and running. That's the power of using modules. We can build off a functionality other people have already written to expand the possibilities of our programs. That's it. That's it. Thank you. See you next time. Bye-bye.
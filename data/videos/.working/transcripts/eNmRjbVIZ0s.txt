Let's apply test cases to debug a racing game. Our game prototype has two cars that race on a straight track. Each round, the cars move forward a random number of spaces. And whichever car passes the end of the track first wins. Let's take a look at the code we have so far. We use a while loop to repeat rounds until the race is over. On each iteration, we move the cars, we print the status of the race, and we display the track state. When I run it, it kinda seems like this game works. But there does seem to maybe be a little bug here. On the last round, it seems like cars are sometimes disappearing from the track. So maybe I'm missing something in my display function. I'm gonna open up the track module to see how this display function works. It takes in the positions of the two cars and the length of the track. And it returns out a string drawing of the track state. Seems reasonable, but what's going wrong then? To narrow this down, I'm gonna test the display function in isolation. So I'll pop back over to main.py and run through a few test cases. There's the case where the first car is ahead. There's the case where the second car is ahead. There's a case where both cars, I guess, are on the same position of the track. And then there's the end case, where a car is beyond the end of the track. Okay, let's see what values we get back. I'm gonna comment out this game loop for now, because its output is a little distracting. Ew, it looks like a car is disappearing in two test cases. So lucky us, maybe we have two bugs to fix. Let's start with the last case, where a car's position is greater than the track length. What do we want to happen in this case? Well, I'd like to still see where the car is. So maybe we just keep drawing until we reach the furthest position. Right now, our draw loop only goes up to the length of the track, but plus one since range is exclusive. So if the track length is 5, and car 1 is at position 7, then we want to keep drawing segments until we pass position 7. So really, the end of the range should be whichever is greater, the position of car 1 or the end of the track. But car 2 might also be the furthest, so we should really take the maximum of all three positions. Hmm, let's see if that fixed the problem. And let's double check the case where car 2 is the furthest. Whew, that's three test cases passing now. So let's wrap this up by fixing the case where the cars are at the same position on the track. Right now, it looks like display is only showing the symbol for car 1. What do we expect? Well, it's not all that obvious. One solution might be to just draw a different symbol. That indicates both cars are on that space. I can change the symbol later, but for now, let's just say I draw an x. So let's go back to our display function and see what we need to modify. It looks like this nested function call controls which symbol we draw for each segment. So we need to update the get symbol for space function to handle that x case. If car 1 and car 2's position are the same, then we return an x. Ooh, everything is an x now. What do we do? It seems like for every segment, get symbol for space is returning x. We do need to check that car 1 and car 2 are at the same position, but we also need to check that that's the position we're currently trying to get the symbol for. It doesn't matter if car 1 and car 2 are both at position 5, if right now we're trying to get the symbol for position 1. So to draw an x, all three of these values should be the same, which we can verify by checking that position equals equals car 1. Alright, all four test cases are passing. I'm fairly confident that the display function works now. So let's put the game back together. I'll clean up those test cases and uncomment out the game loop. The next time you encounter a bug in your program, try narrowing it down to the individual function level. And hopefully you'll have an easier time debugging just that one unit of code.
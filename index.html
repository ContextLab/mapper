<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Knowledge Map Demo - Heatmap Visualization</title>
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #00693E 0%, #004d2c 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            width: 100%;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 80px rgba(0, 0, 0, 0.5);
            border: 3px solid rgba(255, 255, 255, 0.2);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #00693E 0%, #004d2c 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .content {
            padding: 40px;
        }

        .question-section {
            margin-bottom: 30px;
        }

        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .question-number {
            font-size: 0.9em;
            color: #00693E;
            font-weight: 600;
        }

        .question-text {
            font-size: 1.3em;
            color: #333;
            margin-bottom: 25px;
            line-height: 1.6;
        }

        .options {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .option {
            padding: 18px 24px;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.05em;
            display: flex;
            align-items: center;
        }

        .option:hover {
            border-color: #00693E;
            background: #e8f5f1;
            transform: translateX(5px);
        }

        .option.selected {
            border-color: #00693E;
            background: #e8f5f1;
        }

        .option-label {
            display: inline-block;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: #00693E;
            color: white;
            text-align: center;
            line-height: 30px;
            margin-right: 15px;
            font-weight: 600;
            flex-shrink: 0;
        }

        .button-container {
            display: flex;
            gap: 15px;
            margin-top: 30px;
        }

        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 1.05em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            flex: 1;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00693E 0%, #004d2c 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 105, 62, 0.4);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #f5f5f5;
            color: #333;
        }

        .btn-secondary:hover {
            background: #e0e0e0;
        }

        .map-container {
            width: 100%;
            height: 700px;
            background: #f8f9fa;
            border-radius: 12px;
            position: relative;
            overflow: hidden;
        }

        .map-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .map-header h2 {
            font-size: 1.8em;
            color: #333;
            margin-bottom: 10px;
        }

        .map-header p {
            color: #666;
            font-size: 1.05em;
        }

        #map-canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 10;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #00693E;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 12px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: 700;
            color: #00693E;
        }

        .stat-label {
            color: #666;
            margin-top: 5px;
        }

        .hidden {
            display: none;
        }

        .progress-bar {
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 30px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00693E 0%, #004d2c 100%);
            width: 0%;
            transition: width 0.5s ease;
        }

        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.8);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            font-size: 0.9em;
            z-index: 5;
            cursor: move;
            user-select: none;
            transition: box-shadow 0.2s ease;
        }

        .legend:hover {
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        .legend.dragging {
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.3);
            cursor: grabbing;
        }

        .legend h4 {
            margin-bottom: 10px;
            color: #333;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .legend-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-right: 8px;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .colorbar {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.8);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 5;
            cursor: move;
            user-select: none;
            transition: box-shadow 0.2s ease;
        }

        .colorbar:hover {
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        .colorbar.dragging {
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.3);
            cursor: grabbing;
        }

        .colorbar h4 {
            margin-bottom: 8px;
            font-size: 0.9em;
            color: #333;
        }

        .colorbar-gradient {
            width: 200px;
            height: 20px;
            background: linear-gradient(to right,
                rgba(139, 69, 19, 0.8),
                rgba(184, 134, 11, 0.8),
                rgba(218, 165, 32, 0.8),
                rgba(0, 133, 66, 0.8),
                rgba(0, 105, 62, 0.8)
            );
            border-radius: 4px;
        }

        .colorbar-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.8em;
            color: #666;
            margin-top: 5px;
        }

        .tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 0.9em;
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            opacity: 0;
            transition: opacity 200ms ease-in-out;
        }

        .tooltip.visible {
            opacity: 1;
        }

        .tooltip-hidden {
            display: none;
        }

        .tooltip-question {
            font-weight: 600;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
        }

        .tooltip-status {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tooltip-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        @media (max-width: 768px) {
            .content {
                padding: 20px;
            }

            .header h1 {
                font-size: 1.5em;
            }

            .question-text {
                font-size: 1.1em;
            }

            .map-container {
                height: 400px;
            }

            .stats {
                flex-direction: column;
                gap: 20px;
            }

            .legend, .colorbar {
                font-size: 0.8em;
                padding: 10px;
            }

            .colorbar-gradient {
                width: 150px;
            }
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1><i class="fas fa-brain"></i> Knowledge Map Explorer</h1>
            <p>Answer questions to visualize your conceptual understanding</p>
        </div>

        <div class="content">
            <!-- Quiz Section -->
            <div id="quiz-section" class="quiz-section">
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill"></div>
                </div>

                <div class="question-section fade-in" id="question-container">
                    <div class="question-header">
                        <span class="question-number" id="question-number">Question 1 of 10</span>
                    </div>
                    <div class="question-text" id="question-text"></div>
                    <div class="options" id="options-container"></div>
                </div>

                <div class="button-container">
                    <button class="btn btn-secondary hidden" id="prev-btn"><i class="fas fa-arrow-left"></i> Previous</button>
                    <button class="btn btn-secondary" id="skip-btn">Skip <i class="fas fa-forward"></i></button>
                    <button class="btn btn-primary" id="next-btn" disabled>Next <i class="fas fa-arrow-right"></i></button>
                </div>
            </div>

            <!-- Map Section -->
            <div id="map-section" class="map-section hidden">
                <div class="map-header">
                    <h2>Your Knowledge Map</h2>
                    <p>Hover over the map to explore our model of your knowledge</p>
                </div>

                <div class="map-container">
                    <canvas id="map-canvas"></canvas>
                    
                    <div class="legend">
                        <h4>Question Status</h4>
                        <div class="legend-item">
                            <div class="legend-dot" style="background: rgb(0, 105, 62);"></div>
                            <span>Correct</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-dot" style="background: rgb(218, 165, 32);"></div>
                            <span>Unanswered</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-dot" style="background: rgb(139, 69, 19);"></div>
                            <span>Incorrect</span>
                        </div>
                    </div>

                    <div class="colorbar">
                        <h4>Inferred Knowledge</h4>
                        <div class="colorbar-gradient"></div>
                        <div class="colorbar-labels">
                            <span>Low</span>
                            <span>High</span>
                        </div>
                    </div>

                    <div class="tooltip tooltip-hidden" id="tooltip"></div>
                    
                    <div class="loading hidden" id="loading">
                        <div class="spinner"></div>
                        <p>Generating your knowledge map...</p>
                    </div>
                </div>

                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-value" id="correct-count">0</div>
                        <div class="stat-label">Correct</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="accuracy-pct">0%</div>
                        <div class="stat-label">Accuracy</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="total-count">10</div>
                        <div class="stat-label">Total Questions</div>
                    </div>
                </div>

                <div class="button-container">
                    <button class="btn btn-secondary" id="restart-btn"><i class="fas fa-rotate-right"></i> Start Over</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Questions data loaded from external file
        let questionsData = [];

        // Application state
        let currentQuestion = 0;
        let userResponses = [];
        let selectedOption = null;

        // DOM elements
        const quizSection = document.getElementById('quiz-section');
        const mapSection = document.getElementById('map-section');
        const questionContainer = document.getElementById('question-container');
        const questionNumber = document.getElementById('question-number');
        const questionText = document.getElementById('question-text');
        const optionsContainer = document.getElementById('options-container');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const skipBtn = document.getElementById('skip-btn');
        const restartBtn = document.getElementById('restart-btn');
        const progressFill = document.getElementById('progress-fill');
        const canvas = document.getElementById('map-canvas');
        const ctx = canvas.getContext('2d');
        const loading = document.getElementById('loading');
        const tooltip = document.getElementById('tooltip');

        // Hover state for animations
        let hoveredDotIndex = null;
        let hoveredHeatmapCell = null;
        let dotAnimationProgress = {}; // Maps dot index to animation progress (0-1)
        let animationFrameId = null;
        let lastFrameTime = performance.now();

        // Load questions and initialize
        async function loadQuestions() {
            try {
                const response = await fetch('questions.json');
                if (!response.ok) {
                    throw new Error(`Failed to load questions: ${response.status}`);
                }
                questionsData = await response.json();
                console.log(`Loaded ${questionsData.length} questions`);
                renderQuestion();
            } catch (error) {
                console.error('Error loading questions:', error);
                questionContainer.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #e74c3c;">
                        <h3>Error Loading Questions</h3>
                        <p>Could not load questions.json. Please ensure the file exists and the page is served via HTTP(S).</p>
                        <p style="font-size: 0.9em; color: #666; margin-top: 20px;">
                            If testing locally, use a local server like: <code>python -m http.server 8000</code>
                        </p>
                    </div>
                `;
            }
        }

        // Initialize
        loadQuestions();

        // Event listeners
        nextBtn.addEventListener('click', handleNext);
        prevBtn.addEventListener('click', handlePrevious);
        skipBtn.addEventListener('click', handleSkip);
        restartBtn.addEventListener('click', restart);

        function renderQuestion() {
            const q = questionsData[currentQuestion];
            questionNumber.textContent = `Question ${currentQuestion + 1} of ${questionsData.length}`;
            questionText.textContent = q.question;
            
            progressFill.style.width = `${(currentQuestion / questionsData.length) * 100}%`;

            optionsContainer.innerHTML = '';
            q.options.forEach((option, index) => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'option';
                
                const savedResponse = userResponses[currentQuestion];
                if (savedResponse !== undefined && savedResponse === index) {
                    optionDiv.classList.add('selected');
                    selectedOption = index;
                }

                optionDiv.innerHTML = `
                    <span class="option-label">${String.fromCharCode(65 + index)}</span>
                    ${option}
                `;
                
                optionDiv.addEventListener('click', () => selectOption(index, optionDiv));
                optionsContainer.appendChild(optionDiv);
            });

            prevBtn.classList.toggle('hidden', currentQuestion === 0);
            nextBtn.disabled = selectedOption === null;
            nextBtn.innerHTML = currentQuestion === questionsData.length - 1 ?
                'See Results <i class="fas fa-chart-line"></i>' :
                'Next <i class="fas fa-arrow-right"></i>';

            questionContainer.classList.remove('fade-in');
            void questionContainer.offsetWidth;
            questionContainer.classList.add('fade-in');
        }

        function selectOption(index, optionElement) {
            document.querySelectorAll('.option').forEach(opt => {
                opt.classList.remove('selected');
            });

            optionElement.classList.add('selected');
            selectedOption = index;
            nextBtn.disabled = false;
        }

        function handleNext() {
            userResponses[currentQuestion] = selectedOption;

            if (currentQuestion < questionsData.length - 1) {
                currentQuestion++;
                selectedOption = null;
                renderQuestion();
            } else {
                showResults();
            }
        }

        function handlePrevious() {
            if (currentQuestion > 0) {
                currentQuestion--;
                selectedOption = userResponses[currentQuestion] ?? null;
                renderQuestion();
            }
        }

        function handleSkip() {
            // Leave current question unanswered
            if (currentQuestion < questionsData.length - 1) {
                currentQuestion++;
                selectedOption = null;
                renderQuestion();
            } else {
                showResults();
            }
        }

        function showResults() {
            quizSection.classList.add('hidden');
            mapSection.classList.remove('hidden');
            loading.classList.remove('hidden');

            let correct = 0;
            userResponses.forEach((response, index) => {
                if (response === questionsData[index].correctIndex) {
                    correct++;
                }
            });

            document.getElementById('correct-count').textContent = correct;
            document.getElementById('accuracy-pct').textContent = `${Math.round((correct / questionsData.length) * 100)}%`;
            document.getElementById('total-count').textContent = questionsData.length;

            setTimeout(() => {
                loading.classList.add('hidden');
                generateKnowledgeMap();
            }, 1500);
        }

        function generateKnowledgeMap() {
            const container = canvas.parentElement;
            const dpr = window.devicePixelRatio || 1;
            canvas.width = container.clientWidth * dpr;
            canvas.height = container.clientHeight * dpr;
            canvas.style.width = container.clientWidth + 'px';
            canvas.style.height = container.clientHeight + 'px';
            ctx.scale(dpr, dpr);

            const width = container.clientWidth;
            const height = container.clientHeight;

            // Create knowledge heatmap
            drawKnowledgeHeatmap(width, height);

            // Draw question markers
            drawQuestionMarkers(width, height);

            // Add interactivity
            addInteractivity(width, height);

            // Make legend and colorbar draggable (only initialize once)
            if (!canvas.dataset.draggableInitialized) {
                const legend = document.querySelector('.legend');
                const colorbar = document.querySelector('.colorbar');
                if (legend) makeDraggable(legend);
                if (colorbar) makeDraggable(colorbar);
                canvas.dataset.draggableInitialized = 'true';
            }
        }

        function redrawCanvas() {
            // Get current canvas dimensions
            const container = canvas.parentElement;
            const width = canvas.width / window.devicePixelRatio;
            const height = canvas.height / window.devicePixelRatio;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Redraw heatmap and markers
            drawKnowledgeHeatmap(width, height);
            drawQuestionMarkers(width, height);
        }

        function animateCanvas() {
            const currentTime = performance.now();
            const deltaTime = currentTime - lastFrameTime;
            lastFrameTime = currentTime;

            let needsRedraw = false;

            // Update animation progress for all dots
            questionsData.forEach((q, idx) => {
                const isHovered = (hoveredDotIndex === idx);
                const target = isHovered ? 1 : 0;
                const current = dotAnimationProgress[idx] || 0;

                if (Math.abs(current - target) > 0.01) {
                    // Smooth transition (133ms duration - 50% faster than original 200ms)
                    const speed = 1 / 133; // Progress per millisecond
                    const delta = (target - current) * Math.min(speed * deltaTime, 1);
                    dotAnimationProgress[idx] = Math.max(0, Math.min(1, current + delta));
                    needsRedraw = true;
                } else {
                    dotAnimationProgress[idx] = target;
                }
            });

            if (needsRedraw) {
                redrawCanvas();
                animationFrameId = requestAnimationFrame(animateCanvas);
            } else {
                animationFrameId = null;
            }
        }

        function startAnimation() {
            if (!animationFrameId) {
                lastFrameTime = performance.now();
                animationFrameId = requestAnimationFrame(animateCanvas);
            }
        }

        function drawKnowledgeHeatmap(width, height) {
            const gridSize = 40;
            const sigma = 0.15; // Gaussian kernel width

            // Create a 2D grid of knowledge values
            const grid = [];
            for (let gy = 0; gy < gridSize; gy++) {
                grid[gy] = [];
                for (let gx = 0; gx < gridSize; gx++) {
                    const x = gx / (gridSize - 1);
                    const y = gy / (gridSize - 1);
                    
                    // Calculate knowledge at this point based on nearby correct/incorrect answers
                    let knowledge = 0;
                    let totalWeight = 0;
                    
                    questionsData.forEach((q, idx) => {
                        const dx = x - q.x;
                        const dy = y - q.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const weight = Math.exp(-(dist * dist) / (2 * sigma * sigma));
                        
                        if (userResponses[idx] !== undefined) {
                            const isCorrect = userResponses[idx] === q.correctIndex;
                            knowledge += weight * (isCorrect ? 1 : 0);
                            totalWeight += weight;
                        }
                    });
                    
                    grid[gy][gx] = totalWeight > 0 ? knowledge / totalWeight : 0.5;
                }
            }

            // Draw heatmap
            const cellWidth = width / (gridSize - 1);
            const cellHeight = height / (gridSize - 1);

            for (let gy = 0; gy < gridSize - 1; gy++) {
                for (let gx = 0; gx < gridSize - 1; gx++) {
                    const value = grid[gy][gx];
                    let color = viridisColor(value);

                    // Darken if this is the hovered cell
                    if (hoveredHeatmapCell && hoveredHeatmapCell.gx === gx && hoveredHeatmapCell.gy === gy) {
                        color = darkenColor(color, 0.15);
                    }

                    ctx.fillStyle = color;
                    ctx.fillRect(
                        gx * cellWidth,
                        gy * cellHeight,
                        cellWidth + 1,
                        cellHeight + 1
                    );
                }
            }
        }

        function viridisColor(value) {
            // Bronze-to-Green colormap (complementary to Dartmouth Green)
            const colors = [
                [139, 69, 19],    // Saddle Brown (low)
                [184, 134, 11],   // Dark Goldenrod
                [218, 165, 32],   // Goldenrod
                [0, 133, 66],     // Medium Green
                [0, 105, 62]      // Dartmouth Green (high)
            ];

            const scaled = value * (colors.length - 1);
            const idx = Math.floor(scaled);
            const t = scaled - idx;

            if (idx >= colors.length - 1) {
                const c = colors[colors.length - 1];
                return `rgba(${c[0]}, ${c[1]}, ${c[2]}, 0.8)`;
            }

            const c1 = colors[idx];
            const c2 = colors[idx + 1];
            
            const r = Math.round(c1[0] + (c2[0] - c1[0]) * t);
            const g = Math.round(c1[1] + (c2[1] - c1[1]) * t);
            const b = Math.round(c1[2] + (c2[2] - c1[2]) * t);

            return `rgba(${r}, ${g}, ${b}, 0.8)`;
        }

        function darkenColor(colorString, amount = 0.2) {
            // Parse RGB/RGBA color string and darken it
            const matches = colorString.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
            if (!matches) return colorString;

            const r = Math.floor(parseInt(matches[1]) * (1 - amount));
            const g = Math.floor(parseInt(matches[2]) * (1 - amount));
            const b = Math.floor(parseInt(matches[3]) * (1 - amount));
            const a = matches[4] !== undefined ? parseFloat(matches[4]) : 1;

            return `rgba(${r}, ${g}, ${b}, ${a})`;
        }

        function drawQuestionMarkers(width, height) {
            questionsData.forEach((q, idx) => {
                const baseX = q.x * width;
                const baseY = q.y * height;
                const radius = 12;

                const wasAnswered = userResponses[idx] !== undefined;
                const isCorrect = userResponses[idx] === q.correctIndex;

                // Get animation progress for this dot (0 = not hovered, 1 = fully hovered)
                const animProgress = dotAnimationProgress[idx] || 0;

                // Calculate hover offset (3px up and right when fully hovered)
                const offsetX = 3 * animProgress;
                const offsetY = -3 * animProgress;
                const currentX = baseX + offsetX;
                const currentY = baseY + offsetY;

                let baseColor;
                if (!wasAnswered) {
                    // Unanswered - intermediate knowledge (goldenrod)
                    baseColor = 'rgb(218, 165, 32)';
                } else if (isCorrect) {
                    // Correct - high knowledge (Dartmouth Green)
                    baseColor = 'rgb(0, 105, 62)';
                } else {
                    // Incorrect - low knowledge (saddle brown)
                    baseColor = 'rgb(139, 69, 19)';
                }

                // Darken color when hovered
                const color = animProgress > 0 ? darkenColor(baseColor, 0.2 * animProgress) : baseColor;

                // Draw drop shadow at original position when hovered
                if (animProgress > 0) {
                    const shadowRadius = radius + (2 * animProgress);
                    ctx.save();
                    ctx.shadowColor = `rgba(0, 0, 0, ${0.3 * animProgress})`; // Reduced from 0.5 for subtlety
                    ctx.shadowBlur = 16 * animProgress; // Increased from 8 for larger blur
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;

                    ctx.beginPath();
                    ctx.arc(baseX, baseY, shadowRadius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(0, 0, 0, ${0.2 * animProgress})`; // Reduced from 0.3 for subtlety
                    ctx.fill();
                    ctx.restore();
                }

                // Draw marker with white border (at current position with offset)
                ctx.beginPath();
                ctx.arc(currentX, currentY, radius + 2, 0, Math.PI * 2);
                ctx.fillStyle = 'white';
                ctx.fill();

                ctx.beginPath();
                ctx.arc(currentX, currentY, radius, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();

                // Draw question number
                ctx.fillStyle = 'white';
                ctx.font = 'bold 11px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText((idx + 1).toString(), currentX, currentY);
            });
        }

        function getHeatmapCell(mouseX, mouseY, width, height) {
            const gridSize = 40;
            const cellWidth = width / (gridSize - 1);
            const cellHeight = height / (gridSize - 1);

            const gx = Math.floor(mouseX / cellWidth);
            const gy = Math.floor(mouseY / cellHeight);

            if (gx >= 0 && gx < gridSize - 1 && gy >= 0 && gy < gridSize - 1) {
                // Return cell center in normalized coordinates
                const centerX = (gx + 0.5) / (gridSize - 1);
                const centerY = (gy + 0.5) / (gridSize - 1);
                return { gx, gy, centerX, centerY };
            }
            return null;
        }

        function showHeatmapTooltip(canvasRect, cell) {
            tooltip.innerHTML = `
                <div class="tooltip-question">Heatmap Cell</div>
                <div class="tooltip-status">
                    <span>Position: (${cell.centerX.toFixed(3)}, ${cell.centerY.toFixed(3)})</span>
                </div>
            `;

            tooltip.classList.remove('tooltip-hidden');
            setTimeout(() => tooltip.classList.add('visible'), 10);

            // Calculate cell center position on screen
            const cellCanvasX = cell.centerX * canvasRect.width;
            const cellCanvasY = cell.centerY * canvasRect.height;
            const cellScreenX = canvasRect.left + cellCanvasX;
            const cellScreenY = canvasRect.top + cellCanvasY;

            // Get tooltip dimensions
            const tooltipRect = tooltip.getBoundingClientRect();
            const offset = 15;

            // Determine quadrant based on normalized position
            const isLeftHalf = cell.centerX < 0.5;
            const isTopHalf = cell.centerY < 0.5;

            let left, top;

            // Position tooltip based on quadrant
            if (isLeftHalf) {
                left = cellScreenX + offset;
            } else {
                left = cellScreenX - tooltipRect.width - offset;
            }

            if (isTopHalf) {
                top = cellScreenY + offset;
            } else {
                top = cellScreenY - tooltipRect.height - offset;
            }

            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }

        function addInteractivity(width, height) {
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = (e.clientX - rect.left) / rect.width * width;
                const mouseY = (e.clientY - rect.top) / rect.height * height;

                // Check for question dot hover (priority over heatmap)
                let hoveredQuestion = null;
                questionsData.forEach((q, idx) => {
                    const x = q.x * width;
                    const y = q.y * height;
                    const dist = Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2);

                    if (dist < 15) {
                        hoveredQuestion = { ...q, index: idx };
                    }
                });

                if (hoveredQuestion) {
                    // Question dot takes priority
                    hoveredDotIndex = hoveredQuestion.index;
                    hoveredHeatmapCell = null;
                    showTooltip(rect, hoveredQuestion);
                    canvas.style.cursor = 'pointer';
                    startAnimation();
                } else {
                    // Check for heatmap cell hover
                    const cell = getHeatmapCell(mouseX, mouseY, width, height);

                    if (cell) {
                        hoveredDotIndex = null;
                        hoveredHeatmapCell = cell;
                        showHeatmapTooltip(rect, cell);
                        canvas.style.cursor = 'crosshair';
                        redrawCanvas(); // Immediate redraw for heatmap (no animation)
                    } else {
                        hoveredDotIndex = null;
                        hoveredHeatmapCell = null;
                        hideTooltip();
                        canvas.style.cursor = 'default';
                        startAnimation(); // Animate dots back to normal
                    }
                }
            });

            canvas.addEventListener('mouseleave', () => {
                hoveredDotIndex = null;
                hoveredHeatmapCell = null;
                hideTooltip();
                startAnimation();
            });
        }

        function showTooltip(canvasRect, question) {
            const wasAnswered = userResponses[question.index] !== undefined;
            const isCorrect = userResponses[question.index] === question.correctIndex;

            let status, statusColor;
            if (!wasAnswered) {
                status = 'Unanswered';
                statusColor = 'rgb(218, 165, 32)';  // Intermediate knowledge (goldenrod)
            } else if (isCorrect) {
                status = 'Correct';
                statusColor = 'rgb(0, 105, 62)';  // High knowledge (Dartmouth Green)
            } else {
                status = 'Incorrect';
                statusColor = 'rgb(139, 69, 19)';  // Low knowledge (saddle brown)
            }

            tooltip.innerHTML = `
                <div class="tooltip-question">Q${question.index + 1}: ${question.question}</div>
                <div class="tooltip-status">
                    <div class="tooltip-dot" style="background: ${statusColor};"></div>
                    <span>${status}</span>
                </div>
            `;

            tooltip.classList.remove('tooltip-hidden');
            setTimeout(() => tooltip.classList.add('visible'), 10);

            // Calculate dot position on screen
            const dotCanvasX = question.x * canvasRect.width;
            const dotCanvasY = question.y * canvasRect.height;
            const dotScreenX = canvasRect.left + dotCanvasX;
            const dotScreenY = canvasRect.top + dotCanvasY;

            // Get tooltip dimensions
            const tooltipRect = tooltip.getBoundingClientRect();
            const offset = 15;  // Offset from dot (in pixels)

            // Determine quadrant based on normalized position (0-1 range)
            // This ensures tooltips stay within heatmap bounds
            const isLeftHalf = question.x < 0.5;
            const isTopHalf = question.y < 0.5;

            let left, top;

            // Position tooltip based on quadrant
            if (isLeftHalf) {
                // Dot is on left side - show tooltip to the right
                left = dotScreenX + offset;
            } else {
                // Dot is on right side - show tooltip to the left
                left = dotScreenX - tooltipRect.width - offset;
            }

            if (isTopHalf) {
                // Dot is on top half - show tooltip below
                top = dotScreenY + offset;
            } else {
                // Dot is on bottom half - show tooltip above
                top = dotScreenY - tooltipRect.height - offset;
            }

            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }

        function hideTooltip() {
            tooltip.classList.remove('visible');
            setTimeout(() => {
                tooltip.classList.add('tooltip-hidden');
            }, 200); // Match CSS transition duration
        }

        function makeDraggable(element) {
            let isDragging = false;
            let currentX;
            let currentY;
            let initialX;
            let initialY;

            element.addEventListener('mousedown', (e) => {
                // Only start drag if clicking on the element itself, not child elements
                isDragging = true;
                element.classList.add('dragging');

                initialX = e.clientX - element.offsetLeft;
                initialY = e.clientY - element.offsetTop;

                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    e.preventDefault();

                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;

                    // Get parent container bounds
                    const parent = element.parentElement;
                    const parentRect = parent.getBoundingClientRect();
                    const elementRect = element.getBoundingClientRect();

                    // Constrain within parent bounds
                    const maxX = parentRect.width - elementRect.width;
                    const maxY = parentRect.height - elementRect.height;

                    currentX = Math.max(0, Math.min(currentX, maxX));
                    currentY = Math.max(0, Math.min(currentY, maxY));

                    // Update position (remove any existing top/bottom/left/right)
                    element.style.top = currentY + 'px';
                    element.style.left = currentX + 'px';
                    element.style.right = 'auto';
                    element.style.bottom = 'auto';
                }
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    element.classList.remove('dragging');
                }
            });
        }

        function restart() {
            currentQuestion = 0;
            userResponses = [];
            selectedOption = null;
            mapSection.classList.add('hidden');
            quizSection.classList.remove('hidden');
            progressFill.style.width = '0%';
            hideTooltip();
            renderQuestion();
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            if (!mapSection.classList.contains('hidden')) {
                generateKnowledgeMap();
            }
        });
    </script>
</body>
</html>
The world generates an incomprehensible amount of data every day. And that growth curve is exponential, so the amount of data we generate only gets bigger. That data can come from social media, security cameras, even telescopes. There's power in having that data, but the real power comes from our ability to analyze it using programming. A dataset is just a structured collection of data, typically used for analysis. For example, we could write a program to process a dataset of millions of social media posts made in the last year. Our analysis could identify the peak topics for the year, the growth and popularity of certain slang words, or trends in public sentiment toward specific people or products. Individuals or companies may then use that analysis to inform their actions, like a streaming service might look at public sentiment to decide which shows to renew, or an aid organization might look at trending topics to help identify areas of need in the aftermath of a natural disaster. But when there's so much data, how can our programs possibly make sense of it? As our data gets more complex, a list might not always fit our needs. If we have a hundred different data fields, trying to keep track of which information is at which index is going to become quite annoying. And sometimes there are relationships we need to express in our data, like a social media post and the location it was made from, or names and emails, or a school district might have schools, which have classes, which have students. Organizing that data in a useful way calls for more complex data structures. The data structure we choose for a particular program depends entirely on our use case. Certain data structures are better at certain things. So imagine you have a bunch of t-shirts that you need to store. One organizational strategy might be to throw them on the ground in your room. Now this is highly optimized for the add a new t-shirt operation. When I'm done using a shirt, I could just throw it on the ground. But if I need to find a specific shirt, that could take me a while. This t-shirt organization isn't optimized for the find operation. Now let's say instead I go for the strategy of folding my shirts and putting them away in a drawer. Adding a new shirt takes a bit longer now because I need to fold it first. Finding a shirt on average is a bit faster. I might have to dig through the pile, but at least all the shirts are in one place. I am however highly optimized for the find the most recently used shirt operation. If I wear the same few shirts over and over again, they'll always be back on the top of the pile. Which organizational strategy I choose depends on the operations that I think will be the most useful to me. If I really don't care about which t-shirt I wear, then maybe the find operation isn't all that useful to me. So I'd optimize for the most efficient add a t-shirt operation. Okay, but back to programming. If our t-shirts are our data and our organizational strategy is our data structure, then we need to choose our data structure based on how we think we'll use the data in our program. And that can be half the battle when we design programs. Choosing the right organization for our data can make our code a lot easier to write and our program a lot more efficient to run. So let's get into exploring some different data sets, the problems they can be used to solve, and the choice of data structures we use along the way. So you have a bunch of related data. You could store them all in separate named variables, but now you have a bunch of variables to manage. Or you could store them all together in a list, but then you need to remember which value is at which index. What if we could have the best of both worlds? We store all the data in one place, but we attach a meaningful label to each value. In Python, we call this data structure a dictionary. A dictionary stores data in key value pairs. Instead of accessing a value based on its position or index, we access a value based on its key. So, for example, we might look up the value associated with the key duration. To define a new dictionary, we use curly brackets. So here we have an empty dictionary named video. For each key value pair, we put the key, a colon, and then the value. So this item has the key title and the value user input. We separate the items of a dictionary with commas. So this dictionary has five items or five key value pairs. We can also count the number of items using the built-in length function. In Python, technically the computer does maintain the order in which the items are defined. However, logically, dictionaries are unordered data structures. The ordering of the key value pairs doesn't hold a particular meaning for the computer. So this dictionary and this dictionary are equivalent. We define a dictionary using curly brackets, but to access values, we still use square brackets. We put the name of the dictionary, square brackets, and the key we want to access, which tells the computer to look up the value associated with that key. If the dictionary doesn't have an item with that key, we get a key error. Note that the lookup only goes in one direction. We can look up values using their keys, but we can't look up keys using their values. This means that keys must be unique, but values don't have to be. Dictionaries are mutable, so we can add and update items after the dictionary is defined. We write an assignment statement with the dictionary name, square brackets, and the key of the item we want to update. On the right-hand side then, we put the updated value. If the key doesn't already exist in the dictionary, this adds a brand new item with this key and this value. If the key does already exist, this overwrites the key's current value, because we can't have two items with the same key. How would we know which view's value to use? We can check if a key already exists in a dictionary using the in operator. The in operator only checks against the dictionary's keys. It does not search the dictionary values. We can store any type of data we want in a dictionary. Dictionary values can be strings, integers, floats, booleans, lists, even other dictionaries. The keys also don't have to be strings. They just need to be unique and an immutable data type. So we might also have dictionaries with integer keys. Dictionaries are a simple yet enormously powerful way to organize data. They can represent basic relationships between pieces of data, like usernames and passwords, or products and prices. They can also represent any kind of structured data record, where the keys serve as labels for the individual data fields. And because this key value structure is so flexible, yet easy to understand, most of the data passed around the internet is represented in a dictionary like format called JSON, or JavaScript object notation. So no matter what data you're trying to represent, if the ordering or sequence of your data isn't relevant, you can likely solve that problem with a dictionary. You store the key value pairs and you look up values based on their keys. How does the computer store a dictionary in memory? Here we have a dictionary where the keys are the names of files and the values are the sizes of those files in megabytes. With dictionaries, we know that we can look up a value using its key. But how does the computer represent that relationship? In memory, the computer just stores the key value pairs in a list-like structure. Each slot in the list is either empty or contains a matching key and value. For this to work, the computer just needs one thing, a deterministic way to know which key value pair is in which slot. The solution is surprisingly simple. The computer uses a function that converts each key to a deterministic integer, and then it uses that integer as an index into the list. We call this a hash table and the function a hash function. A hash function can be implemented using many different algorithms. The important property is that for any given key, the function returns the same integer every time. This is why dictionary keys need to be immutable to guarantee that the key's hash is always the same. Now Python, of course, uses a sufficiently complex and well-studied algorithm for its hash function that works on any immutable data type. But for now, let's assume something a bit simpler, so it's easier for us to trace. Let's say our simplified hash function that only works on strings just returns the length of the key. When we define a dictionary, the computer starts by allocating space and memory for that list. Initially, it allocates a small number of slots, let's say eight. Then it gets to work storing each item. For each item, it takes the key and passes it into the hash function. So for the key bot.py, we would get the hash six. So the computer finds a slot at index six, and then it stores both the key and the value here. And technically, it also stores the hash. And then we do the same thing for all of the other items. We hash the key to get the index, and then we store the key value pair in that slot. This might raise a few questions for you, like what if the hash is greater than the number of slots? The computer uses the modulo operator to scale the hash down to the number of slots. The modulo operator, remember, takes the remainder of the division. So if we do 11 modulo eight, we get back three. So the flights.csv item goes in the slot at index three. Now that we have our dictionary defined, let's trace through a few accesses and updates. The right hand side of this assignment statement accesses the value associated with the key cat.jpg. So the computer passes the key cat.jpg into the hash function. And then it takes modulo eight since there are eight slots. That gives us the index seven. So we go to slot seven, double check that the key matches. And since it does, we grab the value stored there. We substitute that back in, and then we store that float in a new variable called photosize. This assignment statement reassigns the value associated with the key flights.csv. So again, we hash the key flights.csv, take modulo eight, which gives us three, go to the slot index three, and verify that the key matches. Since it does, the computer updates the item in the slot to have the value 5.3. Now we add a new item to the dictionary. But do you see any problems with this key? nd8.pdf has the same hash as another one of our keys. We call this a collision. So what does the computer do? The algorithm for resolving collisions can vary. It just needs to be deterministic. You could do something as simple as use the next empty slot. If we then access the key later, we would check in the original slot, see that that key doesn't match, and then search the subsequent slots until we find the one with our key. This, of course, is not the most efficient algorithm. Python's actual collision handling algorithm is much more mathematically complex in order to minimize the number of slots we need to search. And unlike our simplified length algorithm, the actual Python hashing algorithm tries to minimize the number of collisions in the first place. And on top of all that, if the list of memory starts to get somewhat full, the computer will allocate a new larger list and copy all of the items over, which gives it more space to spread out. Python makes a few other optimizations here and there, like it also stores some extra data to keep track of the order in which items were inserted. But at its core, the magic of dictionaries comes from hashing. We have the power to look up a value using its key because we can hash the key to a deterministic index. How do we iterate over the items in a dictionary? There's no indices like in lists, so we can't use for i and range. But we can use a for each loop. We have the keyword for, the loop variable name, the keyword in, and then the dictionary name, followed as always by a colon. But what do you think the loop variable holds on each iteration? When we iterate over a dictionary, the loop variable holds the next key. So we name our loop variable descriptively, based on what the keys in the dictionary represent. Here, my dictionary keeps track of word frequencies in a text. So my keys are all words, and my values are all counts. Python iterates over dictionaries in insertion order, meaning the order the items were added. So on the first iteration, the loop variable word will hold the key it. On the second iteration, it'll hold the key is. And on the third iteration, it'll hold the key what. And now that we've reached the end of the dictionary, the loop terminates. If I want the associative value inside the loop body, I just access it using the key. So now this prints out its value to is its value to and then what's value one. What if I want to know what percentage of words were used more than once, I need to keep track of the number of words whose count is greater than one. The total number of unique words is just the length of the dictionary. I'm using a very small dictionary here so we can trace it. But you can imagine this analysis will be a lot cooler with a dictionary with more words. Notice that my loop body only really cares about the values and never uses the key on its own. For situations like this, Python provides two dictionary methods, values and items. There is also a keys method, though we don't need it here. This means we can iterate over a dictionary in three ways by key, by value, and by item or key n value. We can achieve all the same things just by iterating by key. But these alternate syntaxes help make our code a bit cleaner depending on what we're trying to do. So back to our program, we can change it to iterate by value. We call the values method on our dictionary. And then we update our loop variable since now it represents the next value in the dictionary. Okay, how about iterating by item? We call the items method on our dictionary. And then the loop variable holds the next item, meaning the next key value pair. But what data type is that? In Python, we call this a tuple. A tuple is just the immutable form of a list defined with parentheses instead of square brackets. We can index into a tuple, but we can't mutate it. So if we want to access the key, it'll be the first element in the tuple. And the value is the second element. A bit annoying to have to write that out, because the key will always be at index zero, and the value will always be at index one. Fortunately, Python gives us a shortcut called variable unpacking, we can unpack an iterable type like a tuple or a list into several different variables, all in a single assignment. So we can unpack our item tuple into its key and value by putting a comma in between the two variable names. Word will contain the first element and count will contain the second. And to make this even easier, we can inline this unpacking into our for statement. On each iteration, the loop variable word contains the next key and the loop variable count contains the next value. Be extra careful with this syntax, because it's easy to forget the comma or the dot items and end up with a weird error. We can calculate the same result just iterating by key. But if we need both the key and the value in the loop body, iterating by item often makes this a lot cleaner. So how do these methods actually work? The keys, values and items methods all return a special dictionary view type. This is an iterable type, meaning we can iterate over it. But it's not quite a list. Instead, it's an optimized view into the existing dictionary. You can think of it like a special little window into the computer's memory, where we can peek in on specific parts of the dictionary, like the values method gives us a window into just the dictionary values. We can cast a dictionary view to a list if we need to index into it. But if we're just iterating over it, the cast is not necessary. In fact, it's not optimal. As soon as we cast this dictionary view to a list, the computer copies over all of these values to a new location in memory. Whereas if we just use the dictionary view directly, we're just peeking at the memory where the original dictionary is stored. Implementation aside, the big takeaway is that we can iterate over a dictionary by key by value and by item. The choice is just up to what data you need. Let's design a program with dictionaries. We run a small bakery, which means that we spend a lot of our time just managing our inventory. At the start of every week, we have to plan out which recipes we're going to make, what ingredients we need, and then place orders for those ingredients with our vendors. At the same time, we have to pay attention to our ingredient costs to make sure the recipes we're choosing make good business sense on top of being delicious. So let's build a program to help do our inventory management. I started by inputting all of the data I have. First, I represented all of my bakery recipes as dictionaries, where the keys are the ingredients and the values are the amounts. To make it simple, I put all of the amounts in grams, except for items like eggs or bananas. Those numbers are just account. In a separate module, I recorded my inventory. Right now, I'm out of stock of a lot of ingredients. And finally, I estimated the per unit cost of each ingredient. I know I can't technically buy a single gram of flour, but representing my cost this way helps with my weekly accounting. Then I'll create one last module to hold all my functions. But before we get into the code there, let's jump back to our main module and outline how we want this logic to work. I'll start with a simplified case where we just make one type of recipe a week. We need to compare our recipe against our current inventory to see which ingredients were missing. This will tell us how much of each ingredient we need to order. And once we have that order, then we can calculate the cost, which we'll need to take in our prices dictionary. One last thing to consider. This recipe only represents a single batch of cupcakes, which is not going to be enough for an entire week. So let's add one last function that can take in a recipe and a number of batches, which can then return out the total ingredients needed. Of course, if I run my program now, I get a runtime error because I didn't define any of those functions. So let's jump back into the manager module and get to work. Let's start with the scale recipe function. Now because of pass by assignment, we don't want to mutate this recipe parameter directly. We might need the original version of this recipe later. And if we mutate it inside this function, it'll affect the dictionary passed in. So instead, let's accumulate a new dictionary. We scale up an ingredient just by multiplying its amount by the number of batches. So to scale up the whole recipe, we need to iterate over every ingredient. And since we need both the ingredient name and the amount, it's easiest to reiterate by item. We can do a real easy check by testing one batch. And then we should be able to easily verify the result for 10 batches. This looks good. So let's move on to the place order function. The place order function takes in two dictionaries, the current inventory and the recipe. And it returns out a new dictionary with the missing ingredients we need to order. But here's the question, which of these dictionaries do we iterate over? Well, there might be ingredients in our inventory that aren't in our recipe. Like if we're making cupcakes, we don't need the bananas. But there might also be ingredients in our recipe that aren't in our inventory. Like we may be out of eggs. For this to work, we need to check every ingredient in our recipe to see if our inventory has enough of it, which means the thing we need to iterate over is our recipe. On each iteration, then we check how much of that ingredient we have in our inventory. If that amount is greater than or equal to the amount that our recipe needs, then we're fine. But if it's not, then we need to order more. And that amount is just the amount we need minus the amount that we have. And if we run our program now, we have a key error, I guess. This stack trace tells us that our inventory dictionary doesn't have the key flower, we might be out of stock of ingredients a lot. So our function should try and handle it. If the key doesn't exist in our dictionary, that means we have zero of that ingredient, and thus should order the full amount required by the recipe. Sounds like a good time for the get method. Because instead of raising a key error, we want to default the amount to zero. Get is a method, so we call it using dot syntax. And then it takes in the key to look up, followed by the default value. Much better. On to our last function, get cost. It takes in the ingredients in our order, and our dictionary of unit prices. This time, instead of returning a dictionary, we want to return a float, which is the total cost for all the ingredients in the order. And since the number is a price, we'll round it to two decimal places. Here, it makes the most sense to iterate over the order, since those are really the only ingredients we care about. The calculation here is pretty straightforward. We get the price per unit for the ingredient. We multiply it by the amount we need. And we add that to the total cost. But what if the ingredient isn't in the prices dictionary? Should we use the get method here too? In this case, it's not immediately clear. Because what would the default value be? If we make it zero, then we're effectively saying that ingredient is free. The caller would have no idea that we secretly skipped an ingredient. I might argue that the best option here is to let it raise the key error. Because if we're missing the price for an ingredient, it's impossible to correctly calculate the order cost. The only way to fix the program would be for someone to come in and add that data to the price per unit dictionary, which the key error at least brings attention to. So let's leave this as a standard dictionary access. With all our functions written out now, we can run through a few different recipes and compare their ingredient costs. The next step would be to extend this to work across multiple weeks and multiple recipes, where I update the state of my inventory based on the ingredients I've used. We have a bunch of data and we stored it in a dictionary. But now we have 20 fields, 100 fields, and all of this data is getting kind of hard to read. I have to scan through all of these fields just to find the piece of data that I need. Now, remember when this same thing happened with our code? When our programs got to be too long at the top level, we started breaking them down into functions. We can apply that same idea to our data. When our data gets to be too big at the top level, we can break it down into smaller data structures, which we can then combine together. By organizing our data into meaningful chunks, we make it easier to understand for all of the programmers out there trying to use it. Let's take a look at a slightly smaller example. Here we have data for a student record. Right now, all of the fields are stored at the top level, but there are relationships in this data that aren't being clearly represented. Like, all of these fields are for an address, and all of these fields are for different classes. Wouldn't it make more sense if all of the data for a single class was grouped into its own dictionary? We call this process data modeling. We design a meaningful structure for our data that makes it easier to understand and use. So I might group all of these fields for an address into a smaller address dictionary, and then I might group all of the fields related to the student's guardian into its own guardian dictionary, and so on and so on, adding structure to my data by nesting smaller data structures inside the larger dictionary. You can think of this just like adding structure to a document. You take all of those words and then you group them into sections, and within those sections you have subheadings, and maybe those subheadings have other subheadings, until finally you have it organized. So someone can come in and use that structure to easily find the information they're looking for. Okay, but who's making data structures that are this complicated in the first place? It turns out pretty much the entire internet. The websites and apps that you use have both a backend and a frontend component. The backend is all of the main program logic. It might retrieve some information from a database, process or filter it in some way, and then perform some calculations on it. The frontend requests specific data from the backend, and then it displays it on the screen in an appealing and useful way. In most cases, the end user only interacts with the frontend. But what's happening in the middle? This layer is called an API, or Application Programming Interface. An API is essentially a special set of functions that a backend program has made available over the internet. For example, when you do navigation in a maps app, the frontend needs to first request all of that directions data from the backend. So maybe it calls a specific API endpoint called get directions, and then the frontend passes in some information about what directions the user is looking for. The backend then processes that request. It likely retrieves some data from a database and then does some calculations with it, returning the final result back through the API to the frontend, which the frontend then displays as this nice little map overlay. The raw data that came through that API endpoint, however, was formatted just like a dictionary. This dictionary format is called JSON, and it's the format most APIs on the web use to transmit data. In most of the programs we write, we won't be the ones creating the data, we'll just be using it. So we can only hope that whoever did create it modeled the data well. Our job as a programmer then is to learn how to access the fields in a nested data structure, and then to do something interesting with it. What happens if we put a dictionary inside another dictionary? Dictionary values aren't limited to just primitive data types. The dictionary keys need to be immutable, but the values can be dictionaries or lists. We call this nested data because we're nesting one data structure inside of another. But how do we access something that's nested multiple layers deep? This dictionary has location data about a place called Gasworks Park. Just like normal, we use the key to access the value. And we can use an assignment statement to update the value associated with the key rating. Now, what about the item with the key types? Again, we can access its value using the key. But what data type is this value? The important thing to pay attention to here is what symbol comes right after the colon. If it's a quotation mark, that value is a string. If it's a number, that value is an integer or float. But if that symbol is a bracket, that value is a data structure. Remember that we define a list using square brackets, and we define a dictionary using curly brackets. So if we see a square bracket, our dictionary value is a list. Or if we see a curly bracket, our dictionary value is another dictionary. Looking at the square bracket, then we know the value for the key types is a list. We can store that value in a variable, and then we can access it just like we would any other list. So if I access the element at index zero, I get the string ToristAttraction, because that's the first element in the list. But here's the fun part. I can combine that two part access into a single expression. I skipped the intermediate step of storing that list in its own variable, and instead just tack on the second access after the first. This might look a bit intimidating, but we know how to evaluate expressions. We just need to take it one step at a time. We follow the order of operations, and we evaluate from left to right. So the first part of our expression accesses the variable gasworks. And from that, it looks up the key types that gives us our list, which we can substitute back into the expression. And now we simplify again. We're operating on the list now, and we're accessing the element at index zero. So this whole thing evaluates down to the string ToristAttraction, which we store in the variable first type. Now, just because this list is nested inside a dictionary doesn't mean there's anything special about it. We can operate on it just like we would any other list. We can use the in operator to check if an element exists in the list. That's true. Or we can mutate the list and use the append method to add an element to the end. Let's move on to another item. What data type is the value for the key amenities? Notice this curly bracket. That means we have a dictionary. So our variable features holds this inner dictionary, and we can access the values of that inner dictionary as normal. So we look up the value associated with the key parking, which gives us the Boolean true. And just like our magic before, we can inline all those accesses into a single expression. Our accesses just need to go outside in left to right. So the first part of our expression accesses the value for the key amenities, which is a dictionary. We substitute that in, and then we access the value in that dictionary associated with the key parking. And if say they close the restrooms for renovation, I can update the value in that inner dictionary using an assignment statement with that same two part access. Now let's take a look at all that in the code editor. And let's go one level deeper. I've added a new item to our gas works dictionary with the key reviews. What is going on with this value? We have square brackets here, but we also have curly brackets. Remember, though, what we need to pay the most attention to is what symbol comes directly after the colon. And that's a square bracket. So that means the data type of this value is a list. So let's access that first and print it out. Since it's a list, we can index into it. So let's see what element is at index zero. That starts with a curly bracket. So that must mean this element is a dictionary. And then I guess we can access the values of that dictionary using the keys, like we can get the value associated with the key author, which gives us the author of that first review. So rewind, my gas works dictionary has an item reviews whose value is a list of dictionaries. First, I access the list, then I access the element at index zero, which is a dictionary. And then I access the value in that dictionary associated with the key author. If I didn't realize I was working with a list of dictionaries, and say I skipped the second access, I will get a type error because I will be trying to access the list using a string dictionary key instead of an integer list index. When doing nested accesses, we just need to pay careful attention to the order, we always go from the outside in. And if we're ever unsure, we can just take it one step at a time. Let's design a program that uses nested data. Here we have a data set of emergency response incidents in New York City. We stored our data set and a list of dictionaries where each dictionary record represents a single incident. The city wants to analyze this data set to better understand any patterns in the timings, types or locations of incidents, and then apply those insights to make sure enough of the right kind of first responders are available. Let's start by grouping the incidents by type. This will tell us which incidents are the most common. And that should tell us which first responders are most in demand, the fire department, law enforcement, or EMTs. Now, we could write a function that takes in the data set and a type, which counts how many incidents of that type we have. But there are so many different types of incidents. For one, how do I know what all the types are so that I know what to pass in? And two, if I call this function once for 30 different types, then I'll be iterating over my data set 30 separate times. And that sounds pretty inefficient, especially if my data set gets larger. Instead, this feels like a good use case for a data transformation. That is, I iterate over my data set just once, and I convert it to a more useful data structure. In this case, I might want a dictionary that maps the type of incident to a count of the number of incidents. So let's get our accumulator pattern going. We start by initializing an empty dictionary. And then we want to iterate over every incident. Since our data set is a list of dictionaries, our loop variable will hold the next incident record on each iteration. And then inside the loop body, we just want to increment the count for the current incident's type. And then finally, we return our new dictionary at the end. All right, let's jump over to main.py and test that out. We'll import our incident's module and our OEM module, which contains our data set. And then we'll call our count by type function. And that gives us a key error. Why? Well, back in our loop body, we increment the count for the current type. But what if that type doesn't exist in the dictionary yet? So we need to first check if that type exists. And if it doesn't, we need to add a new item instead of incrementing it. We can do this with the in operator, but we can also use the get method here. On the right hand side of the assignment, we access the current count for that type, defaulting it to zero. And then we just add one to increment it. Now let's try this again. No more key error, great. But there are actually quite a lot of types in here. And it looks like all the incident types use a common prefixing scheme. There's the main type like fire, a dash and then a more descriptive subtype. I'm just trying to understand the main category of incident. Like if it's a fire, then the fire department is needed. So I don't really care about this subtype. It'd be more helpful to know how many total fires there were. So let's normalize those types of it. We'll use the split method to split on that dash. And then we'll take the first element of that list, which should be the broad category. Much better. And to clean up that output a bit, maybe I'll iterate over the dictionary and print out a nicely formatted sentence. On to our next analysis, we want to know when the busiest hour of the day is where busiest just means the most number of incidents. But how do we calculate that result from our dataset? To get that final result, it might be easiest to break down this problem into two steps. Where each step follows a very familiar pattern that we already know how to solve. First, we can do a data transformation that maps hour of the day to number of incidents. And then we can use that data structure to get the busiest hour. We just iterate over the dictionary and find the key or hour with the highest value. Let's start with the data transformation. If this sounds familiar, it's because we already solved this problem before. Except this time, instead of type, our keys are hour of the day. So let's copy the structure of the accumulator pattern we used before. But how do we get the hour of the day? Well, each incident record has a time field. And if we just take the first two characters of that string, that should tell us the hour. So we can just use a slice here and then cast that string to an integer. And we'll quickly print out that data structure to spot check that we did it correctly. Great. Now we just need to write the function that takes in that dictionary of hour to incident count. This effectively boils down to the problem find the key with the maximum value. So we'll want to iterate over the dictionary and keep track of the busiest hour we've seen so far. So that by the end of the loop, we'll have the absolute maximum. Since we need both the hour and the count, we'll iterate by item. And then on each iteration, we'll check if the current hours count is greater than the maximum. If it is that hour becomes our new maximum, and we update our variables accordingly. Putting all of our analysis together, then we see that the busiest hour of the day is 11am. And by far, the most common incident type is a fire. That tells us that we need the most staffing in the fire department and in the middle of the day. To really confirm this, we can next do a breakdown by both type and hour or cross reference by location. So we know which borough needs to having the most.
What I want to do in this video is make sure we really understand what's going on when we call our recursive Fibonacci function. So I'm going to assume that someone calls the function with an argument. So they call Fibonacci of, and they give pass 5 as an argument. I don't want to pick too large of a number for the argument, because otherwise I'll be explaining this forever. So let's try Fibonacci 5. So in this situation, within the context of this function, the parameter n right here is going to be equal to 5. So in that first pass, the parameter n is going to be equal to 5. And the way we wrote it, we said if n is less than 2, return n. Well, 5 is definitely not less than 2. So we're going to go to the else part of the if clause, or the else clause. And we say return Fibonacci of n minus 1 plus Fibonacci of n minus 2. So when I call this, it's essentially going to be reduced, if you want to think of it that way, or simplify it, or I guess it would return. This thing is going to be the same thing as Fibonacci of, remember, n was 5. So n minus 1 is 4 plus Fibonacci of n minus 2. Well, when we ran the function here, n was 5. So 5 minus 2 is 3. Well, these are just more function calls. So now we're going to go again. But now n is not 5. It's now 4 and 3. So let's try this out. So over here, n is equal to 4. So once again, 4 is not less than 2. So we don't do this part. We go to the else. So we're going to return Fibonacci of 4 minus 1, which is 3. So this is going to simplify to Fibonacci, or breakdown, I should say. Fibonacci of 4 minus 1, which is 3, plus Fibonacci of 4 minus 2, which is Fibonacci of 2. So this right over here will essentially return this. And this over here, on the right, Fibonacci of 3. Let me draw. Let me make it because it's going to get jumbled up soon. So this returns the stuff in magenta. And then the stuff I underlined in green will return. n is now 3. 3 is not less than 2. So you go here. Fibonacci of 3 minus 1, which is Fibonacci of 3 minus 1, which is Fibonacci of 3 minus 1 of 2, and plus Fibonacci of 3 minus 2, which is Fibonacci of 1. And then we're going to go over here. And we're going to have to calculate each of these things because these are just more calls to Fibonacci. And Fibonacci of 3, so you can see how this is getting pretty involved right now. In fact, I'm going to start writing Fib, short for Fibonacci so I don't run out of real estate. Fibonacci of 3, when you call it, n, 3 is not less than 2. So you're going to go here. That reduces to Fibonacci of 3 minus 2. So that is Fibonacci. I'll just write Fib, short for Fibonacci. Fibonacci of 2 plus Fibonacci of 3 minus 2, plus Fibonacci of 1. So it reduces to that or breaks down into that. And then over here, Fibonacci of 2. Fibonacci of 2, 2 is not less than 2. So we're going to have to return Fibonacci of 2 minus 1. So that's Fibonacci of 1 plus Fibonacci of 2 minus 2. So plus Fibonacci plus Fibonacci of 0. So it breaks down into those two calls to Fibonacci. And then over here, Fibonacci of 2, same thing. We made a call to Fibonacci of 2. That's going to break down just like this call to Fibonacci of 2 did. It will break down to a call to Fibonacci of 1 plus Fibonacci of 0. So we get that. And then we have Fibonacci of 1. This is interesting because when n is equal to 1, now all of a sudden this clause up here becomes relevant. Because now n is less than 2. It says return n. So this right here is going to simplify. This term right over here is going to simplify to 1. It's going to evaluate to 1. And then we look at all of these over here. Fibonacci of 2. We know that Fibonacci of 2 evaluates to Fibonacci of 1 plus Fibonacci of 0. So let me write that over here. So this over here is Fibonacci of 1 plus Fibonacci of 0. Fib is short for Fibonacci. And then we know Fibonacci of 1. 1 is less than 2. n is 1 here. So we're going to just return n. So this is going to return 1. Fibonacci of 1 just returns 1. Fibonacci of 0. Well, 0 is less than 2. It returns 0. Fibonacci of 0 returns 0. Fibonacci of 1, we've seen it. It returns 1. Fibonacci of 0 returns 0. And then Fibonacci of 1 returns 1. Fibonacci of 0 returns 0. So the whole time that the interpreter is processing this recursive function call, this recursive function call right over here, it kind of has to remember all of the previous how it got there. Because once it eventually gets down to the base cases, gets down to n equals 1 or 0, and actually gets a numeric response, it then has to build up to its previous response. So Fibonacci of 2 right over here. It's 1 plus 0. So Fibonacci of 2 is going to simplify to 1. This Fibonacci of 3 was going to be Fibonacci of 2 plus Fibonacci of 1. Those hit simplified to 1. So this is going to be 1 plus 1. This is going to be 2. We go over here. Fibonacci of 2. Fibonacci of 1 plus Fibonacci of 0. 1 plus 0. This is going to be 1. Fibonacci of 2. 1 plus 0. This is going to be 1. Fibonacci of 1. Well, that's just 1. And now we go up to this level. We're kind of reconstructing it back so that we get to the original function call. And I'm not going to go into the details of how does the interpreter actually doing that? This is actually a fascinating discussion. But I'll just think about how do we think about it, what's happening in this recursive function call, and why is it working? Why is it giving us the right answer? And then we go over here. Fibonacci of 4. Well, Fibonacci of 4 is the fourth Fibonacci term is the sum of the third and the second Fibonacci term, which we've already figured out. Those are 2 and 1. You take their sum. You get 3. The third Fibonacci term, by the definition of the Fibonacci sequence, is the sum of the first and the second terms. Those are each 1. 1 plus 1 is 2. The fifth Fibonacci number, the fifth term in the Fibonacci sequence, is the sum of the fourth and the third terms. Those are 3 and 2. 3 plus 2 is 5. So this thing right over here is going to evaluate to 5. So hopefully that clarifies a little bit of how this recursive program is actually working. What's neat about it is it wouldn't work if you didn't define the base cases, the Fibonacci of 1 or Fibonacci of 0. Then it would just keep calling itself forever and never get anywhere. The key with recursion is it can call itself as long as every time you call itself, it's making its way down to the base cases. So at some point, if it keeps calling itself, keeps calling itself, eventually it's going to be able to build back those calls or it's able to get to the base case and then reconstruct what the original value is from that. And so that's why it's working. Every call to Fibonacci is a simpler version. I have a lower n. And eventually my n's are going to get to the base case, which will actually give me actual values that I can then reconstruct for our original call. So hopefully that helps a little bit. Recursion can be confusing, but at the same time it's kind of elegant and beautiful in its own way.
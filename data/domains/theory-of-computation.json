{"domain":{"id":"theory-of-computation","name":"Theory of Computation","parent_id":"computer-science","level":"sub","region":{"x_min":0.528645,"x_max":0.657016,"y_min":0.462627,"y_max":0.654929},"grid_size":70},"questions":[{"id":"0970e8e0ca186112","question_text":"The word 'algorithm' derives from the Latinized name of which 9th-century Persian mathematician who worked at the House of Wisdom in Baghdad?","options":{"A":"Abu Ali ibn al-Haytham","B":"Omar Khayyam of Nishapur","C":"Muhammad ibn Musa al-Khwarizmi","D":"Abu Rayhan al-Biruni"},"correct_answer":"C","difficulty":1,"source_article":"Algorithm","domain_ids":["theory-of-computation"],"concepts_tested":["algorithm"],"x":0.77262,"y":0.80599},{"id":"f6a11e066f66cd7d","question_text":"In his 1936 paper, Alan Turing originally referred to his abstract computational model by what name before Alonzo Church coined the term 'Turing machine'?","options":{"A":"A d-machine (decision machine)","B":"An o-machine (oracle machine)","C":"A c-machine (computing machine)","D":"An a-machine (automatic machine)"},"correct_answer":"D","difficulty":1,"source_article":"Turing machine","domain_ids":["theory-of-computation"],"concepts_tested":["Turing machine"],"x":0.763644,"y":0.744933},{"id":"e22e61c7d9d2139d","question_text":"What are the two main implementation approaches for executing programs written in a programming language, according to standard classification?","options":{"A":"Assembly and linking","B":"Compilation and interpretation","C":"Encoding and decoding","D":"Simulation and emulation"},"correct_answer":"B","difficulty":1,"source_article":"Programming language","domain_ids":["theory-of-computation"],"concepts_tested":["programming language"],"x":0.812194,"y":0.760927},{"id":"90ccdfdfa867c77c","question_text":"The ASCII text-encoding standard originally used how many bits to encode each character, allowing representation of 128 unique values?","options":{"A":"Six bits per character","B":"Seven bits per character","C":"Eight bits per character","D":"Four bits per character"},"correct_answer":"B","difficulty":1,"source_article":"Binary code","domain_ids":["theory-of-computation"],"concepts_tested":["binary code"],"x":0.778057,"y":0.757311},{"id":"c20c98735949502b","question_text":"In cryptography, encryption converts the original representation of information, known as plaintext, into what alternative form?","options":{"A":"Steganograph","B":"Ciphertext","C":"Hashtext","D":"Cleartext"},"correct_answer":"B","difficulty":1,"source_article":"Encryption","domain_ids":["theory-of-computation"],"concepts_tested":["encryption"],"x":0.813077,"y":0.747654},{"id":"a49ddffa91bb7691","question_text":"Which type of loop is classified as 'exit-controlled' because its condition is checked after the loop body executes, guaranteeing at least one iteration?","options":{"A":"A counted for loop","B":"A do-while loop","C":"A for-each loop","D":"A standard while loop"},"correct_answer":"B","difficulty":1,"source_article":"Control flow","domain_ids":["theory-of-computation"],"concepts_tested":["loop"],"x":0.722855,"y":0.709668},{"id":"31784b4059f639c0","question_text":"A compiler translates source code from a high-level programming language into what category of language to create an executable program?","options":{"A":"A scripting language such as JavaScript","B":"A markup language such as HTML","C":"A low-level language such as machine code","D":"A query language such as SQL"},"correct_answer":"C","difficulty":1,"source_article":"Compiler","domain_ids":["theory-of-computation"],"concepts_tested":["compiler"],"x":0.817903,"y":0.762139},{"id":"0a980cb6d00b5703","question_text":"In a recursive function, what is the term for the condition that stops the recursion by returning a value without making further recursive calls?","options":{"A":"The termination flag","B":"The base case","C":"The stack sentinel","D":"The recursive case"},"correct_answer":"B","difficulty":1,"source_article":"Recursion (computer science)","domain_ids":["theory-of-computation"],"concepts_tested":["recursion"],"x":0.768462,"y":0.739786},{"id":"3daf7db6045fb612","question_text":"A sorting algorithm is called 'stable' when it preserves what property among elements that share equal sort keys?","options":{"A":"Their original relative order in the input","B":"Their total number of comparison operations","C":"Their absolute memory addresses in storage","D":"Their binary representation bit patterns"},"correct_answer":"A","difficulty":1,"source_article":"Sorting algorithm","domain_ids":["theory-of-computation"],"concepts_tested":["sorting algorithm"],"x":0.765042,"y":0.738551},{"id":"d22fb31069d354e7","question_text":"The 1965 paper by Juris Hartmanis and Richard Stearns that founded computational complexity theory defined which fundamental concept for classifying problems by resource usage?","options":{"A":"Nondeterministic branching factors","B":"Randomized oracle reduction chains","C":"Time and space complexity classes","D":"Approximation ratio hierarchies"},"correct_answer":"C","difficulty":1,"source_article":"Computational complexity theory","domain_ids":["theory-of-computation"],"concepts_tested":["complexity"],"x":0.720272,"y":0.707279},{"id":"bf165cefe5a87de0","question_text":"Alan Turing's 1936 proof that no algorithm can determine whether an arbitrary program will halt uses which fundamental proof technique involving self-reference?","options":{"A":"Reduction to the Post correspondence problem","B":"Mathematical induction over program length","C":"Diagonalization (proof by contradiction via self-reference)","D":"Pumping lemma for recursive languages"},"correct_answer":"C","difficulty":1,"source_article":"Halting problem","domain_ids":["theory-of-computation"],"concepts_tested":["halting problem"],"x":0.789889,"y":0.763882},{"id":"87e93a4a409be7d4","question_text":"In formal language theory, a formal language is defined as a set of strings whose symbols are drawn from what mathematical object?","options":{"A":"A recursive structure called a grammar","B":"An ordered ring called a codomain","C":"An infinite sequence called a stream","D":"A finite set called an alphabet"},"correct_answer":"D","difficulty":1,"source_article":"Formal language","domain_ids":["theory-of-computation"],"concepts_tested":["formal language"],"x":0.743751,"y":0.724564},{"id":"dade287126af30be","question_text":"George Boole's 1854 work 'An Investigation of the Laws of Thought' laid the foundation for Boolean algebra. What are its three fundamental logical operations?","options":{"A":"IF, THEN, and ELSE","B":"XOR, NAND, and NOR","C":"ADD, SHIFT, and COMPARE","D":"AND, OR, and NOT"},"correct_answer":"D","difficulty":1,"source_article":"Boolean algebra","domain_ids":["theory-of-computation"],"concepts_tested":["Boolean logic"],"x":0.759386,"y":0.728114},{"id":"3ebe78deb3a9a1af","question_text":"A deterministic finite automaton (DFA) and a nondeterministic finite automaton (NFA) recognize exactly the same class of languages. What is that class called?","options":{"A":"Recursively enumerable languages","B":"Context-sensitive languages","C":"Regular languages","D":"Context-free languages"},"correct_answer":"C","difficulty":2,"source_article":"Finite-state machine","domain_ids":["theory-of-computation"],"concepts_tested":["finite automaton"],"x":0.724025,"y":0.711587},{"id":"31ced92950b96e35","question_text":"Stephen Kleene's 1956 paper in 'Automata Studies' proved that regular expressions and finite automata describe the same class of languages. What is this equivalence result called?","options":{"A":"Kleene's theorem","B":"Myhill-Nerode theorem","C":"Rice's equivalence theorem","D":"Chomsky's normal form theorem"},"correct_answer":"A","difficulty":2,"source_article":"Regular expression","domain_ids":["theory-of-computation"],"concepts_tested":["regular expression"],"x":0.725643,"y":0.71573},{"id":"3716bb5c1a61d289","question_text":"Context-free grammars, classified as Type 2 in the Chomsky hierarchy, restrict production rules so that only what appears on the left-hand side of each rule?","options":{"A":"A pair of terminal symbols","B":"The designated start symbol only","C":"A string of mixed terminals and nonterminals","D":"A single nonterminal symbol"},"correct_answer":"D","difficulty":2,"source_article":"Context-free grammar","domain_ids":["theory-of-computation"],"concepts_tested":["context-free grammar"],"x":0.75013,"y":0.73682},{"id":"2762d89939e977c5","question_text":"A pushdown automaton extends a finite automaton with what additional data structure, enabling it to recognize context-free languages?","options":{"A":"A random-access memory register","B":"A stack (last-in, first-out memory)","C":"A second read-only input tape","D":"A queue (first-in, first-out buffer)"},"correct_answer":"B","difficulty":2,"source_article":"Pushdown automaton","domain_ids":["theory-of-computation"],"concepts_tested":["pushdown automaton"],"x":0.741474,"y":0.727976},{"id":"167e7cc2f2d30dd8","question_text":"The Cook-Levin theorem (1971) established which specific decision problem as the first proven NP-complete problem?","options":{"A":"The graph coloring problem (GCP)","B":"The Boolean satisfiability problem (SAT)","C":"The integer linear programming problem (ILP)","D":"The travelling salesman problem (TSP)"},"correct_answer":"B","difficulty":2,"source_article":"NP-completeness","domain_ids":["theory-of-computation"],"concepts_tested":["NP-completeness"],"x":0.778513,"y":0.751947},{"id":"56d23c98e4ceb286","question_text":"The P versus NP problem, one of the seven Clay Millennium Prize Problems worth \\$1 million, asks whether every problem whose solution can be verified in polynomial time can also be what?","options":{"A":"Reduced to a halting problem instance","B":"Solved in exponential time only","C":"Verified in logarithmic time","D":"Solved in polynomial time"},"correct_answer":"D","difficulty":2,"source_article":"P versus NP problem","domain_ids":["theory-of-computation"],"concepts_tested":["P versus NP problem"],"x":0.80318,"y":0.770043},{"id":"aea653c1b95ab3b3","question_text":"A nondeterministic Turing machine differs from a deterministic one because its transition function allows multiple possible actions, creating a branching what?","options":{"A":"Computation tree of parallel paths","B":"Finite state register of memory cells","C":"Linear sequence of deterministic steps","D":"Recursive stack of subroutine calls"},"correct_answer":"A","difficulty":2,"source_article":"Nondeterministic Turing machine","domain_ids":["theory-of-computation"],"concepts_tested":["nondeterministic Turing machine"],"x":0.771988,"y":0.740582},{"id":"5bbc1a75efc91afd","question_text":"What does it mean for a decision problem to be decidable?","options":{"A":"An effective method exists that always derives the correct yes-or-no answer.","B":"A nondeterministic machine exists that halts on at least one computation path.","C":"An effective method exists that sometimes derives a correct yes-or-no answer.","D":"An efficient polynomial-time algorithm exists that derives the correct answer."},"correct_answer":"A","difficulty":2,"source_article":"Decidability (logic)","domain_ids":["theory-of-computation"],"concepts_tested":["decidability"],"x":0.790944,"y":0.750195},{"id":"decdde922ec8aee8","question_text":"In the Chomsky hierarchy, which type of automaton recognizes context-free languages?","options":{"A":"Nondeterministic pushdown automaton.","B":"Nondeterministic Turing machine with unlimited tape.","C":"Linear-bounded nondeterministic Turing machine.","D":"Deterministic finite automaton."},"correct_answer":"A","difficulty":2,"source_article":"Chomsky hierarchy","domain_ids":["theory-of-computation"],"concepts_tested":["Chomsky hierarchy"],"x":0.731135,"y":0.718494},{"id":"a0837c68989cfdb5","question_text":"What is a parse tree in formal language theory?","options":{"A":"A binary tree mapping each input symbol to its corresponding output in a finite-state transducer.","B":"An ordered, rooted tree representing a string's syntactic structure according to a context-free grammar.","C":"An unordered tree representing the runtime execution trace of a deterministic pushdown automaton.","D":"A directed acyclic graph representing semantic dependencies between tokens in a regular grammar."},"correct_answer":"B","difficulty":2,"source_article":"Parse tree","domain_ids":["theory-of-computation"],"concepts_tested":["parse tree"],"x":0.748258,"y":0.734441},{"id":"d4d1872501efc3df","question_text":"What characterizes an algorithm that runs in polynomial time?","options":{"A":"Its running time is bounded by O(n log n) regardless of the input size.","B":"Its running time is bounded by O(n!) for some constant factorial of the input size.","C":"Its running time is bounded by O(n^k) for some constant k, where n is the input size.","D":"Its running time is bounded by O(k^n) for some constant k, where n is the input size."},"correct_answer":"C","difficulty":2,"source_article":"Time complexity","domain_ids":["theory-of-computation"],"concepts_tested":["polynomial time"],"x":0.805064,"y":0.771553},{"id":"5a208c9a071e9e77","question_text":"In complexity theory, what does it mean to reduce problem A to problem B?","options":{"A":"Transform instances of B into instances of A so that solving A efficiently also solves B.","B":"Prove that problems A and B have identical worst-case running times on all inputs.","C":"Transform instances of A into instances of B so that solving B efficiently also solves A.","D":"Decompose problem A into smaller independent subproblems that are each equivalent to B."},"correct_answer":"C","difficulty":2,"source_article":"Reduction (complexity)","domain_ids":["theory-of-computation"],"concepts_tested":["reduction (complexity)"],"x":0.775876,"y":0.741992},{"id":"abcaf2a2d01dae29","question_text":"What does the pumping lemma for regular languages state?","options":{"A":"Every string in a regular language can be split into two halves that are each independently regular.","B":"Every sufficiently long string in a regular language has a middle section that can be repeated any number of times.","C":"Every sufficiently long string in a regular language has a prefix that can be deleted to produce a shorter valid string.","D":"Every sufficiently long string in a context-free language has a middle section that can be repeated any number of times."},"correct_answer":"B","difficulty":3,"source_article":"Pumping lemma for regular languages","domain_ids":["theory-of-computation"],"concepts_tested":["pumping lemma"],"x":0.714006,"y":0.705204},{"id":"4d3d24fb15f965ec","question_text":"What does the Church-Turing thesis assert?","options":{"A":"A function on natural numbers is decidable if and only if it can be verified by a nondeterministic Turing machine.","B":"A function on natural numbers is computable by a Turing machine if and only if it is expressible in first-order logic.","C":"A function on natural numbers is effectively calculable if and only if it runs in polynomial time.","D":"A function on natural numbers is effectively calculable if and only if it is computable by a Turing machine."},"correct_answer":"D","difficulty":3,"source_article":"Church\u2013Turing thesis","domain_ids":["theory-of-computation"],"concepts_tested":["Church-Turing thesis"],"x":0.741116,"y":0.725647},{"id":"1930d14d795dfa8a","question_text":"What did Cantor's 1891 diagonal argument originally prove?","options":{"A":"There exist infinite sets that can always be put into one-to-one correspondence with the rationals.","B":"There exist infinite sets that cannot be put into one-to-one correspondence with the natural numbers.","C":"There exist countably infinite sets whose power sets have the same cardinality.","D":"There exist finite sets that cannot be enumerated by any algorithmic procedure."},"correct_answer":"B","difficulty":3,"source_article":"Cantor's diagonal argument","domain_ids":["theory-of-computation"],"concepts_tested":["diagonalization argument"],"x":0.692265,"y":0.693615},{"id":"763f24c7754bbf5b","question_text":"According to Savitch's theorem, what is the relationship between PSPACE and NPSPACE?","options":{"A":"PSPACE strictly contains NPSPACE.","B":"NPSPACE strictly contains PSPACE.","C":"They are incomparable and neither contains the other.","D":"They are equal: PSPACE equals NPSPACE."},"correct_answer":"D","difficulty":3,"source_article":"Space complexity","domain_ids":["theory-of-computation"],"concepts_tested":["space complexity"],"x":0.792517,"y":0.761642},{"id":"2c27323f785de954","question_text":"What does the Cook-Levin theorem establish?","options":{"A":"The Boolean satisfiability problem is NP-complete.","B":"The Boolean satisfiability problem is in P.","C":"The graph isomorphism problem is NP-complete.","D":"The halting problem is reducible to Boolean satisfiability in polynomial time."},"correct_answer":"A","difficulty":3,"source_article":"Cook\u2013Levin theorem","domain_ids":["theory-of-computation"],"concepts_tested":["Cook-Levin theorem"],"x":0.782571,"y":0.754656},{"id":"5d6052a960a5a615","question_text":"The Cook-Levin theorem established the first natural NP-complete problem. Which problem did it prove to be NP-complete?","options":{"A":"The travelling salesman problem","B":"The integer linear programming problem","C":"The Boolean satisfiability problem (SAT)","D":"The graph coloring problem"},"correct_answer":"C","difficulty":3,"source_article":"Cook\u2013Levin theorem","domain_ids":["theory-of-computation"],"concepts_tested":["Cook-Levin theorem"],"x":0.792235,"y":0.762151},{"id":"5c9fc2acfbc16a09","question_text":"The Myhill-Nerode theorem states that a language is regular if and only if what condition holds?","options":{"A":"Its equivalence relation has finitely many equivalence classes","B":"It is accepted by a nondeterministic pushdown automaton","C":"It is generated by a context-free grammar","D":"It can be pumped according to the pumping lemma"},"correct_answer":"A","difficulty":3,"source_article":"Myhill\u2013Nerode theorem","domain_ids":["theory-of-computation"],"concepts_tested":["Myhill-Nerode theorem"],"x":0.719137,"y":0.708857},{"id":"9c7f33ec5a64f3c6","question_text":"In computability theory, what does it mean for a computational system to be Turing-complete?","options":{"A":"It can simulate any Turing machine","B":"It can solve the halting problem","C":"It runs in polynomial time on all inputs","D":"It uses only a finite amount of memory"},"correct_answer":"A","difficulty":3,"source_article":"Turing completeness","domain_ids":["theory-of-computation"],"concepts_tested":["Turing completeness"],"x":0.764258,"y":0.736167},{"id":"23ea21ea07f35197","question_text":"Context-sensitive languages correspond to Type-1 in the Chomsky hierarchy. What type of automaton recognizes exactly this class of languages?","options":{"A":"A nondeterministic pushdown automaton","B":"A linear bounded automaton","C":"A two-stack pushdown automaton","D":"A deterministic finite automaton"},"correct_answer":"B","difficulty":3,"source_article":"Context-sensitive language","domain_ids":["theory-of-computation"],"concepts_tested":["context-sensitive language"],"x":0.733546,"y":0.720583},{"id":"91746668d058fb27","question_text":"Context-free languages are closed under union, concatenation, and Kleene star but are notably not closed under which operation?","options":{"A":"Reversal","B":"Intersection","C":"Concatenation","D":"Homomorphism"},"correct_answer":"B","difficulty":3,"source_article":"Closure (mathematics)","domain_ids":["theory-of-computation"],"concepts_tested":["closure properties of formal languages"],"x":0.749589,"y":0.734528},{"id":"78135323cb564829","question_text":"Savitch's theorem shows that PSPACE equals NPSPACE. What is the canonical PSPACE-complete problem?","options":{"A":"The subset sum problem","B":"The quantified Boolean formula problem (QBF)","C":"The Boolean satisfiability problem (SAT)","D":"The graph isomorphism problem"},"correct_answer":"B","difficulty":3,"source_article":"PSPACE","domain_ids":["theory-of-computation"],"concepts_tested":["PSPACE"],"x":0.797243,"y":0.766349},{"id":"0024fc84676dd08a","question_text":"A Las Vegas algorithm always produces a correct result but has random running time. How does a Monte Carlo algorithm differ?","options":{"A":"It always runs in constant time and is always correct","B":"It has bounded running time but may produce an incorrect result","C":"It uses no randomness but approximates the answer","D":"It runs deterministically but on a random subset of the input"},"correct_answer":"B","difficulty":3,"source_article":"Randomized algorithm","domain_ids":["theory-of-computation"],"concepts_tested":["randomized algorithm"],"x":0.772715,"y":0.741104},{"id":"d12af99030ef4b58","question_text":"In amortized analysis of a dynamic array that doubles in size when full, what is the amortized time cost per insertion?","options":{"A":"$O(1)$ per insertion","B":"$O(n)$ per insertion","C":"$O(\\log n)$ per insertion","D":"$O(\\sqrt{n})$ per insertion"},"correct_answer":"A","difficulty":3,"source_article":"Amortized analysis","domain_ids":["theory-of-computation"],"concepts_tested":["amortized analysis"],"x":0.779045,"y":0.75559},{"id":"1cc852d8f3656e66","question_text":"Rice's theorem states that all non-trivial properties of programs that depend solely on what aspect are undecidable?","options":{"A":"The program's syntactic structure","B":"The program's semantic behavior","C":"The program's source code length","D":"The program's memory usage"},"correct_answer":"B","difficulty":4,"source_article":"Rice's theorem","domain_ids":["theory-of-computation"],"concepts_tested":["Rice's theorem"],"x":0.724978,"y":0.711796},{"id":"1ff33ad32713306b","question_text":"An oracle machine extends a Turing machine with a black-box oracle. What did Baker, Gill, and Solovay (1975) prove about oracle machines and the P versus NP question?","options":{"A":"Oracle machines can solve the halting problem in polynomial time","B":"Every oracle makes P equal to NP","C":"No oracle can separate P from NP","D":"There exist oracles A and B such that $P^A = NP^A$ and $P^B \\neq NP^B$"},"correct_answer":"D","difficulty":4,"source_article":"Oracle machine","domain_ids":["theory-of-computation"],"concepts_tested":["oracle machine"],"x":0.788079,"y":0.759482},{"id":"31f4b4ba33a433e4","question_text":"Kolmogorov complexity is also known as Solomonoff-Kolmogorov-Chaitin complexity, reflecting independent discovery by three researchers. What does the invariance theorem guarantee about this measure, and why is Kolmogorov complexity uncomputable?","options":{"A":"The invariance theorem guarantees that changing the universal description language alters Kolmogorov complexity by at most an additive constant. It is uncomputable because the shortest description length grows faster than any computable function.","B":"The invariance theorem guarantees that changing the universal description language alters Kolmogorov complexity by at most a multiplicative constant. It is uncomputable because no program can compute the exact shortest description length for all strings.","C":"The invariance theorem guarantees that all universal description languages assign identical Kolmogorov complexity values. It is uncomputable because no program can compute the exact shortest description length for all strings.","D":"The invariance theorem guarantees that changing the universal description language alters Kolmogorov complexity by at most an additive constant. It is uncomputable because no program can compute the exact shortest description length for all strings."},"correct_answer":"D","difficulty":4,"source_article":"Kolmogorov complexity","domain_ids":["theory-of-computation"],"concepts_tested":["Kolmogorov complexity","invariance theorem","uncomputability"],"x":0.749035,"y":0.720958},{"id":"2e994b29f73dba0c","question_text":"In circuit complexity, Boolean functions are classified by the size and depth of circuits computing them. What distinguishes a uniform circuit family from a non-uniform one, and which well-known non-uniform complexity class consists of problems solvable by polynomial-size circuits?","options":{"A":"A uniform family requires that every circuit in the family has identical depth regardless of input size. The non-uniform class P/poly consists of problems solvable by polynomial-size circuit families without a uniformity requirement.","B":"A uniform family requires a resource-bounded Turing machine that, given n, produces the circuit for inputs of size n. The non-uniform class NC consists of problems solvable by polynomial-size circuit families without a uniformity requirement.","C":"A uniform family requires a resource-bounded Turing machine that, given n, produces the circuit for inputs of size n. The non-uniform class P/poly consists of problems solvable by polynomial-size circuit families without a uniformity requirement.","D":"A uniform family requires a resource-bounded Turing machine that, given n, produces the circuit for inputs of size n. The non-uniform class P/poly consists of problems solvable by logarithmic-depth circuit families without a uniformity requirement."},"correct_answer":"C","difficulty":4,"source_article":"Circuit complexity","domain_ids":["theory-of-computation"],"concepts_tested":["circuit complexity","uniform circuits","P/poly"],"x":0.796534,"y":0.764102},{"id":"e46e81c2e9f696a5","question_text":"An interactive proof system involves a computationally unbounded prover and a probabilistic polynomial-time verifier exchanging messages. Goldwasser, Micali, and Rackoff showed that private-coin protocols are equivalent to public-coin protocols. What landmark equality did Shamir prove about the complexity class IP?","options":{"A":"Shamir proved that IP equals EXPTIME, meaning every problem solvable in exponential time has an interactive proof with a probabilistic polynomial-time verifier.","B":"Shamir proved that IP equals NP, meaning every problem verifiable in polynomial time has an interactive proof with a probabilistic polynomial-time verifier.","C":"Shamir proved that IP equals PSPACE, meaning every problem solvable in polynomial space has an interactive proof with a deterministic polynomial-time verifier.","D":"Shamir proved that IP equals PSPACE, meaning every problem solvable in polynomial space has an interactive proof with a probabilistic polynomial-time verifier."},"correct_answer":"D","difficulty":4,"source_article":"Interactive proof system","domain_ids":["theory-of-computation"],"concepts_tested":["interactive proof system","IP = PSPACE","Shamir's theorem"],"x":0.798136,"y":0.768189},{"id":"697aa14eee2704c6","question_text":"Zero-knowledge proofs, introduced by Goldwasser, Micali, and Rackoff in 1985, must satisfy three properties: completeness, soundness, and zero-knowledge. What does the zero-knowledge property specifically guarantee, and how does it differ from soundness?","options":{"A":"Zero-knowledge guarantees the verifier learns nothing beyond the statement's truth, as any interaction can be simulated without the prover. Soundness instead guarantees that the honest prover can always convince the verifier of a true statement.","B":"Zero-knowledge guarantees the verifier learns nothing beyond the statement's truth, as any interaction can be simulated without the prover. Soundness instead guarantees that the protocol terminates in polynomial time for all inputs.","C":"Zero-knowledge guarantees the prover cannot learn the verifier's random coin tosses during the protocol. Soundness instead guarantees that no cheating prover can convince the verifier of a false statement.","D":"Zero-knowledge guarantees the verifier learns nothing beyond the statement's truth, as any interaction can be simulated without the prover. Soundness instead guarantees that no cheating prover can convince the verifier of a false statement."},"correct_answer":"D","difficulty":4,"source_article":"Zero-knowledge proof","domain_ids":["theory-of-computation"],"concepts_tested":["zero-knowledge proof","Goldwasser-Micali-Rackoff","soundness vs zero-knowledge"],"x":0.805825,"y":0.773548},{"id":"6608321f4571a43c","question_text":"The proof that IP = PSPACE relies on arithmetization, a technique for converting Boolean formulas into polynomials over finite fields. What is the key protocol used to verify polynomial identities in this proof, and which earlier result by Lund, Fortnow, Karloff, and Nisan did Shamir build upon?","options":{"A":"The Schwartz-Zippel protocol, which interactively verifies the sum of a polynomial over all Boolean inputs. Shamir extended the result by Lund, Fortnow, Karloff, and Nisan that co-NP has multi-prover interactive proofs.","B":"The sum-check protocol, which interactively verifies the sum of a polynomial over all Boolean inputs. Shamir extended the result by Lund, Fortnow, Karloff, and Nisan that co-NP has multi-prover interactive proofs.","C":"The sum-check protocol, which deterministically evaluates a polynomial at random points to check identity. Shamir extended the result by Lund, Fortnow, Karloff, and Nisan that co-NP has multi-prover interactive proofs.","D":"The sum-check protocol, which interactively verifies the sum of a polynomial over all Boolean inputs. Shamir extended the result by Lund, Fortnow, Karloff, and Nisan that NP has single-prover interactive proofs."},"correct_answer":"B","difficulty":4,"source_article":"IP (complexity)","domain_ids":["theory-of-computation"],"concepts_tested":["arithmetization","sum-check protocol","IP = PSPACE"],"x":0.778917,"y":0.754827},{"id":"1a930d02ce18e133","question_text":"The polynomial hierarchy generalizes NP and co-NP into an infinite hierarchy of complexity classes contained within PSPACE. In the oracle-based definition, how are the classes Sigma_k^P and Pi_k^P defined, and what does it mean for the hierarchy to collapse to level k?","options":{"A":"Sigma_{k+1}^P = NP with a Sigma_k^P oracle, and Pi_{k+1}^P = coNP with a Sigma_k^P oracle. Collapse to level k means all lower levels equal level k, so P = Sigma_k^P.","B":"Sigma_{k+1}^P = NP with a Sigma_k^P oracle, and Pi_{k+1}^P = NP with a Pi_k^P oracle. Collapse to level k means all higher levels equal level k, so PH = Sigma_k^P.","C":"Sigma_{k+1}^P = NP with a Sigma_k^P oracle, and Pi_{k+1}^P = coNP with a Sigma_k^P oracle. Collapse to level k means all higher levels equal level k, so PH = Sigma_k^P.","D":"Sigma_{k+1}^P = P with a Sigma_k^P oracle, and Pi_{k+1}^P = coNP with a Sigma_k^P oracle. Collapse to level k means all higher levels equal level k, so PH = Sigma_k^P."},"correct_answer":"C","difficulty":4,"source_article":"Polynomial hierarchy","domain_ids":["theory-of-computation"],"concepts_tested":["polynomial hierarchy","oracle machines","PH collapse"],"x":0.796583,"y":0.766337},{"id":"5291e29d8ef292bb","question_text":"Descriptive complexity theory characterizes computational complexity classes by the type of logic needed to express them. Fagin's theorem (1974) established the first such correspondence. What complexity class does existential second-order logic capture, and what does the Immerman-Vardi theorem characterize?","options":{"A":"Existential second-order logic captures exactly NP. The Immerman-Vardi theorem shows that second-order logic with a least fixed-point operator captures P on ordered structures.","B":"Existential second-order logic captures exactly PSPACE. The Immerman-Vardi theorem shows that first-order logic with a least fixed-point operator captures P on ordered structures.","C":"Existential second-order logic captures exactly NP. The Immerman-Vardi theorem shows that first-order logic with a transitive closure operator captures P on ordered structures.","D":"Existential second-order logic captures exactly NP. The Immerman-Vardi theorem shows that first-order logic with a least fixed-point operator captures P on ordered structures."},"correct_answer":"D","difficulty":4,"source_article":"Descriptive complexity theory","domain_ids":["theory-of-computation"],"concepts_tested":["descriptive complexity","Fagin's theorem","Immerman-Vardi theorem"],"x":0.79908,"y":0.767497},{"id":"773e7ca17380f2e3","question_text":"Savitch's theorem, proved by Walter Savitch in 1970, establishes a fundamental relationship between deterministic and nondeterministic space complexity. What is the precise statement, and what key algorithmic technique underlies the proof?","options":{"A":"NSPACE(f(n)) is contained in DSPACE(f(n)^2) for any f(n) >= log(n). The proof uses a breadth-first search algorithm that enumerates all reachable configurations, using O(n^2) space for graph connectivity.","B":"NSPACE(f(n)) is contained in DSPACE(f(n)^2) for any f(n) >= log(n). The proof uses a recursive reachability algorithm that tests path existence by repeatedly halving the path length, using O(log^2 n) space for graph connectivity.","C":"NSPACE(f(n)) is contained in DSPACE(f(n) log f(n)) for any f(n) >= log(n). The proof uses a recursive reachability algorithm that tests path existence by repeatedly halving the path length, using O(log^2 n) space for graph connectivity.","D":"NSPACE(f(n)) is contained in DSPACE(f(n)^2) for any f(n) >= n. The proof uses a recursive reachability algorithm that tests path existence by repeatedly halving the path length, using O(log^2 n) space for graph connectivity."},"correct_answer":"B","difficulty":4,"source_article":"Savitch's theorem","domain_ids":["theory-of-computation"],"concepts_tested":["Savitch's theorem","space complexity","PSPACE = NPSPACE"],"x":0.782631,"y":0.757035},{"id":"c1f086995844722d","question_text":"The deterministic time hierarchy theorem, first proved by Hartmanis and Stearns in 1965, uses diagonalization to show that more time strictly increases computational power. What is the precise statement for time-constructible functions, and what major complexity class separation follows as a corollary?","options":{"A":"DTIME(o(f(n))) is strictly contained in DTIME(f(n)^2) for any time-constructible f(n). A corollary is P != EXPTIME, since polynomial time is strictly weaker than exponential time.","B":"DTIME(o(f(n))) is strictly contained in DTIME(f(n) log f(n)) for any time-constructible f(n). A corollary is P != NP, since linear time is strictly weaker than polynomial time.","C":"DTIME(o(f(n))) is strictly contained in DTIME(f(n) log f(n)) for any computable f(n). A corollary is P != EXPTIME, since polynomial time is strictly weaker than exponential time.","D":"DTIME(o(f(n))) is strictly contained in DTIME(f(n) log f(n)) for any time-constructible f(n). A corollary is P != EXPTIME, since polynomial time is strictly weaker than exponential time."},"correct_answer":"D","difficulty":4,"source_article":"Time hierarchy theorem","domain_ids":["theory-of-computation"],"concepts_tested":["time hierarchy theorem","Hartmanis-Stearns","diagonalization"],"x":0.803876,"y":0.770875},{"id":"2b09ba2f2a716c56","question_text":"The Post correspondence problem, introduced by Emil Post in 1946, is an undecidable decision problem frequently used to prove undecidability of other problems. What does the problem ask, and why is it preferred over direct reduction from the halting problem?","options":{"A":"Given two lists of strings, determine whether a sequence of indices exists such that concatenating the corresponding strings from both lists produces the same result. It is preferred because it can be reduced to the halting problem in polynomial time, making complexity bounds easier to establish.","B":"Given two lists of strings, determine whether a sequence of indices exists such that concatenating the corresponding strings from both lists produces the same result. It is preferred because its formulation is simpler than the halting problem, making reductions to other problems easier to construct.","C":"Given two lists of strings, determine whether a sequence of indices exists such that concatenating the corresponding strings from both lists produces the same result. It is preferred because it is decidable for binary alphabets, making partial reductions to other problems easier to construct.","D":"Given two lists of strings, determine whether every sequence of indices produces matching concatenations from both lists. It is preferred because its formulation is simpler than the halting problem, making reductions to other problems easier to construct."},"correct_answer":"B","difficulty":4,"source_article":"Post correspondence problem","domain_ids":["theory-of-computation"],"concepts_tested":["Post correspondence problem","undecidability","Emil Post"],"x":0.76633,"y":0.740127}],"labels":[],"articles":[]}
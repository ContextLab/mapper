What happens when you assign, reassign, or access a variable in a program? Let's trace the execution of a program with variables to find out. When the program starts running, the computer loads the first instruction into its working memory. This instruction is an assignment statement. The left-hand side is the variable name, the equal sign is the assignment operator, and the right-hand side is the value to be stored in that variable. The computer looks for any expressions to simplify on the right-hand side, but in this case, the string is already a single value. When the computer executes an assignment statement, it goes off to its short-term memory and looks for a label with that variable name. Here, it looks for the name gene, but it doesn't find it. That means it doesn't already know a gene, it needs to create one. So, the computer allocates a new chunk of memory for this new variable. It tags that chunk of memory with the name gene, so it can distinguish it from its other chunks of memory. Then, it takes the value on the right-hand side of the assignment operator and copies it over to that location in short-term memory. That way, it doesn't forget it when it clears out its working memory in a second. Okay, well, this instruction is complete, so the computer is going to clear out its working memory, forget all of this stuff here, and move on to the next line. However, anything that it's stored in its short-term memory stays behind. Here we have another assignment statement. With this one, though, on the right-hand side of the assignment operator, there's an un-simplified expression. Like humans, it's much easier for the computer to remember a single value, like 11 than the long expression 4 plus 5 plus 2. So, the computer makes sure to simplify any expressions on the right-hand side of the assignment operator down to a single value before it memorizes it. Now we have 11, so the computer goes off to its short-term memory, looks for the label num mutations, doesn't find it, so creates a new variable, allocates a new chunk of memory, tags it, and copies the value 11 over from working memory. Once that value is stored, this instruction is complete, so the computer clears out working memory and moves to the next line. Now we have a print instruction. The computer looks inside of the parentheses first for any expressions to simplify and finds the variable named gene. Now, this is not an assignment. The name gene is not on the left-hand side of an equal sign or assignment operator. That means we are accessing the value stored in gene, not setting it. The computer goes off to its short-term memory, looks for the label gene, finds it, and then follows it to the location and memory that it points to. Then it substitutes the value stored there into the instruction in working memory. For the second part, note that there are quotation marks here. That means that this is just the string gene, not the variable gene, so we're not going off to access anything in short-term memory. We're just concatenating these two strings together. Once we're down to a single value, the computer peeks outside the parentheses, asks what it's supposed to do with that value, sees print, and prints brca2 gene to the console. Next line, we have a self-referencing assignment statement. The variable we're assigning to on the left-hand side is num mutations, but we're also accessing the variable num mutations on the right-hand side. Not a problem because we always evaluate the right-hand side first. So we access the variable num mutations, look at what value it currently has stored there, and substitute that in on the right-hand side only. Then we evaluate this expression. Now that we have a single value, we're ready to store. The computer sees that it already has a variable num mutations, so it's not going to create a new one. Instead, it'll allocate a new chunk of memory, store the value 12 there, and then take that existing num mutations and move it to point to that new chunk of memory. That old chunk of memory with that old value is now unreachable, so the computer will come in and clear that out at some point to make more room. Then it clears out and picks up the next line. How do you think this assignment works? Though it may look like it, this does not create some special permanent link between the variable gene and the variable num mutations where they'll forever be the same value now. What it does is go off to its short-term memory, looks for the variable gene, and then moves it to point to the same location as num mutations. The computer does this as an optimization, because it could have allocated a new chunk of memory, stored the value 12 there too, and then have gene point to it. In some cases though, we may be storing really big values. It could take up a lot of space in memory if the computer had to copy over a big value multiple times, so it would rather not if it can avoid it. And now that this old location is unreachable, it goes away. We clear out and we load in the next line. On the right-hand side of the assignment operator, we have an expression, so we need to simplify that first. We're accessing the variable gene because it's on the right-hand side, so we go off to short-term memory, grab that value, substitute it in, and then we just add these integers together. We find the label num mutations in short-term memory, so we allocate a new chunk of memory, store the value 17 there, and then move num mutations to point to that new location. Note that this doesn't affect the value of gene. We move num mutations to point to a different location, but we didn't move gene. It still points to that old location with the value 12. Because that location is still reachable through the variable gene, it sticks around. This last line is just a print function, so we evaluate the expression inside the parentheses first. We go off, we grab the value stored in num mutations, we substitute it in, and then we do the same for the variable gene. We add those two integers together to get a single value, and then we peek outside the parentheses and see that we need to print that value to the console. The computer looks for the next line and finds that it's at the end of the program. When the program terminates, short-term memory gets cleared, so all these variables go away. And now the computer has room again to remember new things the next time you run a program.
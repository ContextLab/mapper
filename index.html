<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Knowledge Map Demo - Heatmap Visualization</title>
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #00693E 0%, #004d2c 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            width: 100%;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 80px rgba(0, 0, 0, 0.5);
            border: 3px solid rgba(255, 255, 255, 0.2);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #00693E 0%, #004d2c 100%);
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
        }

        .header h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .btn-about {
            position: absolute;
            top: 30px;
            right: 30px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-about:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-2px);
        }

        .btn-about i {
            font-size: 1.1em;
        }

        .content {
            padding: 40px;
        }

        .question-section {
            margin-bottom: 30px;
        }

        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .question-number {
            font-size: 0.9em;
            color: #00693E;
            font-weight: 600;
        }

        .question-text {
            font-size: 1.3em;
            color: #333;
            margin-bottom: 25px;
            line-height: 1.6;
        }

        .options {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .option {
            padding: 18px 24px;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.05em;
            display: flex;
            align-items: center;
        }

        .option:hover {
            border-color: #00693E;
            background: #e8f5f1;
            transform: translateX(5px);
        }

        .option.selected {
            border-color: #00693E;
            background: #e8f5f1;
        }

        .option-label {
            display: inline-block;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: #00693E;
            color: white;
            text-align: center;
            line-height: 30px;
            margin-right: 15px;
            font-weight: 600;
            flex-shrink: 0;
        }

        .button-container {
            display: flex;
            gap: 15px;
            margin-top: 30px;
        }

        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 1.05em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            flex: 1;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00693E 0%, #004d2c 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 105, 62, 0.4);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #f5f5f5;
            color: #333;
        }

        .btn-secondary:hover {
            background: #e0e0e0;
        }

        .map-container {
            width: 100%;
            height: 700px;
            background: #f8f9fa;
            border-radius: 12px;
            position: relative;
            overflow: hidden;
        }

        .map-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .map-header h2 {
            font-size: 1.8em;
            color: #333;
            margin-bottom: 10px;
        }

        .map-header p {
            color: #666;
            font-size: 1.05em;
        }

        #map-canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 10;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #00693E;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 12px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: 700;
            color: #00693E;
        }

        .stat-label {
            color: #666;
            margin-top: 5px;
        }

        .hidden {
            display: none;
        }

        .progress-bar {
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 30px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00693E 0%, #004d2c 100%);
            width: 0%;
            transition: width 0.5s ease;
        }

        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.8);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            font-size: 0.9em;
            z-index: 5;
            cursor: move;
            user-select: none;
            transition: box-shadow 0.2s ease;
        }

        .legend:hover {
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        .legend.dragging {
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.3);
            cursor: grabbing;
        }

        .legend h4 {
            margin-bottom: 10px;
            color: #333;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .legend-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-right: 8px;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .colorbar {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.8);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 5;
            cursor: move;
            user-select: none;
            transition: box-shadow 0.2s ease;
        }

        .colorbar:hover {
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        .colorbar.dragging {
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.3);
            cursor: grabbing;
        }

        .colorbar h4 {
            margin-bottom: 8px;
            font-size: 0.9em;
            color: #333;
        }

        .colorbar-gradient {
            width: 200px;
            height: 20px;
            background: linear-gradient(to right,
                rgba(139, 69, 19, 0.8),
                rgba(184, 134, 11, 0.8),
                rgba(218, 165, 32, 0.8),
                rgba(0, 133, 66, 0.8),
                rgba(0, 105, 62, 0.8)
            );
            border-radius: 4px;
        }

        .colorbar-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.8em;
            color: #666;
            margin-top: 5px;
        }

        .tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 0.9em;
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            opacity: 0;
            transition: opacity 200ms ease-in-out;
        }

        .tooltip.visible {
            opacity: 1;
        }

        .tooltip-hidden {
            display: none;
        }

        .tooltip-question {
            font-weight: 600;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
        }

        .tooltip-status {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tooltip-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        @media (max-width: 768px) {
            .content {
                padding: 20px;
            }

            .header h1 {
                font-size: 1.5em;
            }

            .question-text {
                font-size: 1.1em;
            }

            .map-container {
                height: 400px;
            }

            .stats {
                flex-direction: column;
                gap: 20px;
            }

            .legend, .colorbar {
                font-size: 0.8em;
                padding: 10px;
            }

            .colorbar-gradient {
                width: 150px;
            }
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Introduction Screen */
        .intro-section {
            text-align: center;
            padding: 60px 40px;
        }

        .intro-section h1 {
            font-size: 2.5em;
            color: #00693E;
            margin-bottom: 20px;
        }

        .intro-description {
            font-size: 1.2em;
            color: #666;
            line-height: 1.8;
            max-width: 700px;
            margin: 0 auto 40px;
        }

        .intro-instructions {
            max-width: 600px;
            margin: 0 auto 40px;
            text-align: left;
            background: #f8f9fa;
            padding: 30px;
            border-radius: 12px;
        }

        .intro-instructions h3 {
            font-size: 1.3em;
            color: #333;
            margin-bottom: 15px;
        }

        .intro-instructions ol {
            font-size: 1.1em;
            color: #666;
            line-height: 2;
            padding-left: 25px;
        }

        .intro-instructions li {
            margin-bottom: 10px;
        }

        /* About Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2000;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .modal.hidden {
            display: none !important;
        }

        .modal-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
        }

        .modal-content {
            position: relative;
            background: white;
            border-radius: 16px;
            max-width: 700px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            z-index: 2001;
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-30px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .modal-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: transparent;
            border: none;
            font-size: 1.5em;
            color: #999;
            cursor: pointer;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close:hover {
            background: #f0f0f0;
            color: #333;
        }

        .modal-content h2 {
            font-size: 2em;
            color: #00693E;
            margin-bottom: 30px;
        }

        .about-section {
            margin-bottom: 35px;
        }

        .about-section h3 {
            font-size: 1.4em;
            color: #333;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e0e0e0;
        }

        .about-link {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 15px;
            margin: 6px 0;
            border-radius: 8px;
            text-decoration: none;
            color: #333;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .about-link:hover {
            background: #f8f9fa;
            border-color: #00693E;
            transform: translateX(5px);
        }

        .link-logo {
            height: 24px;
            width: auto;
            flex-shrink: 0;
        }

        .citation {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            font-size: 0.95em;
            line-height: 1.8;
            color: #555;
            margin: 15px 0;
            position: relative;
        }

        .citation strong {
            color: #333;
        }

        .citation-text {
            margin-bottom: 15px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .copy-citation-btn {
            background: #00693E;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .copy-citation-btn:hover {
            background: #004d2c;
            transform: translateY(-1px);
        }

        .copy-citation-btn.copied {
            background: #28a745;
        }

        .note {
            font-size: 0.9em;
            color: #888;
            font-style: italic;
            margin-top: 10px;
        }

        /* Contact Form */
        .contact-form {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .form-group {
            margin-bottom: 18px;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 18px;
        }

        .form-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: 600;
            color: #333;
            font-size: 0.95em;
        }

        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 1em;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            transition: border-color 0.2s ease;
        }

        .form-group input:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #00693E;
        }

        .form-group textarea {
            resize: vertical;
            min-height: 120px;
        }

        .form-submit-btn {
            background: #00693E;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .form-submit-btn:hover {
            background: #004d2c;
            transform: translateY(-1px);
        }

        .form-submit-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .contact-info {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
            line-height: 1.8;
        }

        .contact-info p {
            margin: 4px 0;
            color: #555;
        }

        .contact-info strong {
            color: #00693E;
            display: block;
            margin-bottom: 8px;
            font-size: 1.05em;
        }

        .contact-info a {
            color: #00693E;
            text-decoration: none;
        }

        .contact-info a:hover {
            text-decoration: underline;
        }

        /* Responsive Adjustments */
        @media (max-width: 768px) {
            .btn-about {
                top: 20px;
                right: 20px;
                padding: 8px 16px;
                font-size: 0.9em;
            }

            .intro-section {
                padding: 40px 20px;
            }

            .intro-section h1 {
                font-size: 1.8em;
            }

            .intro-instructions {
                padding: 20px;
            }

            .modal-content {
                padding: 30px 20px;
                max-height: 90vh;
            }

            .modal-content h2 {
                font-size: 1.6em;
                margin-bottom: 20px;
            }

            .about-link {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }

            .link-logo {
                height: 20px;
            }

            .form-row {
                grid-template-columns: 1fr;
                gap: 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1><i class="fas fa-brain"></i> Knowledge Map Explorer</h1>
            <p>Answer questions to visualize your conceptual understanding</p>
            <button class="btn-about" id="about-btn">
                <i class="fas fa-info-circle"></i> About
            </button>
        </div>

        <div class="content">
            <!-- Introduction Section -->
            <div id="intro-section" class="intro-section">
                <h1>Welcome!</h1>
                <p class="intro-description">
                    This interactive demo uses text embedding models to create a visual
                    map of your conceptual knowledge based on your quiz responses. Discover
                    how your understanding of biology concepts relates to each other in semantic space.
                </p>
                <div class="intro-instructions">
                    <h3>How it works:</h3>
                    <ol>
                        <li>Answer 10 biology questions at your own pace</li>
                        <li>View your personalized 2D knowledge map</li>
                        <li>Explore areas of strength and opportunities to learn</li>
                    </ol>
                </div>
                <button class="btn btn-primary" id="start-quiz-btn">
                    Start Quiz <i class="fas fa-play"></i>
                </button>
            </div>

            <!-- Quiz Section -->
            <div id="quiz-section" class="quiz-section hidden">
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill"></div>
                </div>

                <div class="question-section fade-in" id="question-container">
                    <div class="question-header">
                        <span class="question-number" id="question-number">Question 1 of 10</span>
                    </div>
                    <div class="question-text" id="question-text"></div>
                    <div class="options" id="options-container"></div>
                </div>

                <div class="button-container">
                    <button class="btn btn-secondary hidden" id="prev-btn"><i class="fas fa-arrow-left"></i> Previous</button>
                    <button class="btn btn-secondary" id="skip-btn">Skip <i class="fas fa-forward"></i></button>
                    <button class="btn btn-primary" id="next-btn" disabled>Next <i class="fas fa-arrow-right"></i></button>
                </div>
            </div>

            <!-- Map Section -->
            <div id="map-section" class="map-section hidden">
                <div class="map-header">
                    <h2>Your Knowledge Map</h2>
                    <p>Hover to explore your knowledge map</p>
                </div>

                <div class="map-container">
                    <canvas id="map-canvas"></canvas>
                    
                    <div class="legend">
                        <h4>Legend</h4>
                        <div class="legend-item">
                            <div class="legend-dot" style="background: rgb(0, 105, 62);"></div>
                            <span>Correct response</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-dot" style="background: rgb(218, 165, 32);"></div>
                            <span>Skipped question</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-dot" style="background: rgb(139, 69, 19);"></div>
                            <span>Incorrect response</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-dot" style="background: rgba(0, 0, 0, 0.1); border: 1px solid rgba(0, 0, 0, 0.3); width: 6px; height: 6px; margin-left: 5px; margin-right: 13px;"></div>
                            <span>Wikipedia article</span>
                        </div>
                    </div>

                    <div class="colorbar">
                        <h4>Inferred Knowledge</h4>
                        <div class="colorbar-gradient"></div>
                        <div class="colorbar-labels">
                            <span>Low</span>
                            <span>High</span>
                        </div>
                    </div>

                    <div class="tooltip tooltip-hidden" id="tooltip"></div>
                    
                    <div class="loading hidden" id="loading">
                        <div class="spinner"></div>
                        <p>Generating your knowledge map...</p>
                    </div>
                </div>

                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-value" id="correct-count">0</div>
                        <div class="stat-label">Correct</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="accuracy-pct">0%</div>
                        <div class="stat-label">Accuracy</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="total-count">10</div>
                        <div class="stat-label">Total Questions</div>
                    </div>
                </div>

                <div class="button-container">
                    <button class="btn btn-secondary" id="restart-btn"><i class="fas fa-rotate-right"></i> Start Over</button>
                </div>
            </div>
        </div>
    </div>

    <!-- About Modal -->
    <div id="about-modal" class="modal hidden">
        <div class="modal-backdrop"></div>
        <div class="modal-content">
            <button class="modal-close" id="close-about" aria-label="Close">
                <i class="fas fa-times"></i>
            </button>

            <h2>About This Project</h2>

            <section class="about-section">
                <h3>Research Paper</h3>
                <a href="https://osf.io/preprints/psyarxiv/dh3q2_v2" target="_blank" rel="noopener noreferrer" class="about-link">
                    <img src="logos/nature.png" alt="Nature Communications logo" class="link-logo">
                    <span>Text embedding models yield high-resolution insights into conceptual knowledge</span>
                </a>
                <div class="citation">
                    <div class="citation-text" id="citation-text">
                        Fitzpatrick, P. C., Heusser, A. C., & Manning, J. R. (2025). Text embedding models yield high-resolution insights into conceptual knowledge from short multiple-choice quizzes. <em>Nature Communications</em>: In press.
                    </div>
                    <button class="copy-citation-btn" id="copy-citation-btn">
                        <i class="fas fa-copy"></i> Copy Citation
                    </button>
                </div>
                <p class="note">
                    Note: This paper is currently in press. The link above leads to the preprint version. Once published in Nature Communications, this link will be updated with the official DOI.
                </p>
            </section>

            <section class="about-section">
                <h3>Related Resources</h3>
                <a href="https://github.com/ContextLab/efficient-learning-khan" target="_blank" rel="noopener noreferrer" class="about-link">
                    <img src="logos/github.svg" alt="GitHub logo" class="link-logo">
                    <span>Khan Academy Efficient Learning Repository</span>
                </a>
                <a href="https://www.nsf.gov/awardsearch/show-award/?AWD_ID=2145172&HistoricalAwards=false" target="_blank" rel="noopener noreferrer" class="about-link">
                    <img src="logos/nsf.png" alt="National Science Foundation logo" class="link-logo">
                    <span>NSF Award #2145172 - Supporting this research</span>
                </a>
                <a href="https://context-lab.com" target="_blank" rel="noopener noreferrer" class="about-link">
                    <img src="logos/cdl.png" alt="Context Lab logo" class="link-logo">
                    <span>Context Dynamics Lab at Dartmouth College</span>
                </a>
            </section>

            <section class="about-section">
                <h3>Contact</h3>

                <div class="contact-info">
                    <strong>Contextual Dynamics Lab</strong>
                    <p>Department of Psychological and Brain Sciences</p>
                    <p>Dartmouth College</p>
                    <p>349 Moore Hall, HB 6207</p>
                    <p>Hanover, NH 03755</p>
                    <p style="margin-top: 12px;">
                        <a href="mailto:contextualdynamics@gmail.com">contextualdynamics@gmail.com</a><br>
                        <a href="tel:6036460070">603.646.0070</a>
                    </p>
                </div>

                <form class="contact-form" id="contact-form">
                    <div class="form-row">
                        <div class="form-group">
                            <label for="contact-first-name">First Name *</label>
                            <input type="text" id="contact-first-name" name="firstName" required>
                        </div>
                        <div class="form-group">
                            <label for="contact-last-name">Last Name *</label>
                            <input type="text" id="contact-last-name" name="lastName" required>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="contact-email">Email Address *</label>
                        <input type="email" id="contact-email" name="email" required>
                    </div>
                    <div class="form-group">
                        <label for="contact-subject">Subject *</label>
                        <input type="text" id="contact-subject" name="subject" required>
                    </div>
                    <div class="form-group">
                        <label for="contact-message">Message *</label>
                        <textarea id="contact-message" name="message" required></textarea>
                    </div>
                    <button type="submit" class="form-submit-btn">
                        <i class="fas fa-paper-plane"></i> Send Message
                    </button>
                </form>
            </section>
        </div>
    </div>

    <script>
        // Questions data loaded from external file
        let questionsData = [];
        let cellLabelsData = null; // Cell labels for heatmap tooltips
        let wikipediaArticles = []; // Wikipedia articles with coordinates

        // Application state
        let currentQuestion = 0;
        let userResponses = [];
        let selectedOption = null;

        // DOM elements
        const introSection = document.getElementById('intro-section');
        const quizSection = document.getElementById('quiz-section');
        const mapSection = document.getElementById('map-section');
        const questionContainer = document.getElementById('question-container');
        const questionNumber = document.getElementById('question-number');
        const questionText = document.getElementById('question-text');
        const optionsContainer = document.getElementById('options-container');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const skipBtn = document.getElementById('skip-btn');
        const restartBtn = document.getElementById('restart-btn');
        const startQuizBtn = document.getElementById('start-quiz-btn');
        const aboutBtn = document.getElementById('about-btn');
        const aboutModal = document.getElementById('about-modal');
        const closeAboutBtn = document.getElementById('close-about');
        const copyCitationBtn = document.getElementById('copy-citation-btn');
        const contactForm = document.getElementById('contact-form');
        const progressFill = document.getElementById('progress-fill');
        const canvas = document.getElementById('map-canvas');
        const ctx = canvas.getContext('2d');
        const loading = document.getElementById('loading');
        const tooltip = document.getElementById('tooltip');

        // Hover state for animations
        let hoveredDotIndex = null;
        let hoveredHeatmapCell = null;
        let hoveredArticleIndex = null; // Wikipedia article hover state
        let dotAnimationProgress = {}; // Maps dot index to animation progress (0-1)
        let articleAnimationProgress = {}; // Maps article index to animation progress (0-1)
        let animationFrameId = null;
        let lastFrameTime = performance.now();

        // Load questions and initialize
        async function loadQuestions() {
            try {
                const response = await fetch('questions.json');
                if (!response.ok) {
                    throw new Error(`Failed to load questions: ${response.status}`);
                }
                questionsData = await response.json();
                console.log(`Loaded ${questionsData.length} questions`);
                renderQuestion();
            } catch (error) {
                console.error('Error loading questions:', error);
                questionContainer.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #e74c3c;">
                        <h3>Error Loading Questions</h3>
                        <p>Could not load questions.json. Please ensure the file exists and the page is served via HTTP(S).</p>
                        <p style="font-size: 0.9em; color: #666; margin-top: 20px;">
                            If testing locally, use a local server like: <code>python -m http.server 8000</code>
                        </p>
                    </div>
                `;
            }
        }

        // Load cell labels for heatmap tooltips
        async function loadCellLabels() {
            try {
                const response = await fetch('heatmap_cell_labels.json');
                if (!response.ok) {
                    console.warn('Cell labels not found - tooltips will show basic info only');
                    return;
                }
                const data = await response.json();
                cellLabelsData = data.cells;
                console.log(`Loaded ${cellLabelsData.length} cell labels`);
            } catch (error) {
                console.warn('Could not load cell labels:', error);
            }
        }

        // Load Wikipedia articles
        async function loadWikipediaArticles() {
            try {
                const response = await fetch('wikipedia_articles.json');
                if (!response.ok) {
                    console.warn('Wikipedia articles not found - visualization will show questions only');
                    return;
                }
                wikipediaArticles = await response.json();
                console.log(`Loaded ${wikipediaArticles.length} Wikipedia articles`);
            } catch (error) {
                console.warn('Could not load Wikipedia articles:', error);
            }
        }

        // Calculate inferred knowledge percentage for a cell
        function calculateCellKnowledge(centerX, centerY) {
            const sigma = 0.15; // Same as drawKnowledgeHeatmap
            let knowledge = 0;
            let totalWeight = 0;

            questionsData.forEach((q, idx) => {
                const dx = centerX - q.x;
                const dy = centerY - q.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const weight = Math.exp(-(dist * dist) / (2 * sigma * sigma));

                if (userResponses[idx] !== undefined && userResponses[idx] !== null) {
                    const isCorrect = userResponses[idx] === q.correctIndex;
                    knowledge += weight * (isCorrect ? 1 : 0);
                    totalWeight += weight;
                }
            });

            const value = totalWeight > 0 ? knowledge / totalWeight : 0.5;
            return Math.round(value * 100);
        }

        // Initialize
        loadQuestions();
        loadCellLabels();
        loadWikipediaArticles();

        // Event listeners
        nextBtn.addEventListener('click', handleNext);
        prevBtn.addEventListener('click', handlePrevious);
        skipBtn.addEventListener('click', handleSkip);
        restartBtn.addEventListener('click', restart);
        startQuizBtn.addEventListener('click', startQuiz);
        aboutBtn.addEventListener('click', openAbout);
        closeAboutBtn.addEventListener('click', closeAbout);
        copyCitationBtn.addEventListener('click', copyCitation);

        // About modal functions
        function openAbout() {
            aboutModal.classList.remove('hidden');
            document.body.style.overflow = 'hidden';
        }

        function closeAbout() {
            aboutModal.classList.add('hidden');
            document.body.style.overflow = '';
        }

        // Close modal on backdrop click
        aboutModal.addEventListener('click', (e) => {
            if (e.target.classList.contains('modal-backdrop')) {
                closeAbout();
            }
        });

        // Close modal on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && !aboutModal.classList.contains('hidden')) {
                closeAbout();
            }
        });

        // Copy citation to clipboard
        function copyCitation() {
            const citationText = document.getElementById('citation-text').innerText;
            navigator.clipboard.writeText(citationText).then(() => {
                const btn = copyCitationBtn;
                const originalHTML = btn.innerHTML;
                btn.innerHTML = '<i class="fas fa-check"></i> Copied!';
                btn.classList.add('copied');
                setTimeout(() => {
                    btn.innerHTML = originalHTML;
                    btn.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy citation:', err);
                alert('Failed to copy citation. Please copy manually.');
            });
        }

        // Handle contact form submission
        contactForm.addEventListener('submit', (e) => {
            e.preventDefault();

            // Get form values
            const firstName = document.getElementById('contact-first-name').value.trim();
            const lastName = document.getElementById('contact-last-name').value.trim();
            const email = document.getElementById('contact-email').value.trim();
            const subject = document.getElementById('contact-subject').value.trim();
            const message = document.getElementById('contact-message').value.trim();

            // Build mailto link
            const to = 'contextualdynamics@gmail.com';
            const fullSubject = `[MAPPER] ${subject}`;
            const body = `From: ${firstName} ${lastName}\nEmail: ${email}\n\n${message}`;

            const mailtoLink = `mailto:${to}?subject=${encodeURIComponent(fullSubject)}&body=${encodeURIComponent(body)}`;

            // Open mailto link
            window.location.href = mailtoLink;

            // Reset form after slight delay
            setTimeout(() => {
                contactForm.reset();
            }, 100);
        });

        // Start quiz (hide intro, show quiz)
        function startQuiz() {
            introSection.classList.add('hidden');
            quizSection.classList.remove('hidden');
        }

        function renderQuestion() {
            const q = questionsData[currentQuestion];
            questionNumber.textContent = `Question ${currentQuestion + 1} of ${questionsData.length}`;
            questionText.textContent = q.question;
            
            progressFill.style.width = `${(currentQuestion / questionsData.length) * 100}%`;

            optionsContainer.innerHTML = '';
            q.options.forEach((option, index) => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'option';
                
                const savedResponse = userResponses[currentQuestion];
                if (savedResponse !== undefined && savedResponse === index) {
                    optionDiv.classList.add('selected');
                    selectedOption = index;
                }

                optionDiv.innerHTML = `
                    <span class="option-label">${String.fromCharCode(65 + index)}</span>
                    ${option}
                `;
                
                optionDiv.addEventListener('click', () => selectOption(index, optionDiv));
                optionsContainer.appendChild(optionDiv);
            });

            prevBtn.classList.toggle('hidden', currentQuestion === 0);
            nextBtn.disabled = selectedOption === null;
            nextBtn.innerHTML = currentQuestion === questionsData.length - 1 ?
                'See Results <i class="fas fa-chart-line"></i>' :
                'Next <i class="fas fa-arrow-right"></i>';

            questionContainer.classList.remove('fade-in');
            void questionContainer.offsetWidth;
            questionContainer.classList.add('fade-in');
        }

        function selectOption(index, optionElement) {
            document.querySelectorAll('.option').forEach(opt => {
                opt.classList.remove('selected');
            });

            optionElement.classList.add('selected');
            selectedOption = index;
            nextBtn.disabled = false;
        }

        function handleNext() {
            userResponses[currentQuestion] = selectedOption;

            if (currentQuestion < questionsData.length - 1) {
                currentQuestion++;
                selectedOption = null;
                renderQuestion();
            } else {
                showResults();
            }
        }

        function handlePrevious() {
            if (currentQuestion > 0) {
                currentQuestion--;
                selectedOption = userResponses[currentQuestion] ?? null;
                renderQuestion();
            }
        }

        function handleSkip() {
            // Leave current question unanswered
            if (currentQuestion < questionsData.length - 1) {
                currentQuestion++;
                selectedOption = null;
                renderQuestion();
            } else {
                showResults();
            }
        }

        function showResults() {
            quizSection.classList.add('hidden');
            mapSection.classList.remove('hidden');
            loading.classList.remove('hidden');

            let correct = 0;
            userResponses.forEach((response, index) => {
                if (response === questionsData[index].correctIndex) {
                    correct++;
                }
            });

            document.getElementById('correct-count').textContent = correct;
            document.getElementById('accuracy-pct').textContent = `${Math.round((correct / questionsData.length) * 100)}%`;
            document.getElementById('total-count').textContent = questionsData.length;

            setTimeout(() => {
                loading.classList.add('hidden');
                generateKnowledgeMap();
            }, 1500);
        }

        function generateKnowledgeMap() {
            const container = canvas.parentElement;
            const dpr = window.devicePixelRatio || 1;
            canvas.width = container.clientWidth * dpr;
            canvas.height = container.clientHeight * dpr;
            canvas.style.width = container.clientWidth + 'px';
            canvas.style.height = container.clientHeight + 'px';
            ctx.scale(dpr, dpr);

            const width = container.clientWidth;
            const height = container.clientHeight;

            // Create knowledge heatmap
            drawKnowledgeHeatmap(width, height);

            // Draw Wikipedia article dots (between heatmap and questions)
            drawWikipediaArticles(width, height);

            // Draw question markers
            drawQuestionMarkers(width, height);

            // Add interactivity
            addInteractivity(width, height);

            // Make legend and colorbar draggable (only initialize once)
            if (!canvas.dataset.draggableInitialized) {
                const legend = document.querySelector('.legend');
                const colorbar = document.querySelector('.colorbar');
                if (legend) makeDraggable(legend);
                if (colorbar) makeDraggable(colorbar);
                canvas.dataset.draggableInitialized = 'true';
            }
        }

        function redrawCanvas() {
            // Get current canvas dimensions
            const container = canvas.parentElement;
            const width = canvas.width / window.devicePixelRatio;
            const height = canvas.height / window.devicePixelRatio;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Redraw heatmap, articles, and markers
            drawKnowledgeHeatmap(width, height);
            drawWikipediaArticles(width, height);
            drawQuestionMarkers(width, height);
        }

        function animateCanvas() {
            const currentTime = performance.now();
            const deltaTime = currentTime - lastFrameTime;
            lastFrameTime = currentTime;

            let needsRedraw = false;

            // Update animation progress for all question dots
            questionsData.forEach((q, idx) => {
                const isHovered = (hoveredDotIndex === idx);
                const target = isHovered ? 1 : 0;
                const current = dotAnimationProgress[idx] || 0;

                if (Math.abs(current - target) > 0.01) {
                    // Smooth transition (50ms duration - very snappy)
                    const speed = 1 / 50; // Progress per millisecond
                    const delta = (target - current) * Math.min(speed * deltaTime, 1);
                    dotAnimationProgress[idx] = Math.max(0, Math.min(1, current + delta));
                    needsRedraw = true;
                } else {
                    dotAnimationProgress[idx] = target;
                }
            });

            // Update animation progress for Wikipedia article dots
            wikipediaArticles.forEach((article, idx) => {
                const isHovered = (hoveredArticleIndex === idx);
                const target = isHovered ? 1 : 0;
                const current = articleAnimationProgress[idx] || 0;

                if (Math.abs(current - target) > 0.01) {
                    // Smooth transition (50ms duration - same as questions)
                    const speed = 1 / 50; // Progress per millisecond
                    const delta = (target - current) * Math.min(speed * deltaTime, 1);
                    articleAnimationProgress[idx] = Math.max(0, Math.min(1, current + delta));
                    needsRedraw = true;
                } else {
                    articleAnimationProgress[idx] = target;
                }
            });

            if (needsRedraw) {
                redrawCanvas();
                animationFrameId = requestAnimationFrame(animateCanvas);
            } else {
                animationFrameId = null;
            }
        }

        function startAnimation() {
            if (!animationFrameId) {
                lastFrameTime = performance.now();
                animationFrameId = requestAnimationFrame(animateCanvas);
            }
        }

        function drawKnowledgeHeatmap(width, height) {
            const gridSize = 40;
            const sigma = 0.15; // Gaussian kernel width

            // Create a 2D grid of knowledge values
            const grid = [];
            for (let gy = 0; gy < gridSize; gy++) {
                grid[gy] = [];
                for (let gx = 0; gx < gridSize; gx++) {
                    const x = gx / (gridSize - 1);
                    const y = gy / (gridSize - 1);
                    
                    // Calculate knowledge at this point based on nearby correct/incorrect answers
                    let knowledge = 0;
                    let totalWeight = 0;
                    
                    questionsData.forEach((q, idx) => {
                        const dx = x - q.x;
                        const dy = y - q.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const weight = Math.exp(-(dist * dist) / (2 * sigma * sigma));
                        
                        if (userResponses[idx] !== undefined) {
                            const isCorrect = userResponses[idx] === q.correctIndex;
                            knowledge += weight * (isCorrect ? 1 : 0);
                            totalWeight += weight;
                        }
                    });
                    
                    grid[gy][gx] = totalWeight > 0 ? knowledge / totalWeight : 0.5;
                }
            }

            // Draw heatmap
            const cellWidth = width / (gridSize - 1);
            const cellHeight = height / (gridSize - 1);

            for (let gy = 0; gy < gridSize - 1; gy++) {
                for (let gx = 0; gx < gridSize - 1; gx++) {
                    const value = grid[gy][gx];
                    let color = mapToColor(value);

                    // Darken if this is the hovered cell
                    if (hoveredHeatmapCell && hoveredHeatmapCell.gx === gx && hoveredHeatmapCell.gy === gy) {
                        color = darkenColor(color, 0.15);
                    }

                    ctx.fillStyle = color;
                    ctx.fillRect(
                        gx * cellWidth,
                        gy * cellHeight,
                        cellWidth + 1,
                        cellHeight + 1
                    );
                }
            }
        }

        function mapToColor(value) {
            // Bronze-to-Green colormap (complementary to Dartmouth Green)
            const colors = [
                [139, 69, 19],    // Saddle Brown (low)
                [184, 134, 11],   // Dark Goldenrod
                [218, 165, 32],   // Goldenrod
                [0, 133, 66],     // Medium Green
                [0, 105, 62]      // Dartmouth Green (high)
            ];

            const scaled = value * (colors.length - 1);
            const idx = Math.floor(scaled);
            const t = scaled - idx;

            if (idx >= colors.length - 1) {
                const c = colors[colors.length - 1];
                return `rgba(${c[0]}, ${c[1]}, ${c[2]}, 0.8)`;
            }

            const c1 = colors[idx];
            const c2 = colors[idx + 1];
            
            const r = Math.round(c1[0] + (c2[0] - c1[0]) * t);
            const g = Math.round(c1[1] + (c2[1] - c1[1]) * t);
            const b = Math.round(c1[2] + (c2[2] - c1[2]) * t);

            return `rgba(${r}, ${g}, ${b}, 0.8)`;
        }

        function darkenColor(colorString, amount = 0.2) {
            // Parse RGB/RGBA color string and darken it
            const matches = colorString.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
            if (!matches) return colorString;

            const r = Math.floor(parseInt(matches[1]) * (1 - amount));
            const g = Math.floor(parseInt(matches[2]) * (1 - amount));
            const b = Math.floor(parseInt(matches[3]) * (1 - amount));
            const a = matches[4] !== undefined ? parseFloat(matches[4]) : 1;

            return `rgba(${r}, ${g}, ${b}, ${a})`;
        }

        function drawWikipediaArticles(width, height) {
            // Render articles in extended region (includes articles outside [0,1] for context)
            wikipediaArticles.forEach((article, idx) => {
                const x = article.x;
                const y = article.y;

                // Skip articles outside the extended region [-0.5, 1.5]
                // (matches the filtering in export script)
                if (x < -0.5 || x > 1.5 || y < -0.5 || y > 1.5) {
                    return;
                }

                const baseX = x * width;
                const baseY = y * height;

                // Get animation progress for this article (0 = not hovered, 1 = fully hovered)
                const animProgress = articleAnimationProgress[idx] || 0;

                // Base radius for article dots (small, as specified)
                const baseRadius = 2;

                // When hovered, grow slightly
                const radius = baseRadius + (1 * animProgress);

                // Base alpha (very subtle when not hovered)
                const baseAlpha = 0.1;
                const hoverAlpha = 0.5;
                const alpha = baseAlpha + (hoverAlpha - baseAlpha) * animProgress;

                // Draw article dot (black)
                ctx.beginPath();
                ctx.arc(baseX, baseY, radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(0, 0, 0, ${alpha})`;
                ctx.fill();
            });
        }

        function drawQuestionMarkers(width, height) {
            questionsData.forEach((q, idx) => {
                const baseX = q.x * width;
                const baseY = q.y * height;
                const radius = 12;

                const wasAnswered = userResponses[idx] !== undefined;
                const isCorrect = userResponses[idx] === q.correctIndex;

                // Get animation progress for this dot (0 = not hovered, 1 = fully hovered)
                const animProgress = dotAnimationProgress[idx] || 0;

                // Calculate hover offset (3px up and right when fully hovered)
                const offsetX = 3 * animProgress;
                const offsetY = -3 * animProgress;
                const currentX = baseX + offsetX;
                const currentY = baseY + offsetY;

                let baseColor;
                if (!wasAnswered) {
                    // Unanswered - intermediate knowledge (goldenrod)
                    baseColor = 'rgb(218, 165, 32)';
                } else if (isCorrect) {
                    // Correct - high knowledge (Dartmouth Green)
                    baseColor = 'rgb(0, 105, 62)';
                } else {
                    // Incorrect - low knowledge (saddle brown)
                    baseColor = 'rgb(139, 69, 19)';
                }

                // Darken color when hovered
                const color = animProgress > 0 ? darkenColor(baseColor, 0.2 * animProgress) : baseColor;

                // Draw drop shadow at original position when hovered
                if (animProgress > 0) {
                    const shadowRadius = radius + (2 * animProgress);
                    ctx.save();
                    ctx.shadowColor = `rgba(0, 0, 0, ${0.15 * animProgress})`; // Very low alpha for soft edges
                    ctx.shadowBlur = 50 * animProgress; // Extra large blur radius for very diffuse, soft shadows
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;

                    ctx.beginPath();
                    ctx.arc(baseX, baseY, shadowRadius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(0, 0, 0, ${0.1 * animProgress})`; // Very low fill alpha for soft appearance
                    ctx.fill();
                    ctx.restore();
                }

                // Draw marker with white border (at current position with offset)
                ctx.beginPath();
                ctx.arc(currentX, currentY, radius + 2, 0, Math.PI * 2);
                ctx.fillStyle = 'white';
                ctx.fill();

                ctx.beginPath();
                ctx.arc(currentX, currentY, radius, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();

                // Draw question number
                ctx.fillStyle = 'white';
                ctx.font = 'bold 11px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText((idx + 1).toString(), currentX, currentY);
            });
        }

        function getHeatmapCell(mouseX, mouseY, width, height) {
            const gridSize = 40;
            const cellWidth = width / (gridSize - 1);
            const cellHeight = height / (gridSize - 1);

            const gx = Math.floor(mouseX / cellWidth);
            const gy = Math.floor(mouseY / cellHeight);

            if (gx >= 0 && gx < gridSize - 1 && gy >= 0 && gy < gridSize - 1) {
                // Return cell center in normalized coordinates
                const centerX = (gx + 0.5) / (gridSize - 1);
                const centerY = (gy + 0.5) / (gridSize - 1);
                return { gx, gy, centerX, centerY };
            }
            return null;
        }

        function showHeatmapTooltip(canvasRect, cell) {
            // Find cell label if available
            let label = 'Unknown Region';
            if (cellLabelsData) {
                const cellData = cellLabelsData.find(c =>
                    Math.abs(c.center_x - cell.centerX) < 0.001 &&
                    Math.abs(c.center_y - cell.centerY) < 0.001
                );
                if (cellData && cellData.label) {
                    label = cellData.label;
                }
            }

            // Calculate knowledge percentage
            const knowledgePct = calculateCellKnowledge(cell.centerX, cell.centerY);

            tooltip.innerHTML = `
                <div class="tooltip-question">${label}</div>
                <div class="tooltip-status">
                    <span>Inferred Knowledge: ${knowledgePct}%</span>
                </div>
            `;

            tooltip.classList.remove('tooltip-hidden');
            setTimeout(() => tooltip.classList.add('visible'), 10);

            // Calculate cell center position on screen
            const cellCanvasX = cell.centerX * canvasRect.width;
            const cellCanvasY = cell.centerY * canvasRect.height;
            const cellScreenX = canvasRect.left + cellCanvasX;
            const cellScreenY = canvasRect.top + cellCanvasY;

            // Get tooltip dimensions
            const tooltipRect = tooltip.getBoundingClientRect();
            const offset = 15;

            // Determine quadrant based on normalized position
            const isLeftHalf = cell.centerX < 0.5;
            const isTopHalf = cell.centerY < 0.5;

            let left, top;

            // Position tooltip based on quadrant
            if (isLeftHalf) {
                left = cellScreenX + offset;
            } else {
                left = cellScreenX - tooltipRect.width - offset;
            }

            if (isTopHalf) {
                top = cellScreenY + offset;
            } else {
                top = cellScreenY - tooltipRect.height - offset;
            }

            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }

        function addInteractivity(width, height) {
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = (e.clientX - rect.left) / rect.width * width;
                const mouseY = (e.clientY - rect.top) / rect.height * height;

                // Check for question dot hover (highest priority)
                let hoveredQuestion = null;
                questionsData.forEach((q, idx) => {
                    const x = q.x * width;
                    const y = q.y * height;
                    const dist = Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2);

                    if (dist < 15) {
                        hoveredQuestion = { ...q, index: idx };
                    }
                });

                if (hoveredQuestion) {
                    // Question dot takes priority
                    hoveredDotIndex = hoveredQuestion.index;
                    hoveredArticleIndex = null;
                    hoveredHeatmapCell = null;
                    showTooltip(rect, hoveredQuestion);
                    canvas.style.cursor = 'pointer';
                    startAnimation();
                } else {
                    // Check for Wikipedia article hover (second priority)
                    let hoveredArticle = null;
                    wikipediaArticles.forEach((article, idx) => {
                        // Skip articles outside extended region
                        if (article.x < -0.5 || article.x > 1.5 || article.y < -0.5 || article.y > 1.5) {
                            return;
                        }

                        const x = article.x * width;
                        const y = article.y * height;
                        const dist = Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2);

                        // Use larger hover radius for easier interaction
                        if (dist < 8) {
                            hoveredArticle = { ...article, index: idx };
                        }
                    });

                    if (hoveredArticle) {
                        // Wikipedia article hover
                        hoveredDotIndex = null;
                        hoveredArticleIndex = hoveredArticle.index;
                        hoveredHeatmapCell = null;
                        showArticleTooltip(rect, hoveredArticle);
                        canvas.style.cursor = 'pointer';
                        startAnimation();
                    } else {
                        // Check for heatmap cell hover (lowest priority)
                        const cell = getHeatmapCell(mouseX, mouseY, width, height);

                        if (cell) {
                            hoveredDotIndex = null;
                            hoveredArticleIndex = null;
                            hoveredHeatmapCell = cell;
                            showHeatmapTooltip(rect, cell);
                            canvas.style.cursor = 'crosshair';
                            redrawCanvas(); // Immediate redraw to darken heatmap cell
                            startAnimation(); // Also ensure dots animate back if they were hovered
                        } else {
                            hoveredDotIndex = null;
                            hoveredArticleIndex = null;
                            hoveredHeatmapCell = null;
                            hideTooltip();
                            canvas.style.cursor = 'default';
                            redrawCanvas(); // Immediate redraw to un-darken heatmap cells
                            startAnimation(); // Animate dots back to normal
                        }
                    }
                }
            });

            canvas.addEventListener('mouseleave', () => {
                hoveredDotIndex = null;
                hoveredArticleIndex = null;
                hoveredHeatmapCell = null;
                hideTooltip();
                startAnimation();
            });

            // Add click handler for Wikipedia articles
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = (e.clientX - rect.left) / rect.width * width;
                const mouseY = (e.clientY - rect.top) / rect.height * height;

                // Check if clicking on a Wikipedia article
                let clickedArticle = null;
                wikipediaArticles.forEach((article, idx) => {
                    // Skip articles outside extended region
                    if (article.x < -0.5 || article.x > 1.5 || article.y < -0.5 || article.y > 1.5) {
                        return;
                    }

                    const x = article.x * width;
                    const y = article.y * height;
                    const dist = Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2);

                    if (dist < 8) {
                        clickedArticle = article;
                    }
                });

                // Open Wikipedia article in new tab
                if (clickedArticle && clickedArticle.url) {
                    window.open(clickedArticle.url, '_blank');
                }
            });
        }

        function showTooltip(canvasRect, question) {
            const wasAnswered = userResponses[question.index] !== undefined;
            const isCorrect = userResponses[question.index] === question.correctIndex;

            let status, statusColor;
            if (!wasAnswered) {
                status = 'Unanswered';
                statusColor = 'rgb(218, 165, 32)';  // Intermediate knowledge (goldenrod)
            } else if (isCorrect) {
                status = 'Correct';
                statusColor = 'rgb(0, 105, 62)';  // High knowledge (Dartmouth Green)
            } else {
                status = 'Incorrect';
                statusColor = 'rgb(139, 69, 19)';  // Low knowledge (saddle brown)
            }

            tooltip.innerHTML = `
                <div class="tooltip-question">Q${question.index + 1}: ${question.question}</div>
                <div class="tooltip-status">
                    <div class="tooltip-dot" style="background: ${statusColor};"></div>
                    <span>${status}</span>
                </div>
            `;

            tooltip.classList.remove('tooltip-hidden');
            setTimeout(() => tooltip.classList.add('visible'), 10);

            // Calculate dot position on screen
            const dotCanvasX = question.x * canvasRect.width;
            const dotCanvasY = question.y * canvasRect.height;
            const dotScreenX = canvasRect.left + dotCanvasX;
            const dotScreenY = canvasRect.top + dotCanvasY;

            // Get tooltip dimensions
            const tooltipRect = tooltip.getBoundingClientRect();
            const offset = 15;  // Offset from dot (in pixels)

            // Determine quadrant based on normalized position (0-1 range)
            // This ensures tooltips stay within heatmap bounds
            const isLeftHalf = question.x < 0.5;
            const isTopHalf = question.y < 0.5;

            let left, top;

            // Position tooltip based on quadrant
            if (isLeftHalf) {
                // Dot is on left side - show tooltip to the right
                left = dotScreenX + offset;
            } else {
                // Dot is on right side - show tooltip to the left
                left = dotScreenX - tooltipRect.width - offset;
            }

            if (isTopHalf) {
                // Dot is on top half - show tooltip below
                top = dotScreenY + offset;
            } else {
                // Dot is on bottom half - show tooltip above
                top = dotScreenY - tooltipRect.height - offset;
            }

            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }

        function showArticleTooltip(canvasRect, article) {
            // Display article title and excerpt
            tooltip.innerHTML = `
                <div class="tooltip-question">${article.title}</div>
                <div class="tooltip-status">
                    <span>${article.excerpt}</span>
                </div>
            `;

            tooltip.classList.remove('tooltip-hidden');
            setTimeout(() => tooltip.classList.add('visible'), 10);

            // Calculate article position on screen
            const articleCanvasX = article.x * canvasRect.width;
            const articleCanvasY = article.y * canvasRect.height;
            const articleScreenX = canvasRect.left + articleCanvasX;
            const articleScreenY = canvasRect.top + articleCanvasY;

            // Get tooltip dimensions
            const tooltipRect = tooltip.getBoundingClientRect();
            const offset = 15;  // Offset from dot (in pixels)

            // Determine quadrant based on normalized position (0-1 range)
            const isLeftHalf = article.x < 0.5;
            const isTopHalf = article.y < 0.5;

            let left, top;

            // Position tooltip based on quadrant to avoid overlap
            if (isLeftHalf) {
                // Article is on left side - show tooltip to the right
                left = articleScreenX + offset;
            } else {
                // Article is on right side - show tooltip to the left
                left = articleScreenX - tooltipRect.width - offset;
            }

            if (isTopHalf) {
                // Article is on top half - show tooltip below
                top = articleScreenY + offset;
            } else {
                // Article is on bottom half - show tooltip above
                top = articleScreenY - tooltipRect.height - offset;
            }

            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }

        function hideTooltip() {
            tooltip.classList.remove('visible');
            setTimeout(() => {
                tooltip.classList.add('tooltip-hidden');
            }, 200); // Match CSS transition duration
        }

        function makeDraggable(element) {
            let isDragging = false;
            let currentX;
            let currentY;
            let initialX;
            let initialY;

            element.addEventListener('mousedown', (e) => {
                // Only start drag if clicking on the element itself, not child elements
                isDragging = true;
                element.classList.add('dragging');

                initialX = e.clientX - element.offsetLeft;
                initialY = e.clientY - element.offsetTop;

                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    e.preventDefault();

                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;

                    // Get parent container bounds
                    const parent = element.parentElement;
                    const parentRect = parent.getBoundingClientRect();
                    const elementRect = element.getBoundingClientRect();

                    // Constrain within parent bounds
                    const maxX = parentRect.width - elementRect.width;
                    const maxY = parentRect.height - elementRect.height;

                    currentX = Math.max(0, Math.min(currentX, maxX));
                    currentY = Math.max(0, Math.min(currentY, maxY));

                    // Update position (remove any existing top/bottom/left/right)
                    element.style.top = currentY + 'px';
                    element.style.left = currentX + 'px';
                    element.style.right = 'auto';
                    element.style.bottom = 'auto';
                }
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    element.classList.remove('dragging');
                }
            });
        }

        function restart() {
            currentQuestion = 0;
            userResponses = [];
            selectedOption = null;
            mapSection.classList.add('hidden');
            quizSection.classList.add('hidden');
            introSection.classList.remove('hidden');
            progressFill.style.width = '0%';
            hideTooltip();
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            if (!mapSection.classList.contains('hidden')) {
                generateKnowledgeMap();
            }
        });
    </script>
</body>
</html>
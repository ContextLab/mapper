How does the computer evaluate expressions with illogical operators and, or, and not? To find out, let's explore the order of operations for compound Boolean expressions. Imagine we're working on a program to check if a specific song matches the filters for a specific playlist. This expression asks, are the song's beats per minute both greater than or equal to 150 and less than or equal to 180? Illogical operators like this and come last in the order of operations. So the computer evaluates the two sides separately first. Let's say the variable bpm contains the value 200. The comparison operators greater than or equal to and less than or equal to have the same level of precedence, so the computer evaluates left to right. So we substitute in that 200 on the left hand side first and simplify. 200 is greater than or equal to 150, so this evaluates to true. Then we jump to the right hand side. 200 is not less than or equal to 180, so this evaluates to false. Now that we've simplified both sides down to a Boolean value, we evaluate the and. An expression with the and operator only evaluates to true if both sides are true, so a true and a false evaluates to false. And boom, the computer has its answer. Let's try an expression where there are multiple logical operators. This asks the question, is the genre any of the spellings of lo-fi? Let's say the variable genre contains the string lo-fi. We evaluate the expressions around the logical operators first and then apply the ors. We start with the leftmost expression. These strings are not equal, so this evaluates to false. We jump to the second expression. These strings are equal, so this evaluates to true. And then the third part, these strings are not equal, so this evaluates to false. Now that we're all simplified, we take a look at the ors. An expression with the or operator evaluates to true if at least one of the sides is true. False or true evaluates to true, and then true or false evaluates to true. Now you may be thinking, whoa, did I even need to evaluate that last part? Once I knew that second expression evaluated to true, I knew that my final answer was going to be true. As it's evaluating, the computer makes the same optimization. We call this short circuit evaluation, or lazy evaluation. In its laziness, the computer stops evaluating as soon as it knows the final answer. With the or operator, the computer stops evaluating as soon as it finds a side that evaluates to true. Because no matter what's on the other side, the expression will always evaluate to true. True or true evaluates to true, and true or false also evaluates to true. With the and operator, we have the opposite. The computer stops as soon as it finds a side that evaluates to false. No matter what's on the other side, the whole expression will evaluate to false. Because false and true evaluates to false, and false and false also evaluates to false. Okay, so the computer is saving itself some work. Why do I care? Consider this Boolean expression. Looks pretty sensible, but what if the variable group size contains a value zero? The computer can't divide by zero, so this gives a runtime error. Well, we could just not do that, but we might not control the value of group size. Maybe it's set by user input. To solve this, we can check that group size doesn't equal zero first. If group size is equal to zero, the left hand side will evaluate to false, and the computer will short circuit. It'll jump to the conclusion that the whole expression must evaluate to false and won't bother evaluating the right hand side, thus avoiding the division by zero. We can use this pattern across our programs, taking advantage of short circuit evaluation to check for preconditions that allow us to avoid possible errors. Last bit, what about the not operator? The not operator takes precedence over the and and or operators. That means this expression really asks, is the genre not equal to rock and is the BPM greater than 130? Now, we want to be careful about overusing the not operator when we don't need to, because it tends to make things more confusing. For example, this expression is just equivalent to genre not equals rock and BPM greater than 130. If instead I put parentheses here, I would be negating the whole expression. This asks, is it not both a rock song and a fast song? That's equivalent to the expression, is the genre not equal to rock or is the BPM less than or equal to 130? If either of these conditions is true, then this and expression would evaluate to false, which means not it would evaluate to true. Now you're probably starting to understand why I said to use the not operator sparingly. If you do need to negate a compound Boolean expression, it's often easier to understand if you break it down into multiple parts. Otherwise, the not operator tends to make your program a bit less readable, just like if I said something like, I prefer not blue colors, or I'm going to not not in this video now.
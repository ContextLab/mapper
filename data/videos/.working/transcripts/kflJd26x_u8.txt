What exactly happens when the computer executes a function call? Well, let's trace a program with a function definition to find out. When we run the program, the computer, as normal, reads the program line by line, starting at the top of the file. When the computer sees the keyword def, it goes off to a short-term memory and defines a new function. We can think of this as the computer copying the function body into a place in memory, and then it tags that location with the function name and the number of parameters. The computer technically makes some optimizations here, but we can think of it the same way. Effectively, the computer has just learned a new task named get greeting. Note, however, that the computer does not yet execute any of these lines of code. It's just learning the new task right now, not doing it. When it's done learning, it skips to the next line of code after the function definition. Remember that Python's all about that indentation, so these lines of code are all part of the function body since they're indented over from the function header. To make this a bit easier to see, I'm going to scroll the program up, but those lines of code still exist. Here we just have a normal variable assignment, and since the right-hand side is already a single value, we're ready to store that in short-term memory. The computer stores the value 6 and then tags that location with the name lastchatted. Next line, we have another variable assignment, but before we store, we need to simplify down the right-hand side to a single value. As with all expressions, we start simplifying with the parentheses. So we substitute in the current value of lastchatted and add 1. Now that our arguments are down to single values, we're ready to call the function. To start, the computer checks its memory to see if it knows the name get greeting with two input parameters. In this case, it does, so it loads those instructions to execute. The first thing the computer does when it calls a function is create a new stack frame. A stack frame is its own isolated chunk of short-term memory. When the computer executes a function, it treats it as its own little subprogram. It doesn't want that subprogram to muck with the state of the larger program, so it ropes it off from the rest of its memory. Anything that was stored before is still there, we just don't get access to it right now. First, we need to store the arguments that were passed in. To do this, the computer copies the argument values into new locations in its stack frame. Then it tags each location with the corresponding parameter name. This is order-dependent, so the first argument in the function call gets assigned to the first parameter in the function header. Then we're just executing these lines of code per normal. 7 is not less than 1, so this evaluates to false, and we jump to the else branch, and we assign the string, always good to see you, to a new variable greeting in our own stack frame. Then, we're at the return statement. The return keyword tells the computer to exit the function and return execution back to wherever the function was called. But first, it needs to calculate the return value, so we need to simplify down this expression. We plug in the current values of greeting and catchphrase, and then we concatenate everything together. Now, the computer jumps execution back to the call site, taking that return value with it. However, this stack frame does not get to come back. We've effectively terminated this subprogram, so its short-term memory gets cleared. We take that return value to go as we pop off that stack frame. What that means in practice is that this function call expression evaluates down to the return value. So now we have the statement, response is assigned the value, always good to see you, kirpal. We have a single value now, so we can go off and create that variable. Because we cleared that stack frame, we're back in our global memory space, so we store response there. Now finally, we get to move to the next line. This just reassigns the variable lastchatted to the value zero. Easy. Here we've got another function call to get greeting, so we just do the same thing. Our two arguments are already simplified down to single values, so we can just go ahead and call the function. The computer loads the instructions associated with get greeting from memory, and like before, it also creates a new stack frame. It copies the arguments into the corresponding parameters, and then continues on to execute the function body. Days since spoken contains zero this time, so we execute the if branch. And then we're back at the return statement. This string expression evaluates down to, oh, it's you again, mabines. And once we have that single value, we return back to the call site, popping off that stack frame. Now this is a bit of a weird one. This function call expression evaluates down to that string we returned. However, this line of code doesn't do anything with that string. I wouldn't recommend writing programs like this, because we're wasting the computer's time calculating a result that we don't need. But I took the creative liberty here so I could show what happens. This instruction is complete, so we move to the next line. And unfortunately, since we didn't store it, that function call return value gets lost to time. We are back in our global memory space, and we have a print statement. We load in the value of response, and then we concatenate it to the first string. Once we have that single value, we go ahead and display it in the console. And then we hit the last line, so the computer clears out his global memory and terminates the program. Notice that that function definition gets cleared out from memory too. The computer doesn't remember user defined functions across program executions. So we need that function definition to teach it how to get greeting every time.
We can use objects to store data. But their true power comes from bundling data and behavior together. By behavior, I mean that an object can do things. It can act on the data it stores. To define an object's behavior, we just need methods. A method is a function that belongs to an object. Meaning, it's a function that's defined on a specific data type. Typically, we use methods to access or update an object's attributes. But instead of passing the object as an argument to the method, we call the method on the object. Just like we use dot syntax to access an object's attributes, we also use dot syntax to call an object's methods. Let's consider a bank account type. A bank account might have the attributes owner and balance. What actions can we take on a bank account? Well, we can get the current balance, deposit money, or withdraw money. We can achieve all of those behaviors by directly working with each account's balance, but it's easy for a programmer to make a mistake here. They might forget to round the balance to two decimal places or withdraw more money than there is. To solve for this, we think through those requirements upfront and then wrap that common logic inside a function. We call this concept encapsulation, where an object manages its own data. Outside code doesn't modify an object's attributes directly. It only interacts with the object through those well-defined methods, thus protecting the object's attributes from invalid changes. That's the theory of methods. Now, let's take a look at the actual syntax. We have a class definition for a bank account type with an owner and a balance attribute. We want to guarantee that whenever we access an account's balance, it's always rounded correctly. So, we can write a function that takes in a bank account object. Let's call that parameter self and returns its rounded balance. Now, here's the method magic. Notice that we indented this function definition inside of our bank account class definition that attaches this function to the bank account type, thus making it a method. When we call a method on an object, Python automatically passes in that object as the first argument. Just like with our init method, the first parameter is always the object we're acting on. And by convention, we always name that parameter self. This once again is just a convenient syntax shortcut. Python knows that checking is a bank account type. So when we call get balance on checking, Python knows to look for that get balance definition inside the bank account class. We can tell Python that information explicitly. We can say go to the bank account class and find the get balance definition and then we manually pass in that checking object. These expressions are equivalent. They do the exact same thing. They get the balance of the checking object. This first one is just a bit easier and it doesn't require that we know where the bank account class lives. So programmers prefer this syntax of calling the method on the object. Methods can access and return data but they can also mutate it. I can write a method deposit that as always first takes in the object and then an amount. Inside the method, I'll just add that amount to the object's balance attribute. And then I'll add another method withdraw that subtracts an amount from an object's balance. When we call those methods on the checking object, it automatically gets passed in as that first argument. So we only need to pass in a value for amount. The real value of these methods is that we can add more logic around these updates. So, let's make sure no one deposits a negative amount and no one withdraws an amount greater than their current balance. If other programmers play by the rules and only access balance through these methods, we can guarantee that this validation always runs before balance gets updated. That's the power of encapsulation. We define all of the rules for a type inside the class definition. What data it stores in the attributes and how that data can be accessed and updated in the methods. Then we can use those methods to safely interact with objects of that type. thinking in terms of the behaviors deposit and withdraw instead of the details of how the code and attributes
This is our Ulam Spiral Fun Program, and I'm sure I'm mispronouncing Ulam or Ulam. But what it is is a way to visualize number factors, and in particular, a way to visualize prime numbers. And so it starts at the center here. This is the number 1. And it calculates how many factors does 1 have? Well, 1 only has one factor. And so the way I did it, if something has very few factors, it draws a bigger circle. If it has a lot of factors, it draws a smaller circle. So 1 is the biggest circle, because only it, out of all of the positive integers, only it has only one factor. And it's actually not considered prime. Prime numbers have two factors. The number 1 and itself, they have exactly two factors. 1 has one factor. Then we go to 2. We move up here to 2. 2 is prime. So we draw it this size. Then we go to 3. 3 is also prime. Has two factors. Then we go to 4. 4 has more factors, so it's smaller. Then 5 is prime again. 6 is even smaller, because it has 1, 2, 3, and 6. Then 7 is prime. 8, 9, 10, 11 is prime again. 12, 13 is prime. And we keep spiraling outwards. And you see this kind of interesting pattern. And to just get a sense of it, we can zoom out by making the size of each of the, I haven't drawn it, but the bounding boxes around. It's not really a bounding boxes, but you can imagine each of these circles sits in a kind of a little box. If we make each of those smaller, let me try my best to, then we start to zoom out. Because the way the program's written, it makes sure that we have enough of these boxes to actually cover our thing. But we see this really fascinating pattern. And I really encourage you to play with it. Now with that out of the way, let's actually try to understand the underlying structure of our program. And I'm just going to do the underlying structure. I'm going to assume that you know something about functions, and variables, and conditionals, and loops, and all the rest. So this first part right over here, we're just setting some variables, kind of dealing with the scale of things. This is the size of each individual cell right over here. Then what's the scale of the circles is the next line. Then we figure out how many total cells you have. And you're essentially dividing the number of pixels in each dimension on our canvas by our cell size. So let's say that our cell size is 100. Let me just draw this just so you get the general idea. So let's say this is 400 by 400 pixels. If each of our cells are 100 pixels in both directions, then the x direction, you could have four cells. And in the y direction, you have four cells. And the way we calculate that is you divide 400 by the cell size. So cell size is 100. You have four cells in each direction. The reason why we add this one, not to go into too much detail, is just to make sure we cover everything. I encourage you to see what happens if you delete that. So all of this stuff right over here just deals with kind of the scale at which we are operating. All of this stuff right over here. I'll just write that down. Scale at which we are operating. Then this part right over here, we're setting up an underlying data structure to represent the numbers as we write them. And we need that information because as we draw our spiral, we're going to have to keep track of whether adjacent cells have been filled in or not. So this is initializing the two-dimensional array, where we're going to hold the actual number of factors. So this is the array part, initializing the array. And then down here, we calculate the cent. Let me do this in a different color. This right over here is to calculate what the center cell is. So we're literally just dividing the number of cells we have in each dimension by two. But we're rounding it because in order to reference the elements of an array, you need to have an integer. So that's why we're rounding it. And then we set our initial direction. But we're going to see as we start our program that this changes very, very, very fast. But the convention here is that this variable xder says, how much are we going to increment in the x direction each time? Yder says, how much do we increment in the y direction? And so if you increment if xder is 1 and yder is 0, that means every time you're going to increase x by 1, y by 0. Doing that means you're going to move to the right. So let me do that in a yellow color. You are going to move to the right. If xder were 0 and yder was 1, that means every time you're going to increase your y by some value. And based on how our coordinate system is set up, because this right over here is 0, 0, at any point that you're at, if you increase it just the y, you're going to move down. And I let you think about, and we're going to see later on in the program, well, how do you specify to the left? Well, maybe just make extra negative 1. How do you move up? Well, maybe just make wider negative 1. We'll see that later on. This line, this is just an offset. You actually could set offset to 0 and see what happens. But it makes sure that as we zoom in and out that our center cell is always the center of the canvas. And it makes the zooming in and out a little bit less shaky. But if you set it to 0, then you're just going to get a little bit of that shake in there. Now down here, this is our first, or actually, this is our only function that we define in our program. And the purpose of this function is really just to, you pass it a number, and it tells you how many factors that has. And then we use that information to decide how large of a circle to actually draw. You pass in a number, and it returns the factors. If the number's 1, it just returns 1. It just cuts to the chase. 1 has exactly one factor. Otherwise, it starts at 1, and it goes up to the square root of that number to try to figure out the number of factors. And you might say, well, why doesn't it go all the way up to the number? Well, the square root of that number will grow smaller than the number. So this is actually a faster algorithm than if you had to figure out all the factors of 10,000. Now you only have to go test the numbers between 1 and 100. You don't have to figure out the numbers between 1 and 10,000. And to see why this works, why you only have to go up to the square root of a number, let's think about this. Let's say that you're trying to figure out num factors. We do that same magenta color. You're trying to figure out num factors of 16. So this algorithm right over here, well, the number isn't 1, so we won't just return 1. And when you return 1, you don't actually do the rest of the program. So that's why that was fast, just with 1. But let's see. We'll start at factor count of 0. You calculate the square root of 16, which in this case is 4. And then for i is equal to 1, all the way up to and including up to the square root of this number, you see if it's a factor. So you test 1, you say, yeah, sure, that's a factor. You test 2, yeah, that's a factor. You test 3, 3 is not a factor. And that's what this is testing. This is saying when the number is divided by this, is the remainder 0. This is really the modulus, but that's one way to think about it. 3 is not a factor. And then you say, well, sure, 4 is a factor. And the reason why you only have to test those is because you know each of those have a corresponding pair. 1 times 16 is 16. 2 times 8 is 16. 4 squared is 16. And so when we return the number of factors, we say, look, if the number was a perfect square, that's all we're doing here. If the number divided by the rounded square root is equal to the square root, so this is saying that you are a perfect square. Then the number of factors are going to be the number of factors you counted here. So in this case, you counted 1, 2, 3. Multiply it by 2 minus 1. So you're going to have 3 times 2 is 6. You're going to have 5 factors. And we see that here. You have 1, 2, 3, 4, 5. If you're not a perfect square, and that's this case right over here, just double the number. So that means everyone's going to have a corresponding pair. Now let's go a little bit lower. So this just sets the background. Once again, you can play with that a little bit. And then this is where the real meat of the program happens. So this entire for loop is the real meat of the program, where we start drawing and filling in our array. And what it does is it goes, well, it says, well, how many total cells am I going to have? Well, it's going to be the x cells times the y cells. Give me the total number of cells. So starting with my number equals 1 all the way to my total number of cells. So first calculate how many factors. So we're using that numFactors function that we wrote. And then for the corresponding cell in the array, and we initialized the cell as the center cell, we did that up here, car cell x and car cell y. So here we initialize it as the center cell. So right when we start, we are starting at the center. This was defined outside of the for loop. We're setting that cell in our array to say the number of factors. And in this case, for the first time we go through it, it's just going to be a 1. This part right over here, you don't have to have this, but this keeps us if we zoom out a lot from drawing the boundaries on the circle. It's just an aesthetics thing. Then all of this code right over here is really the code that determines how we draw a circle. Do we draw a bigger circle if there are fewer factors, smaller circle? How do we color in the circle and all the rest? And then down here is the real meat for how do we actually traverse this grid to make it a spiral. So let's think about this a little bit, because it is interesting. Let's say that we just had a 3 by 3 array. We're going to start with our car cell x and car cell y pointing right over here. And we're going to say, well, our current number is 1. We're going to say the number of factors of 1 is just 1. And we're just going to fill that in our array. And then we'll actually draw the corresponding circle as well. So we might draw the corresponding circle on our canvas then. So that's our circle right over there. And then we have to think about what direction we want to go to. Our initial direction started with x equals or the x increment 1 and the y increment 0. So we fall into this conditional initially. But we essentially say, is the cell above it? So this is just saying, is the cell above it empty? This is just saying, is it not? So if this returns false, then putting this exclamation bark will say it returns true. So this is another way of saying if the cell above it is not empty, change your direction to up. So now our direction is going to be up. We're not going to do any of this other stuff. And then we're going to increment our x and y in the up direction. So now we're going to go in the up direction. We're going to evaluate number of factors for 2. 2 has 2 factors. Then we go over and we'll draw the corresponding circle. We'll draw the corresponding circle just like that. That's what we do right over here with this ellipse. And then we decide, OK, right now we are going up. So our yder is negative 1 and our extra 0. So this is the condition that holds 2 up for us. And we say, well, if the left cell is empty, then start moving left. So make extra negative 1 yder 0. So then we move to the left and we increment accordingly. And so now we go through the for loop again. We're at this point. Our number is now 3. We say, how many factors does 3 have? Well, 3 has 2 factors. We draw the corresponding circle. We draw the corresponding circle. And then we say, well, we're going to go down. And you keep going down. You do it for 4, 4, 5. Every time you check if the cell to your right is empty. So if you're going down, you keep checking to see if the cell to your right is empty. If it's not empty, you keep going down. If it is empty, then you start going to the right. So here, over here, you check to the right. Oh, that cell is not empty. Then you go down. Cell to the right is not empty. You go down. Cell to the right is empty. Now we change our direction. We change our direction to right over here. And we keep going to the right. We keep checking if the cell above us is empty. Well, it's not empty. So we move right again. Cell above us is empty now. Now we move up. And so that's what all of this business is doing. So hopefully, that gives you an overview of how this program works. I encourage you to play with it, experiment with it. And this is really a foundation that you can start to do all sorts of visualizations based on number properties.
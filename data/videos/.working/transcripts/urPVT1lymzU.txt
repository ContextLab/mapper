If you haven't tried already to write your own recursive Fibonacci function, I really encourage you to do so, or at least to try to do so. Give it a serious attempt before you watch this video. But if you have done that, or if you're feeling lazy, I guess you can watch this video. And so we're going to try to write a recursive Fibonacci function according to the specs that I laid out when I first set out the challenge to write a Fibonacci function. So I'll call this Fibonacci again. Fibonacci. And it has a parameter here n. So someone will have to pass an argument to it to say which term do we want of the Fibonacci sequence. But here we're going to do it recursively. What we're going to see is that it's actually very intuitive to write a Fibonacci function recursively. It's almost like magic. And later we'll see, though, it's not necessarily the most efficient way to write a Fibonacci function. So what I'm going to do is whenever you write any recursive program, you really need to think about the base cases really well. The base cases of the Fibonacci sequence, there's actually two base cases. There's the 0-th term and the first term. And those are really given by definition. So let's just say if we want the 0-th term. So if n is equal to 0, well, that means you want the 0-th term and the 0-th term is actually 0. And you could say, else if n is equal to 1, then you can return 1. Because the 0-th term is 0, the first term in the Fibonacci sequence is 1. And now here's where a little bit of the magic happens. Otherwise, return, and this is really cool here, return the Fibonacci of n minus 1. So whatever the previous term in the Fibonacci sequence is, plus Fibonacci of n minus 2. And I think this should work. And that's why it seems magical. Because all we're saying, hey, look, if you want the 0-th term, it's 0. If you want the first term, it's 1. Let me put some spaces here. If you want the first term, it is 1. If you want any other term, so else, if you want, and this is else if, but else, if neither of these are true, if it's neither 0 nor 1, if it's some other number, it's going to be, and we're going to assume that you're inputting some non-negative integer over here, right over here. This would break down if you did something non-negative integer over the non-negative term. But assuming you have a non-negative integer, then you say, look, if it's not the 0-th term or the first term, then just take the Fibonacci of whatever 1 term less than it is, plus 2 terms less than that. And you could try it out. For example, let's say you took Fibonacci of 2. Or then n is not 0, so you won't do this. n is not 1, so you won't do this. So you'll say return Fibonacci of 2 minus 1, so that's Fibonacci of 1, plus Fibonacci of 2 minus 2, plus Fibonacci of 0. Well, we know Fibonacci of 1 evaluates to 1, and Fibonacci of 0 evaluates to 0, so it'll be 1 plus 0, or just 1. And you could keep going. Try Fibonacci of 3. It'll work, because we know Fibonacci of 0, 1, or 2 works, because Fibonacci of 3 will boil down to Fibonacci of 2 plus Fibonacci of 1. We know that Fibonacci of 2 is 1. Fibonacci of 1 is 1, so it'll be 1 plus 1 is 2. So it'll just keep working. And we could try it out. Let's just save this. Actually, we didn't save the file name. Let me call it recursive Fibonacci. Recursive Fibonacci. Recursive Fibonacci. It's a .py file. And now let me actually run the program. And all this does is define the function in my environment. And then I'd actually have to call the function. So let me just run it. And let me ask for Fibonacci of 4. It gave me the right answer. Fibonacci of 10. 55, right answer. Fibonacci of 0. The 0 term is 0. So it all works out. So that's why recursion is kind of magical. And if you wanted to simplify this anymore, you might recognize, hey, the 0 term of the Fibonacci sequence is 0. The first term of the Fibonacci sequence is 1. So really, if you're looking for the 0 or the first term, it's really the same thing as that number. So you could actually maybe simplify this a little bit. If you assume that someone's going to input a non-negative integer over here, you could say something like if n is equal to 0 or n is equal to 1, return n. Let's see if this works. So this simplified our code up a little bit. So let's try to save this. And now let's run it. And now let's try Fibonacci of 10. It still worked. Because really, the 0 term is 0, and the first term is 1. So it works there. Or you could even simplify more if n is less than 2. That should also work. Because then if it's 0 or 1, you're going to return n. And otherwise, you're going to do all of this business. So let's try that out. So we ran it. And let's try Fibonacci of 10. Now, it seems like the computer is able to do this really quickly and all of that and all the rest of it. But if you really want to see all of the work that's being done, all of the calls to Fibonacci, what you can do is let's put a print in here. So that every time Fibonacci gets called, it prints Fibonacci, Fibonacci. It prints the text Fibonacci colon. And then I'm going to add to that string, to that string of text, what the argument is. So the argument in this is going to be n. And I want to make sure that it is viewed as a string. So I'm casting it to a string. That's essentially just taking an integer and making sure it's a string. And then when I add it to this string, it'll make it one big string. But let's see what this does. And I'm going to try it out with lower values first. So the function is defined. So let me write Fibonacci. I can just, let me do Fibonacci of 3. So notice, when it called, it called Fibonacci of 3. Then to do Fibonacci of 3, it had to call Fibonacci of 2 and Fibonacci of 1. And then to do Fibonacci of 2, it had to call Fibonacci of 0 and Fibonacci of 1. So it had to do all of these calls to Fibonacci just to calculate the Fibonacci of 3. And then eventually, it gave you the answer. If you did Fibonacci of 10, it's going to go really crazy. So I'm not even going to do that. Let me just do Fibonacci of 6. And you're going to see how many calls to Fibonacci it had to do. So it had to do all of these calls to Fibonacci. So it was actually a very computationally intensive thing to do. But the computers are super fast, so you don't even notice it. But in the future, we'll talk a little bit more. How do we think about how computationally intensive different ways of implementing a function can be?
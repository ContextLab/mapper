Cryptographic hash functions are basically fundamental building blocks that are used within many cryptographic algorithms and protocols. And they have a number of very important applications in the context of information security as a whole. Now some of the more common algorithms in this category that are known as cryptographic hash functions include things like MD5 and also it has some predecessors like MD4 and others as well as algorithms like SHA256 and actually SHA256 is preceded by other algorithms like SHA1 and so on. And also there are some algorithms that maybe you've heard of or maybe that are a bit lesser known but things like RIPE-MD and BLAKE and SKYNE and others. Now cryptographic hash functions are basically used as critical building blocks in many applications and really the first motivating application, the first historical application of these types of hash functions was in the context of what's known as a digital signature. Digital signatures are used in so many different cryptographic applications today. They're the cornerstone of many e-commerce protocols. They are used in doing things like Bitcoin generation and so on. Cryptographic hash functions are also used in things like message authentication protocols, in pseudo random number generation and password security, even encryption to some degree. And in fact aside from their use in digital signatures, these hash functions are also used in other places in the Bitcoin protocol as well. So first of all let me talk about what a cryptographic hash function actually is and of course as the name implies the first thing is it's a hash function. And by hash function I basically mean that it will take input, it's a mathematical function, a transformation if you will, that takes a particular input and we call this input a message. The message can be of arbitrary length and the hash function basically applies a mathematical transformation, maybe a set of mathematical transformations to this input to produce a single output. And we typically call this output a digest although sometimes you will see the output referred to as a tag or as a hash or as a fingerprint but digest is sort of the most common nomenclature. In fact MD5 which was one of the one of the earlier hash function stands for message digest 5. And MD4 is message digest 4 and so on and so forth. Now the message as I mentioned briefly can be of arbitrary size. It can be as long as you want or as short as you want but the output, the size of the digest or the size of the tag is going to be fixed in length. And for example in the context of a hash function like let's say SHA-256 the digest will actually be exactly 256 bits in length. So it's going to have a fixed length output but an arbitrary length input. And the other thing I want to point out about these cryptographic hash functions is that the function here is a deterministic function and by that I mean that the output will always be the same for a given input. So if you have a given input you're going to see the exact same output. You won't have a situation in which maybe a given input will have two different possible outputs. It's going to be consistent. Now traditional hash functions that have been used in computer science for quite some time and they are used in many computing applications. So for example you may have heard of something like a hash function used in something called a hash table. But the kinds of hash functions that are used in hash tables and I want to stress this they aren't necessarily the same as cryptographic hash functions. The qualifier cryptographic here is very very important and it usually means or implies that that hash function has to have a certain set of critical design goals and maybe some particular properties in mind that make it suitable for use in applications that use cryptography or cryptographic applications areas where perhaps security or privacy or confidentiality or authentication is a serious concern. So first and foremost and maybe in describing some of these properties is that and maybe this almost goes without saying one of the first properties you want of a cryptographic hash function is that it should be computationally efficient. And by that I mean that it shouldn't take a lot of time to compute the output from a given input. If you're given a message and you want to apply this set of transformations to that message to get a digest that set of transformation should not take a long time to implement on a computer. It should be very fast or relatively fast. And it almost goes without saying but I think it is important to stress and point it out because I've seen people come up with grossly inefficient hash function sometimes and those would not be considered suitable in the context of one typical cryptographic hash function they're used for cryptographic applications. Now the second property you typically need in the context and this is especially in the context of digital signing is that you want it to be the case that it's hard to find two inputs that actually map to the same output and I mean two distinct inputs whose corresponding digest is identical. And this property is typically referred to as collision resistance. That means it's hard to find a colliding pair of inputs. In other words if you have two inputs and let's say you have some message M1 and you have a message M2, their output under the application of the hash function should not be the same. You won't ever have it be the same. You won't ever have it be the case rather that the output of M1 and M2 under an application of the hash function is the same. They should never be the same. It should always be different. Now I should take a step back here and point out that of course in practice given that messages can be of arbitrary size and given that the input or the output rather is a fixed size it's not mathematically possible to guarantee that the output will always be different for two distinct messages. But what you typically want is not that the outputs are necessarily different but that it's hard to find two distinct messages that produce the same output. We know that they exist by virtue of the fact that there are many messages that can be hash and only a finite and small number or relatively small number compared to the number of messages, a smaller number of possible digest values. But aside from from that consideration it should be hard. It should take a long time and by long I mean an astronomically long time to find two distinct messages that would result in the same output under the application of the hash function. Now the third thing I want to point out is that in many cases you might want also in the context of a hash function for the hash function to be able to hide information about the inputs. In other words given the output it should be hard to glean anything useful or interesting about the input. Anything any relevant detail and I don't just mean the whole input but maybe even something as simple as you know was the input an even number or odd number. I mean that should be the kind of thing that should be hard to infer when you see the output even something as simple as the evenness or oddness of the input. Now a fourth property I want to point out is that you typically want the output to be well distributed. In other words the output should look random. In other words it should look like a set of coin flips took place not that there was a predictable way in which the output was created. Really what that means is that and you can think of it maybe more conceptually as it's almost as if you flipped a bunch of coins to get to the output it should look just that random. So what you can really think of cryptographic hash functions as is perhaps maybe the mathematical equivalent or mathematical analog of a meat grinder. It can take inputs and apply these mathematical transformations to them such that the output looks for all intents and purposes completely random and unrelated to the original input. I do want to make a few quick remarks about these particular properties and first of all they are interrelated. For example if you have a situation where the outputs let's say really appear to bear no relationship to the input and the outputs also look random then that will in fact give you to a large degree a lot of the collision resistance properties because just the fact that you can't predict the output and the fact that it hides all this information implies that it's going to be hard to find two inputs that are distinct that map to the same output and so sometimes you get one property in exchange for the others. The second thing I want to point out is that typically these properties in practice or maybe even in the underlying mathematics are things that you hope for but you can't always guarantee that they'll always hold and it may be entirely possible that you could design a hash function that you think is completely collision resistant but someone might come along a year from now and come up with a more clever way for finding a collision maybe they'll find a clever shortcut that does not involve doing a brute force search of any sort. It turns out that cryptographers for better or worse currently do not have any mathematical techniques they haven't developed techniques for being able to work around some of these limitations and so we often do take it on face value that these schemes are secure based on how long they've been around. I also want to point out and the last thing I want to point out is that this treatment that I've given is not meant to be mathematically rigorous by any stretch of the imagination. There are far more precise ways to describe these underlying properties but my hope instead is that this video gives you maybe a bit of a flavor for what is required of a cryptographic hash function without maybe getting bogged down in some of the mathematical minutia and formalism.
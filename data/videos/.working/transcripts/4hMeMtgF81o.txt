Let's design a program with lists, the accumulator pattern, and string methods. We've collected flight data from several different airports. We want to do some analysis here to understand if there's any patterns in a particular airport's delays, and maybe to see which airline is the biggest offender. Before we try processing it, let's understand our data format. Here we have a table of past flights. For each flight, we have the date, the airline, the flight number, and a bunch of delay fields. The delays are all represented in minutes. For now, we're mostly interested in departure delays. That is, how long after the scheduled time the flight took off. When we download this data, the computer puts it in CSV format, where the columns of each row are separated by commas. I did some quick work to get that data into my Python program, and now I have a list of CSV strings. Each element represents a row of the table. To start, let's create a new module to hold all of my analysis functions. I think I want to calculate the average delay time per airline. So I probably want a function that takes in the name of an airline, our flight data, and returns out the average delay for that airline in minutes. To make this easy, I can just accumulate a list of all of that airline's delays. The average then is just the sum of that list divided by the length of that list. Remember that each element of flights is a CSV string, so I need to parse that string to get the airline and delay info. To get a list of all the fields, I can split my string based on the comma separator. And if I check my data format real quick, I can see that the airline is in the second column. So that'll be index 1. If the airline doesn't match, we skip it. Otherwise, we need to know the flight delay. The departure delay field is going to be index 0, 1, 2, 3, 4. So I extract that field and append it to my list. Let's go back to the main file and test it. We import both our modules and then pass the flight data into our get average function. For now, we'll just pick a test airline, let's say Delta. Whoop, that's a type error. The stack trace says it's coming from the return statement in my get average function. Weird. Let's print the state of my list right before that line. OK, these are strings, not integers. And also weird that there are some negative numbers in here. But one thing at a time, the type error is definitely coming from the string thing. So if we want all these values to be integers, we should cast them before we append them to the list. Great. Now, where are those negative numbers coming from? It looks like our data does have some negative numbers in the departure delay column. My guess is that maybe this means that the flight left early. But if I'm talking about delays, I don't care if the flight left early. I don't want negative numbers to be skewing my delay average. So I think I want to treat those as zeros. If the flight left early, there was no delay. All right, we have this working for one airline, but I want to compare the delays for all airlines. How do I know which airlines to check? Well, I'm going to run this analysis on data from a bunch of different airports. And the airlines that fly out of each airport are different. So the best source of truth is the data itself. Let's write a function that iterates over the flight data and collects a list of unique airline names. So we start with an empty list. We accumulate inside the loop. And we return the final list at the end. OK, and on each iteration, we extract the airline name, which we know is at index 1, and then we append it to the list. But this is just a list of each row's airline. We want a list of the unique airlines that fly out of a given airport. So if an airline already exists in the list, we don't want to append it again. Better, but not best. It looks like maybe our data has some different capitalizations of airline names. So they're getting counted as separate airlines. Now, we could just convert all the airlines to the same case inside the find airlines function. But the get average function is also using the airline name. So it must be affected by the same issue. Instead of forcing every analysis function to recognize and handle this data inconsistency, we can use a step called preprocessing. This normalizes our data once up front. So the rest of our code doesn't have to think about it. We'll create a new module for this, since this is a different class of functionality. We iterate through each flight, normalize it, and append it back. To normalize, I'm going to convert every airline name to all uppercase. Now, one other thing. We also had all those negative delays that we converted to zero inside the get average function. Now, I think for all calculations I'm going to do, I don't care about early departures. So I'm going to move that zero conversion out to the preprocessing step too. That way, no one else has to worry about it. We call this pattern separation of concerns, because each piece of code can focus on a single task. Our analysis shows that JetBlue has the worst average delay at this airport. To continue on, we can analyze the delays at other airports, or maybe add a function to learn more about delay causes.
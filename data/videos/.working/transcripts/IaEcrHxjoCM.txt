Say your program manages a bunch of related data, like a user's favorite songs. You start by creating a variable for each song name, but that quickly gets out of hand. You might have five songs, then 100 songs, then 1000. How can you keep track of all those variable names? This calls for our first data structure, lists. A list allows us to store a bunch of data in a single container, which we can then refer to with a single variable name. To define a new list in Python, we use square brackets. This creates an empty list named songs. Then we can just stick data in here, separating each individual piece of data or element with a comma. Here, our elements are strings, but lists can hold values of any data type. They can also hold duplicate elements, so this song can appear in the list twice. In Python, a list can even hold values of different data types. Lists store data in an ordered sequence, which means the ordering of the data in the list matters. This list and this list are not equivalent. Even though the data is the same, it's in a different order. Okay, we've organized the data into a nice container, but what if I want to access the individual songs? Remember when I said the order is relevant? We refer to the individual elements based on their position in the list. This is the first element, the second element, the third element, and the fourth, or last element. But in computer land, instead of starting our count at one, we start counting at zero. We call these positions list indices. So the element espresso is at index zero, this is at index one, index two, and index three. The syntax for accessing an element at a specific index also uses square brackets. We take the variable name of the list, square bracket, index, square bracket. So this accesses the element at index zero. Back to our program. If I access an index that doesn't exist, then I get an index error, which is a type of runtime error. This list only has four elements. So if I try to access the element at index seven, there is none. So the computer rightfully throws up its hands and says, I don't know. To protect against this, we can always compare an index to the number of elements in the list. If we remember our built in length function, which we use with strings, we can also take the length of a list, which just returns the number of elements. So the length of this list is four. Since we start counting indices at zero, however, that means the last element of a list is at the index length of the list minus one, in this case, three. So if we want to know if an index is valid, we just need to check if it's between zero and the length of the list minus one inclusive. Okay, what about replacing values? A list is what we call a mutable data structure, which means we can modify it after it's been defined. We can update the value at a specific index using an assignment statement. On the left hand side of the equal sign, we put the name of the list, square brackets and the index we want to mutate. Just like any other assignment statement, on the right hand side, we put the value we want to store. And we can also write a self referencing assignment statement where we grab the current value, modify it and store it back in the same location, which we can also write with our plus equal syntax shortcut. Either way we write it, we can see that we modified the element at index three, we concatenated those exclamation marks. To review, we can use a list to store multiple values in a defined order. We access values based on their position or index, which we start counting at zero, we can get the number of elements in a list using the built in length function, where the last element of a list is at the index length of the list minus one. And if we access an index beyond that, we get an index error.
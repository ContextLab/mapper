You're writing a program, and it's starting to get pretty long. Plus, you're duplicating a lot of code, because you need to perform the same task at several different points in the program. How can we better keep this code organized and reduce the repetition? We need functions. A function is a named block of code that performs a specific task. There's really not too much special here. It's just normal lines of code that we've packaged up and attached a name to. Like a variable gives a name to a value, a function gives a name to a set of instructions. We define the function once, and then that name lets us execute the task over and over again, without having to rewrite all those lines of code every time. Typically, a function takes in some number of input values. It operates on them in some way, and then it returns out an output value. The input values allow us to generalize the function's task, so it can round any number to any number of decimal points, or drink a potion of any color. Each time we call the function, we can pass in different input values. The function call expression then evaluates down to whatever output value the function returns. To define a new function, we use a function definition. A function definition starts with the keyword def, which stands for define. Then we put the name of our function, followed by a set of parentheses. And then, like most things in Python, we end it with a colon. We call this whole line the function header. Now we're just missing the input values. We need to specify how many input values the function takes, and give each of them a name. We then put those names inside the parentheses. These are called the parameters to our function. Parameters are effectively just variables, but those variables are only accessible within the function body. The function body is all the lines of code that perform the function's task. These can include any normal lines of code, like variable assignments, conditionals, or loops. To tell the computer that these lines of code belong to the function body, we indent them one tab over from the function header. Typically, at the end of the function body, we specify the output value that the function returns. To do this, we use the keyword return. Whatever value we put after it will be the output value. Our function definition is now complete, but a function definition just defines how to perform a task. To actually perform that task, we still need to call the function. Because the computer needs to learn the task before it can do the task, a function definition needs to appear in the program before any of its function calls. To call a function, we use its name and a set of parentheses. Inside the parentheses, we pass in any input values, which we call arguments. To execute a function call, the computer jumps back to the function definition. It plugs in the input values by binding the arguments to the corresponding parameters. This is effectively the same as a variable assignment, so we're assigning the value pink to the variable color. Then the computer executes the function body. When it reaches the return statement, it'll exit out of the function body and jump back to the line of code where the function call occurred. The function returns out whatever value appeared after that return, so this function call evaluates down to the value 4. And then we can call the function again and again with different arguments. Let's take another look at our original program. I can see that we're building some kind of adventure game, and the player has some number of potion items in their inventory. Then within the game, the player can choose to drink a potion at any point in time. Instead of duplicating this potion conditional all over the program, it's much easier if we refactor it into a function. We've already written this function definition. It's called drinkPotion, it takes in the color of the potion as a parameter, and it returns out the number of affected health points. This means we can replace all these potion conditionals with calls to the drinkPotion function, and we'll pass in as an argument the potion that the user selected. The more we break down our programs into functions, the easier they are to read and maintain. For example, if I want to add a blue potion, I only need to modify this one function definition. Before, I would have had to find every duplicated potion conditional in the entire program and update all of them to include a blue potion. But now, every time I drink a potion, I just call this function. So if I just make a quick change here, the entire game now supports blue potions. Plus, now that I've built this function, I don't ever have to think about how potions work again. As I continue building out my game, anytime I need to deal with potions, I can just call the drinkPotion function without having to really understand what the code does. In this way, functions let us solve the problem once and move on, which is super convenient when solving big problems.
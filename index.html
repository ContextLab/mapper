<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Knowledge Map Demo - Heatmap Visualization</title>
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- KaTeX for LaTeX rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #00693E 0%, #004d2c 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            width: 100%;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 80px rgba(0, 0, 0, 0.5);
            border: 3px solid rgba(255, 255, 255, 0.2);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #00693E 0%, #004d2c 100%);
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
        }

        .header h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .btn-about {
            position: absolute;
            top: 30px;
            right: 30px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-about:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-2px);
        }

        .btn-about i {
            font-size: 1.1em;
        }

        .content {
            padding: 40px;
        }

        .question-section {
            margin-bottom: 30px;
        }

        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .question-number {
            font-size: 0.9em;
            color: #00693E;
            font-weight: 600;
            display: none; /* Hidden per issue #4 */
        }

        .confidence-display {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border: 2px solid #00693E;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .confidence-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .confidence-label {
            font-size: 0.95em;
            font-weight: 600;
            color: #333;
        }

        .confidence-value {
            font-size: 1.1em;
            font-weight: 700;
            color: #00693E;
        }

        /* Stacked level bars container */
        .level-bars-container {
            position: relative;
            margin-bottom: 28px;
        }

        .level-bar-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }

        .level-label {
            font-size: 0.75em;
            font-weight: 600;
            color: #555;
            min-width: 24px;
        }

        .level-percent {
            font-size: 0.75em;
            font-weight: 600;
            color: #555;
            min-width: 35px;
            text-align: right;
        }

        .confidence-bar {
            height: 8px;
            background: #dee2e6;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            flex: 1;
        }

        .confidence-fill {
            height: 100%;
            width: 0%;
            transition: width 0.5s ease;
        }

        /* Level-specific colors (reverse gradient: bronze at L4 to green at L0) */
        .level-bar-row[data-level="4"] .confidence-fill {
            background: linear-gradient(90deg, #8B4513 0%, #A0522D 100%); /* Bronze */
        }

        .level-bar-row[data-level="3"] .confidence-fill {
            background: linear-gradient(90deg, #B8860B 0%, #DAA520 100%); /* Goldenrod */
        }

        .level-bar-row[data-level="2"] .confidence-fill {
            background: linear-gradient(90deg, #D4AF37 0%, #FFD700 100%); /* Gold */
        }

        .level-bar-row[data-level="1"] .confidence-fill {
            background: linear-gradient(90deg, #85BB65 0%, #9ACD32 100%); /* Yellow-Green */
        }

        .level-bar-row[data-level="0"] .confidence-fill {
            background: linear-gradient(90deg, #00693E 0%, #00a859 100%); /* Dartmouth Green */
        }

        /* Shared coverage threshold line */
        .coverage-threshold {
            position: absolute;
            /* Calculate position: label (24px) + gap (8px) + 90% of the bar width
               Bar width = 100% - (24px + 8px + 35px + 8px) = 100% - 75px */
            left: calc(32px + (100% - 75px) * 0.90);
            top: 0;
            bottom: 0;
            width: 2px;
            background: #333;
            z-index: 10;
            pointer-events: none;
        }

        .coverage-threshold::after {
            content: 'Target Coverage';
            position: absolute;
            bottom: -22px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75em;
            color: #333;
            white-space: nowrap;
            font-weight: 600;
        }

        .confidence-message {
            font-size: 0.85em;
            color: #666;
            margin: 0;
            text-align: center;
            display: none; /* Hidden per issue #5 */
        }

        .question-text {
            font-size: 1.3em;
            color: #333;
            margin-bottom: 25px;
            line-height: 1.6;
        }

        .options {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .option {
            padding: 18px 24px;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.05em;
            display: flex;
            align-items: center;
        }

        .option:hover {
            border-color: #00693E;
            background: #e8f5f1;
            transform: translateX(5px);
        }

        .option.selected {
            border-color: #00693E;
            background: #e8f5f1;
        }

        .option-label {
            display: inline-block;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: #00693E;
            color: white;
            text-align: center;
            line-height: 30px;
            margin-right: 15px;
            font-weight: 600;
            flex-shrink: 0;
        }

        .button-container {
            display: flex;
            gap: 15px;
            margin-top: 30px;
        }

        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 1.05em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            flex: 1;
        }

        .btn-primary {
            background: #dee2e6;
            color: #333;
        }

        .btn-primary:hover:not(:disabled) {
            background: #00693E;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 105, 62, 0.4);
            animation: none; /* Stop pulsing on hover */
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #dee2e6;
            color: #333;
        }

        .btn-secondary:hover {
            background: #ced4da;
        }

        .btn-info {
            background: #dee2e6;
            color: #333;
        }

        .btn-info:hover:not(:disabled) {
            background: #00693E;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 105, 62, 0.4);
            animation: none; /* Stop pulsing on hover */
        }

        .btn-info:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Pulse animation for high-confidence button */
        @keyframes pulse-green-bg {
            0%, 100% {
                background-color: #dee2e6;
                box-shadow: 0 3px 10px rgba(108, 117, 125, 0.2);
            }
            50% {
                background-color: #00693E;
                box-shadow: 0 3px 10px rgba(0, 105, 62, 0.3);
            }
        }

        @keyframes pulse-green-text {
            0%, 100% {
                color: #333;
            }
            50% {
                color: white;
            }
        }

        .btn-info.high-confidence {
            animation: pulse-green-bg 6s ease-in-out infinite, pulse-green-text 6s ease-in-out infinite;
        }

        /* Apply same pulsing to Start Quiz button */
        .btn-primary:not(:disabled) {
            animation: pulse-green-bg 6s ease-in-out infinite, pulse-green-text 6s ease-in-out infinite;
        }

        .btn-info.high-confidence:hover:not(:disabled) {
            background: #00693E;
            color: white;
            box-shadow: 0 5px 15px rgba(0, 105, 62, 0.4);
            animation: none; /* Stop pulsing on hover */
        }

        .btn-skip {
            background: #dee2e6;
            color: #333;
            font-weight: 600;
        }

        .btn-skip:hover {
            background: #ced4da;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(108, 117, 125, 0.3);
        }

        .map-container {
            width: 100%;
            height: 700px;
            background: #f8f9fa;
            border-radius: 12px;
            position: relative;
            overflow: hidden;
        }

        .map-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .map-header h2 {
            font-size: 1.8em;
            color: #333;
            margin-bottom: 10px;
        }

        .map-header p {
            color: #666;
            font-size: 1.05em;
        }

        #map-canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 10;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #00693E;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 12px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: 700;
            color: #00693E;
        }

        .stat-label {
            color: #666;
            margin-top: 5px;
        }

        .hidden {
            display: none;
        }


        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.8);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            font-size: 0.9em;
            z-index: 5;
            cursor: move;
            user-select: none;
            transition: box-shadow 0.2s ease;
        }

        .legend:hover {
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        .legend.dragging {
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.3);
            cursor: grabbing;
        }

        .legend h4 {
            margin-bottom: 10px;
            color: #333;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .legend-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-right: 8px;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .colorbar {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.8);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 5;
            cursor: move;
            user-select: none;
            transition: box-shadow 0.2s ease;
        }

        .colorbar:hover {
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        .colorbar.dragging {
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.3);
            cursor: grabbing;
        }

        .colorbar h4 {
            margin-bottom: 8px;
            font-size: 0.9em;
            color: #333;
        }

        .colorbar-gradient {
            width: 200px;
            height: 20px;
            background: linear-gradient(to right,
                rgba(139, 69, 19, 0.8),
                rgba(184, 134, 11, 0.8),
                rgba(218, 165, 32, 0.8),
                rgba(0, 133, 66, 0.8),
                rgba(0, 105, 62, 0.8)
            );
            border-radius: 4px;
        }

        .colorbar-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.8em;
            color: #666;
            margin-top: 5px;
        }

        .tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 0.9em;
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            opacity: 0;
            transition: opacity 200ms ease-in-out;
        }

        .tooltip.visible {
            opacity: 1;
        }

        .tooltip-hidden {
            display: none;
        }

        .tooltip-question {
            font-weight: 600;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
        }

        .tooltip-status {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tooltip-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        @media (max-width: 768px) {
            .content {
                padding: 20px;
            }

            .header h1 {
                font-size: 1.5em;
            }

            .question-text {
                font-size: 1.1em;
            }

            .map-container {
                height: 400px;
            }

            .stats {
                flex-direction: column;
                gap: 20px;
            }

            .legend, .colorbar {
                font-size: 0.8em;
                padding: 10px;
            }

            .colorbar-gradient {
                width: 150px;
            }
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Introduction Screen */
        .intro-section {
            text-align: center;
            padding: 60px 40px;
        }

        .intro-section h1 {
            font-size: 2.5em;
            color: #00693E;
            margin-bottom: 20px;
        }

        .intro-description {
            font-size: 1.2em;
            color: #666;
            line-height: 1.8;
            max-width: 700px;
            margin: 0 auto 40px;
        }

        .intro-instructions {
            max-width: 600px;
            margin: 0 auto 40px;
            text-align: left;
            background: #f8f9fa;
            padding: 30px;
            border-radius: 12px;
        }

        .intro-instructions h3 {
            font-size: 1.3em;
            color: #333;
            margin-bottom: 15px;
        }

        .intro-instructions ol {
            font-size: 1.1em;
            color: #666;
            line-height: 2;
            padding-left: 25px;
        }

        .intro-instructions li {
            margin-bottom: 10px;
        }

        /* About Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2000;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .modal.hidden {
            display: none !important;
        }

        .modal-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
        }

        .modal-content {
            position: relative;
            background: white;
            border-radius: 16px;
            max-width: 700px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            z-index: 2001;
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-30px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .modal-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: transparent;
            border: none;
            font-size: 1.5em;
            color: #999;
            cursor: pointer;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close:hover {
            background: #f0f0f0;
            color: #333;
        }

        .modal-content h2 {
            font-size: 2em;
            color: #00693E;
            margin-bottom: 30px;
        }

        .about-section {
            margin-bottom: 35px;
        }

        .about-section h3 {
            font-size: 1.4em;
            color: #333;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e0e0e0;
        }

        .about-link {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 15px;
            margin: 6px 0;
            border-radius: 8px;
            text-decoration: none;
            color: #333;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .about-link:hover {
            background: #f8f9fa;
            border-color: #00693E;
            transform: translateX(5px);
        }

        .link-logo {
            height: 24px;
            width: auto;
            flex-shrink: 0;
        }

        .citation {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            font-size: 0.95em;
            line-height: 1.8;
            color: #555;
            margin: 15px 0;
            position: relative;
        }

        .citation strong {
            color: #333;
        }

        .citation-text {
            margin-bottom: 15px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .copy-citation-btn {
            background: #00693E;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .copy-citation-btn:hover {
            background: #004d2c;
            transform: translateY(-1px);
        }

        .copy-citation-btn.copied {
            background: #28a745;
        }

        .note {
            font-size: 0.9em;
            color: #888;
            font-style: italic;
            margin-top: 10px;
        }

        /* Contact Form */
        .contact-form {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .form-group {
            margin-bottom: 18px;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 18px;
        }

        .form-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: 600;
            color: #333;
            font-size: 0.95em;
        }

        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 1em;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            transition: border-color 0.2s ease;
        }

        .form-group input:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #00693E;
        }

        .form-group textarea {
            resize: vertical;
            min-height: 120px;
        }

        .form-submit-btn {
            background: #00693E;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .form-submit-btn:hover {
            background: #004d2c;
            transform: translateY(-1px);
        }

        .form-submit-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .contact-info {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
            line-height: 1.8;
        }

        .contact-info p {
            margin: 4px 0;
            color: #555;
        }

        .contact-info strong {
            color: #00693E;
            display: block;
            margin-bottom: 8px;
            font-size: 1.05em;
        }

        .contact-info a {
            color: #00693E;
            text-decoration: none;
        }

        .contact-info a:hover {
            text-decoration: underline;
        }

        /* Responsive Adjustments */
        @media (max-width: 768px) {
            .btn-about {
                top: 20px;
                right: 20px;
                padding: 8px 16px;
                font-size: 0.9em;
            }

            .intro-section {
                padding: 40px 20px;
            }

            .intro-section h1 {
                font-size: 1.8em;
            }

            .intro-instructions {
                padding: 20px;
            }

            .modal-content {
                padding: 30px 20px;
                max-height: 90vh;
            }

            .modal-content h2 {
                font-size: 1.6em;
                margin-bottom: 20px;
            }

            .about-link {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }

            .link-logo {
                height: 20px;
            }

            .form-row {
                grid-template-columns: 1fr;
                gap: 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1><i class="fas fa-brain"></i> Knowledge Map Explorer</h1>
            <p>Answer questions to visualize your conceptual understanding</p>
            <button class="btn-about" id="about-btn">
                <i class="fas fa-info-circle"></i> About
            </button>
        </div>

        <div class="content">
            <!-- Introduction Section -->
            <div id="intro-section" class="intro-section">
                <h1>Welcome!</h1>
                <p class="intro-description">
                    This interactive demo maps out an approximation of your knowledge across all topics,
                    using Wikipedia as a reference and LLM text embeddings to define a coordinate system for the map.
                    Answer quiz questions to visualize your conceptual understanding in a 2D semantic space.
                </p>
                <div class="intro-instructions">
                    <h3>How it works:</h3>
                    <ol>
                        <li>Answer questions about various topics at your own pace</li>
                        <li>View your personalized 2D knowledge map</li>
                        <li>Explore areas of strength and opportunities to learn</li>
                    </ol>
                </div>
                <button class="btn btn-primary" id="start-quiz-btn">
                    Start Quiz <i class="fas fa-play"></i>
                </button>
            </div>

            <!-- Quiz Section -->
            <div id="quiz-section" class="quiz-section hidden">
                <div class="question-section fade-in" id="question-container">
                    <div class="question-header">
                        <span class="question-number" id="question-number">Question 1 of 10</span>
                    </div>

                    <!-- Confidence Display (for adaptive sampling) -->
                    <div class="confidence-display hidden" id="confidence-display">
                        <div class="confidence-header">
                            <span class="confidence-label">Coverage</span>
                        </div>
                        <!-- Stacked per-level coverage bars (Level 4 to Level 0) -->
                        <div class="level-bars-container">
                            <div class="level-bar-row" data-level="4">
                                <span class="level-label">L4</span>
                                <div class="confidence-bar">
                                    <div class="confidence-fill" id="confidence-fill-4"></div>
                                </div>
                                <span class="level-percent" id="level-percent-4">0%</span>
                            </div>
                            <div class="level-bar-row" data-level="3">
                                <span class="level-label">L3</span>
                                <div class="confidence-bar">
                                    <div class="confidence-fill" id="confidence-fill-3"></div>
                                </div>
                                <span class="level-percent" id="level-percent-3">0%</span>
                            </div>
                            <div class="level-bar-row" data-level="2">
                                <span class="level-label">L2</span>
                                <div class="confidence-bar">
                                    <div class="confidence-fill" id="confidence-fill-2"></div>
                                </div>
                                <span class="level-percent" id="level-percent-2">0%</span>
                            </div>
                            <div class="level-bar-row" data-level="1">
                                <span class="level-label">L1</span>
                                <div class="confidence-bar">
                                    <div class="confidence-fill" id="confidence-fill-1"></div>
                                </div>
                                <span class="level-percent" id="level-percent-1">0%</span>
                            </div>
                            <div class="level-bar-row" data-level="0">
                                <span class="level-label">L0</span>
                                <div class="confidence-bar">
                                    <div class="confidence-fill" id="confidence-fill-0"></div>
                                </div>
                                <span class="level-percent" id="level-percent-0">0%</span>
                            </div>
                            <!-- Shared threshold line across all levels -->
                            <div class="coverage-threshold"></div>
                        </div>
                        <p class="confidence-message" id="confidence-message">Answer more questions to build coverage...</p>
                    </div>

                    <div class="question-text" id="question-text"></div>
                    <div class="options" id="options-container"></div>
                </div>

                <div class="button-container">
                    <button class="btn btn-secondary hidden" id="prev-btn"><i class="fas fa-arrow-left"></i> Previous</button>
                    <button class="btn btn-skip" id="dont-know-btn"><i class="fas fa-question-circle"></i> I Don't Know</button>
                    <button class="btn btn-info" id="show-map-btn"><i class="fas fa-map"></i> Show Map</button>
                    <button class="btn btn-primary" id="next-btn" disabled>Next <i class="fas fa-arrow-right"></i></button>
                </div>
            </div>

            <!-- Map Section -->
            <div id="map-section" class="map-section hidden">
                <div class="map-header">
                    <h2>Your Knowledge Map</h2>
                    <p>Hover to explore your knowledge map</p>
                </div>

                <!-- Coverage Display (also shown on map when adaptive sampling is active) -->
                <div class="confidence-display hidden" id="map-confidence-display">
                    <div class="confidence-header">
                        <span class="confidence-label">Coverage</span>
                    </div>
                    <!-- Stacked per-level coverage bars (Level 4 to Level 0) -->
                    <div class="level-bars-container">
                        <div class="level-bar-row" data-level="4">
                            <span class="level-label">L4</span>
                            <div class="confidence-bar">
                                <div class="confidence-fill" id="map-confidence-fill-4"></div>
                            </div>
                            <span class="level-percent" id="map-level-percent-4">0%</span>
                        </div>
                        <div class="level-bar-row" data-level="3">
                            <span class="level-label">L3</span>
                            <div class="confidence-bar">
                                <div class="confidence-fill" id="map-confidence-fill-3"></div>
                            </div>
                            <span class="level-percent" id="map-level-percent-3">0%</span>
                        </div>
                        <div class="level-bar-row" data-level="2">
                            <span class="level-label">L2</span>
                            <div class="confidence-bar">
                                <div class="confidence-fill" id="map-confidence-fill-2"></div>
                            </div>
                            <span class="level-percent" id="map-level-percent-2">0%</span>
                        </div>
                        <div class="level-bar-row" data-level="1">
                            <span class="level-label">L1</span>
                            <div class="confidence-bar">
                                <div class="confidence-fill" id="map-confidence-fill-1"></div>
                            </div>
                            <span class="level-percent" id="map-level-percent-1">0%</span>
                        </div>
                        <div class="level-bar-row" data-level="0">
                            <span class="level-label">L0</span>
                            <div class="confidence-bar">
                                <div class="confidence-fill" id="map-confidence-fill-0"></div>
                            </div>
                            <span class="level-percent" id="map-level-percent-0">0%</span>
                        </div>
                        <!-- Shared threshold line across all levels -->
                        <div class="coverage-threshold"></div>
                    </div>
                    <p class="confidence-message" id="map-confidence-message">Answer more questions to build coverage...</p>
                </div>

                <div class="map-container">
                    <canvas id="map-canvas"></canvas>
                    
                    <div class="legend">
                        <h4>Legend</h4>
                        <div class="legend-item">
                            <div class="legend-dot" style="background: rgb(0, 105, 62);"></div>
                            <span>Correct response</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-dot" style="background: rgb(255, 193, 7);"></div>
                            <span>Skipped/Unsure</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-dot" style="background: rgb(139, 69, 19);"></div>
                            <span>Incorrect response</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-dot" style="background: rgba(0, 0, 0, 0.1); border: 1px solid rgba(0, 0, 0, 0.3); width: 6px; height: 6px; margin-left: 5px; margin-right: 13px;"></div>
                            <span>Wikipedia article</span>
                        </div>
                    </div>

                    <div class="colorbar">
                        <h4>Inferred Knowledge</h4>
                        <div class="colorbar-gradient"></div>
                        <div class="colorbar-labels">
                            <span>Low</span>
                            <span>High</span>
                        </div>
                    </div>

                    <div class="tooltip tooltip-hidden" id="tooltip"></div>
                    
                    <div class="loading hidden" id="loading">
                        <div class="spinner"></div>
                        <p>Generating your knowledge map...</p>
                    </div>
                </div>

                <!-- Hidden stats elements (kept for JavaScript compatibility) -->
                <div class="stats hidden">
                    <div class="stat-item">
                        <div class="stat-value" id="correct-count">0</div>
                        <div class="stat-label">Correct</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="accuracy-pct">0%</div>
                        <div class="stat-label">Accuracy</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="total-count">10</div>
                        <div class="stat-label">Total Questions</div>
                    </div>
                </div>

                <div class="button-container">
                    <button class="btn btn-primary" id="another-round-btn"><i class="fas fa-play"></i> Answer More Questions</button>
                    <button class="btn btn-secondary" id="restart-btn"><i class="fas fa-rotate-right"></i> Start Over</button>
                </div>
            </div>
        </div>
    </div>

    <!-- About Modal -->
    <div id="about-modal" class="modal hidden">
        <div class="modal-backdrop"></div>
        <div class="modal-content">
            <button class="modal-close" id="close-about" aria-label="Close">
                <i class="fas fa-times"></i>
            </button>

            <h2>About This Project</h2>

            <section class="about-section">
                <h3>Research Paper</h3>
                <a href="https://osf.io/preprints/psyarxiv/dh3q2_v2" target="_blank" rel="noopener noreferrer" class="about-link">
                    <img src="logos/nature.png" alt="Nature Communications logo" class="link-logo">
                    <span>Text embedding models yield high-resolution insights into conceptual knowledge</span>
                </a>
                <div class="citation">
                    <div class="citation-text" id="citation-text">
                        Fitzpatrick, P. C., Heusser, A. C., & Manning, J. R. (2025). Text embedding models yield high-resolution insights into conceptual knowledge from short multiple-choice quizzes. <em>Nature Communications</em>: In press.
                    </div>
                    <button class="copy-citation-btn" id="copy-citation-btn">
                        <i class="fas fa-copy"></i> Copy Citation
                    </button>
                </div>
                <p class="note">
                    Note: This paper is currently in press. The link above leads to the preprint version. Once published in Nature Communications, this link will be updated with the official DOI.
                </p>
            </section>

            <section class="about-section">
                <h3>Related Resources</h3>
                <a href="https://github.com/ContextLab/efficient-learning-khan" target="_blank" rel="noopener noreferrer" class="about-link">
                    <img src="logos/github.svg" alt="GitHub logo" class="link-logo">
                    <span>GitHub repository for this project</span>
                </a>
                <a href="https://www.nsf.gov/awardsearch/show-award/?AWD_ID=2145172&HistoricalAwards=false" target="_blank" rel="noopener noreferrer" class="about-link">
                    <img src="logos/nsf.png" alt="National Science Foundation logo" class="link-logo">
                    <span>Information about the NSF Award (#2145172) that supports this work</span>
                </a>
                <a href="https://context-lab.com" target="_blank" rel="noopener noreferrer" class="about-link">
                    <img src="logos/cdl.png" alt="Context Lab logo" class="link-logo">
                    <span>Learn more about the Contextual Dynamics Lab at Dartmouth College</span>
                </a>
            </section>

            <section class="about-section">
                <h3>Contact</h3>

                <div class="contact-info">
                    <strong><a href="https://context-lab.com" target="_blank" rel="noopener noreferrer">Contextual Dynamics Lab</a></strong>
                    <p>Department of Psychological and Brain Sciences</p>
                    <p>Dartmouth College</p>
                    <p>349 Moore Hall, HB 6207</p>
                    <p>Hanover, NH 03755</p>
                    <p style="margin-top: 12px;">
                        <a href="mailto:contextualdynamics@gmail.com">contextualdynamics@gmail.com</a><br>
                        <a href="tel:6036460070">603.646.0070</a>
                    </p>
                </div>

                <form class="contact-form" id="contact-form">
                    <div class="form-row">
                        <div class="form-group">
                            <label for="contact-first-name">First Name *</label>
                            <input type="text" id="contact-first-name" name="firstName" required>
                        </div>
                        <div class="form-group">
                            <label for="contact-last-name">Last Name *</label>
                            <input type="text" id="contact-last-name" name="lastName" required>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="contact-email">Email Address *</label>
                        <input type="email" id="contact-email" name="email" required>
                    </div>
                    <div class="form-group">
                        <label for="contact-subject">Subject *</label>
                        <input type="text" id="contact-subject" name="subject" required>
                    </div>
                    <div class="form-group">
                        <label for="contact-message">Message *</label>
                        <textarea id="contact-message" name="message" required></textarea>
                    </div>
                    <button type="submit" class="form-submit-btn">
                        <i class="fas fa-paper-plane"></i> Send Message
                    </button>
                </form>
            </section>
        </div>
    </div>

    <script>
        // Level-based scaling parameters
        // Note: Articles are much more visible now - minimum is 3x larger than before
        const ARTICLE_PARAMS = {
            0: { baseRadius: 1.5,  baseAlpha: 0.05, hoverAlpha: 0.5 },  // Most specific (smallest at this scale)
            1: { baseRadius: 2.25, baseAlpha: 0.06, hoverAlpha: 0.6 },
            2: { baseRadius: 3.0,  baseAlpha: 0.07, hoverAlpha: 0.7 },
            3: { baseRadius: 3.5,  baseAlpha: 0.08, hoverAlpha: 0.8 },
            4: { baseRadius: 4.0,  baseAlpha: 0.10, hoverAlpha: 1.0 }   // Most abstract (largest)
        };

        const QUESTION_PARAMS = {
            0: { radius: 8,  baseFontSize: 6 },   // Most specific (smallest)
            1: { radius: 10, baseFontSize: 8 },
            2: { radius: 12, baseFontSize: 10 },
            3: { radius: 14, baseFontSize: 12 },
            4: { radius: 16, baseFontSize: 14 }   // Most abstract (largest)
        };

        // Questions data loaded from external file
        let questionsData = []; // Current round's questions (10 questions)
        let allQuestionsPool = []; // All available questions loaded from JSON
        let cellLabelsData = null; // Cell labels for heatmap tooltips
        let wikipediaArticles = []; // Wikipedia articles with coordinates

        // Application state
        let currentQuestion = 0;
        let userResponses = []; // Current round responses
        let allUserResponses = []; // Full history across all rounds
        let allQuestionsShown = []; // All questions shown across all rounds (for cumulative map display)
        let askedQuestionIndices = []; // Track which questions have been asked
        let currentRound = 0; // Current round number
        let selectedOption = null;

        // Adaptive sampling state
        let cellDistances = null; // Precomputed distance matrix
        let adaptiveSampler = null; // AdaptiveSampler instance
        let cellQuestionsData = null; // Original cell-based questions structure

        // DOM elements
        const introSection = document.getElementById('intro-section');
        const quizSection = document.getElementById('quiz-section');
        const mapSection = document.getElementById('map-section');
        const questionContainer = document.getElementById('question-container');
        const questionNumber = document.getElementById('question-number');
        const questionText = document.getElementById('question-text');
        const optionsContainer = document.getElementById('options-container');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const dontKnowBtn = document.getElementById('dont-know-btn');
        const showMapBtn = document.getElementById('show-map-btn');
        const restartBtn = document.getElementById('restart-btn');
        const anotherRoundBtn = document.getElementById('another-round-btn');
        const startQuizBtn = document.getElementById('start-quiz-btn');
        const aboutBtn = document.getElementById('about-btn');
        const aboutModal = document.getElementById('about-modal');
        const closeAboutBtn = document.getElementById('close-about');
        const copyCitationBtn = document.getElementById('copy-citation-btn');
        const contactForm = document.getElementById('contact-form');
        const confidenceDisplay = document.getElementById('confidence-display');
        const confidenceValue = document.getElementById('confidence-value');
        const confidenceFill = document.getElementById('confidence-fill');
        const confidenceMessage = document.getElementById('confidence-message');
        const canvas = document.getElementById('map-canvas');
        const ctx = canvas.getContext('2d');
        const loading = document.getElementById('loading');
        const tooltip = document.getElementById('tooltip');

        // Hover state for animations
        let hoveredDotIndex = null;
        let hoveredHeatmapCell = null;
        let hoveredArticleIndex = null; // Wikipedia article hover state
        let dotAnimationProgress = {}; // Maps dot index to animation progress (0-1)
        let articleAnimationProgress = {}; // Maps article index to animation progress (0-1)
        let animationFrameId = null;
        let lastFrameTime = performance.now();

        // ====== AdaptiveSampler Class ======
        class AdaptiveSampler {
            constructor(questionsPool, distances, config) {
                this.questionsPool = questionsPool;
                this.distances = distances.distances;  // 2D array (not used in geometric sampling)
                this.cellKeys = distances.cell_keys;   // Array of "gx_gy" strings
                this.config = {
                    maxQuestions: 10,
                    // RBF sigma values per level (from knowledge estimation)
                    sigma: {
                        0: 0.01,   // Level 0: 1% of space
                        1: 0.05,   // Level 1: 5% of space
                        2: 0.075,  // Level 2: 7.5% of space
                        3: 0.10,   // Level 3: 10% of space
                        4: 0.15    // Level 4: 15% of space
                    },
                    // Coverage multiplier: transition when avg min distance < sigma * multiplier
                    coverageMultiplier: 2.0,
                    ...config  // Allow override
                };

                // Flatten all questions into a single pool with coordinates
                this.allQuestions = [];
                for (const cellData of this.questionsPool.cells) {
                    const cellKey = `${cellData.cell.gx}_${cellData.cell.gy}`;
                    for (let i = 0; i < cellData.questions.length; i++) {
                        const q = cellData.questions[i];
                        this.allQuestions.push({
                            ...q,
                            cellKey,
                            cellData,
                            questionId: `${cellKey}_${i}`,
                            index: this.allQuestions.length
                        });
                    }
                }

                // State
                this.askedQuestionIndices = [];  // Indices of asked questions
                this.pendingQuestionIndices = [];  // Indices of questions selected but not yet answered
                this.responses = {};  // questionIndex â†’ correctness value
                this.currentLevel = 4;  // Start with highest (broadest) level
                this.levelTransitions = []; // Track when we transition levels

                // Per-level tracking
                this.perLevelState = {
                    0: { askedIndices: [], pendingIndices: [], coverage: 0 },
                    1: { askedIndices: [], pendingIndices: [], coverage: 0 },
                    2: { askedIndices: [], pendingIndices: [], coverage: 0 },
                    3: { askedIndices: [], pendingIndices: [], coverage: 0 },
                    4: { askedIndices: [], pendingIndices: [], coverage: 0 }
                };

                // Coverage threshold (default 90%)
                this.coverageThreshold = 0.90;
            }

            // === Geometric Sampling Methods ===

            _getAvailableQuestions(level = null) {
                // Return questions from the specified level (or current level if not specified)
                const targetLevel = level !== null ? level : this.currentLevel;
                const available = [];

                for (const q of this.allQuestions) {
                    const questionLevel = q.level !== undefined ? q.level : 0;
                    // Only include questions that:
                    // 1. Haven't been asked (answered)
                    // 2. Haven't been selected for current round (pending)
                    // 3. Match the target level
                    if (!this.askedQuestionIndices.includes(q.index) &&
                        !this.pendingQuestionIndices.includes(q.index) &&
                        questionLevel === targetLevel) {
                        available.push(q);
                    }
                }
                return available;
            }

            _calculateDistance(q1, q2) {
                // Euclidean distance between two questions
                const dx = q1.x - q2.x;
                const dy = q1.y - q2.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            _selectFurthestQuestion(availableQuestions) {
                // Select the question furthest from all asked questions AND pending questions
                // This ensures that within a single round, questions are spread out from each other
                if (this.askedQuestionIndices.length === 0 && this.pendingQuestionIndices.length === 0) {
                    // First question ever: select randomly
                    const randomIdx = Math.floor(Math.random() * availableQuestions.length);
                    return availableQuestions[randomIdx];
                }

                let furthestQuestion = null;
                let maxMinDistance = -Infinity;

                // Combine asked and pending indices to get all "sampled" questions
                const sampledIndices = [...this.askedQuestionIndices, ...this.pendingQuestionIndices];
                const sampledQuestions = sampledIndices.map(idx => this.allQuestions[idx]);

                for (const candidate of availableQuestions) {
                    // Find minimum distance to any sampled question (asked or pending)
                    let minDistance = Infinity;
                    for (const sampled of sampledQuestions) {
                        const dist = this._calculateDistance(candidate, sampled);
                        minDistance = Math.min(minDistance, dist);
                    }

                    // Select candidate with maximum of these minimum distances
                    if (minDistance > maxMinDistance) {
                        maxMinDistance = minDistance;
                        furthestQuestion = candidate;
                    }
                }

                console.log(`Selected question at distance ${maxMinDistance.toFixed(4)} from nearest sampled question`);
                return furthestQuestion;
            }

            _calculateCoverageDensity() {
                // Calculate average minimum distance between asked questions
                // This tells us how densely we've sampled the space
                if (this.askedQuestionIndices.length < 2) {
                    return Infinity; // Not enough questions to calculate density
                }

                const askedQuestions = this.askedQuestionIndices.map(idx => this.allQuestions[idx]);
                let totalMinDistance = 0;

                for (const q of askedQuestions) {
                    let minDist = Infinity;
                    for (const other of askedQuestions) {
                        if (q.index !== other.index) {
                            const dist = this._calculateDistance(q, other);
                            minDist = Math.min(minDist, dist);
                        }
                    }
                    totalMinDistance += minDist;
                }

                return totalMinDistance / askedQuestions.length;
            }

            _checkAndTransitionLevel() {
                // Check if we should transition to next level based on coverage threshold
                if (this.currentLevel === 0) {
                    return false; // Already at finest level
                }

                const currentLevelCoverage = this.perLevelState[this.currentLevel].coverage;
                const availableAtCurrentLevel = this._getAvailableQuestions(this.currentLevel).length;

                // Debug: Log coverage check for level 4
                if (this.currentLevel === 4 && !window.level4CoverageLogged) {
                    console.log(`DEBUG: Level 4 coverage check:`);
                    console.log(`  currentLevelCoverage: ${(currentLevelCoverage * 100).toFixed(2)}%`);
                    console.log(`  coverageThreshold: ${(this.coverageThreshold * 100).toFixed(2)}%`);
                    console.log(`  availableAtCurrentLevel: ${availableAtCurrentLevel}`);
                    console.log(`  askedQuestions at L4: ${this.perLevelState[4].askedIndices.length}`);
                    console.log(`  Should transition? ${currentLevelCoverage >= this.coverageThreshold || availableAtCurrentLevel === 0}`);
                    window.level4CoverageLogged = true;
                }

                // Transition when coverage exceeds threshold OR no more questions available at current level
                if (currentLevelCoverage >= this.coverageThreshold || availableAtCurrentLevel === 0) {
                    const oldLevel = this.currentLevel;
                    this.currentLevel--;
                    this.levelTransitions.push({
                        fromLevel: oldLevel,
                        toLevel: this.currentLevel,
                        coverage: currentLevelCoverage,
                        threshold: this.coverageThreshold,
                        questionsAsked: this.perLevelState[oldLevel].askedIndices.length,
                        reason: availableAtCurrentLevel === 0 ? 'exhausted' : 'coverage_met'
                    });
                    console.log(`ðŸ“Š Level transition: ${oldLevel} â†’ ${this.currentLevel} ` +
                               `(coverage: ${(currentLevelCoverage * 100).toFixed(1)}%, ` +
                               `reason: ${availableAtCurrentLevel === 0 ? 'exhausted' : 'target reached'})`);
                    return true;
                }

                return false;
            }

            // === Selection and Recording ===

            selectNextQuestion() {
                // Check if we should transition to next level
                this._checkAndTransitionLevel();

                // Get available questions for current level
                const availableQuestions = this._getAvailableQuestions();

                if (availableQuestions.length === 0) {
                    // No more questions at current level - try to transition
                    if (this.currentLevel > 0) {
                        console.log(`No questions available at level ${this.currentLevel}, transitioning to level ${this.currentLevel - 1}`);
                        this.currentLevel--;
                        return this.selectNextQuestion(); // Recursive call with new level
                    }
                    return null;
                }

                // Use pure geometric sampling: select furthest question
                const selectedQuestion = this._selectFurthestQuestion(availableQuestions);

                // Add to pendingQuestionIndices to prevent selecting again in this round
                if (selectedQuestion) {
                    this.pendingQuestionIndices.push(selectedQuestion.index);
                    // Also track in per-level state
                    const level = selectedQuestion.level !== undefined ? selectedQuestion.level : 0;
                    this.perLevelState[level].pendingIndices.push(selectedQuestion.index);
                }

                // NOTE: Don't add to askedQuestionIndices here!
                // Questions are only marked as "asked" when recordResponse() is called
                // after the user actually answers them

                return selectedQuestion;
            }

            recordResponse(questionIndex, isCorrect, fractionalCorrectness = null) {
                // Record response for a question by its index
                const correctness = fractionalCorrectness !== null ? fractionalCorrectness : (isCorrect ? 1.0 : 0.0);
                this.responses[questionIndex] = correctness;

                // Get question level for per-level tracking
                const question = this.allQuestions[questionIndex];
                const level = question && question.level !== undefined ? question.level : 0;

                // Move from pending to asked
                const pendingIndex = this.pendingQuestionIndices.indexOf(questionIndex);
                if (pendingIndex !== -1) {
                    this.pendingQuestionIndices.splice(pendingIndex, 1);
                }

                // Add to askedQuestionIndices if not already there
                if (!this.askedQuestionIndices.includes(questionIndex)) {
                    this.askedQuestionIndices.push(questionIndex);
                }

                // Update per-level tracking
                const levelPendingIdx = this.perLevelState[level].pendingIndices.indexOf(questionIndex);
                if (levelPendingIdx !== -1) {
                    this.perLevelState[level].pendingIndices.splice(levelPendingIdx, 1);
                }
                if (!this.perLevelState[level].askedIndices.includes(questionIndex)) {
                    this.perLevelState[level].askedIndices.push(questionIndex);
                }

                // Update coverage for this level
                this._updateLevelCoverage(level);
            }

            clearPendingQuestions() {
                // Clear pending questions (e.g., when starting a new round)
                this.pendingQuestionIndices = [];
                // Also clear per-level pending
                for (let level = 0; level <= 4; level++) {
                    this.perLevelState[level].pendingIndices = [];
                }
            }

            // === Utility Methods ===

            _updateLevelCoverage(level) {
                // Compute coverage for a specific level using the confidence formula
                const levelAskedIndices = this.perLevelState[level].askedIndices;

                if (levelAskedIndices.length === 0) {
                    this.perLevelState[level].coverage = 0;
                    return;
                }

                // Get all questions at this level
                const levelQuestions = this.allQuestions.filter(q => {
                    const qLevel = q.level !== undefined ? q.level : 0;
                    return qLevel === level;
                });

                if (levelQuestions.length === 0) {
                    this.perLevelState[level].coverage = 0;
                    return;
                }

                // Generate grid of cell centers (39x39 grid covering [0,1] x [0,1])
                const gridSize = 39;
                const cellCenters = [];
                for (let gx = 0; gx < gridSize; gx++) {
                    for (let gy = 0; gy < gridSize; gy++) {
                        const x = (gx + 0.5) / gridSize;
                        const y = (gy + 0.5) / gridSize;
                        cellCenters.push({x, y});
                    }
                }

                // Compute max distance to nearest question for different scenarios
                const computeMaxDist = (questions) => {
                    let maxDist = 0;
                    for (const center of cellCenters) {
                        let minDist = Infinity;
                        for (const q of questions) {
                            const dist = this._calculateDistance(center, q);
                            minDist = Math.min(minDist, dist);
                        }
                        maxDist = Math.max(maxDist, minDist);
                    }
                    return maxDist;
                };

                // Z: Current max distance (with currently asked questions at this level)
                const askedQuestions = levelAskedIndices.map(idx => this.allQuestions[idx]);
                const Z = computeMaxDist(askedQuestions);

                // X: Best case (all questions at this level answered)
                const X = computeMaxDist(levelQuestions);

                // Y: Worst case (one question at corner (0,0))
                const worstCaseQuestion = [{x: 0, y: 0}];
                const Y = computeMaxDist(worstCaseQuestion);

                // Coverage: (Y - Z) / (Y - X)
                let coverage = 0;
                if (Y > X) {
                    coverage = (Y - Z) / (Y - X);
                    coverage = Math.max(0, Math.min(1, coverage));
                } else {
                    coverage = Z <= X ? 1.0 : 0.0;
                }

                this.perLevelState[level].coverage = coverage;
            }

            _computeConfidence() {
                // Confidence based on coverage distance
                // Formula: confidence = (Y - Z) / (Y - X)
                // where:
                //   X = best case (max dist when ALL questions answered)
                //   Y = worst case (max dist when 1 corner question answered)
                //   Z = current max dist to nearest asked question

                if (this.askedQuestionIndices.length === 0) {
                    return { confidence: 0, maxDistCurrent: Infinity, maxDistBest: 0, maxDistWorst: 0 };
                }

                // Generate grid of cell centers (39x39 grid covering [0,1] x [0,1])
                const gridSize = 39;
                const cellCenters = [];
                for (let gx = 0; gx < gridSize; gx++) {
                    for (let gy = 0; gy < gridSize; gy++) {
                        const x = (gx + 0.5) / gridSize;
                        const y = (gy + 0.5) / gridSize;
                        cellCenters.push({x, y});
                    }
                }

                // Compute max distance to nearest question for different scenarios
                const computeMaxDist = (questions) => {
                    let maxDist = 0;
                    for (const center of cellCenters) {
                        let minDist = Infinity;
                        for (const q of questions) {
                            const dist = this._calculateDistance(center, q);
                            minDist = Math.min(minDist, dist);
                        }
                        maxDist = Math.max(maxDist, minDist);
                    }
                    return maxDist;
                };

                // Z: Current max distance (with currently asked questions)
                const askedQuestions = this.askedQuestionIndices.map(idx => this.allQuestions[idx]);
                const Z = computeMaxDist(askedQuestions);

                // X: Best case (all questions answered)
                const X = computeMaxDist(this.allQuestions);

                // Y: Worst case (one question at corner (0,0))
                const worstCaseQuestion = [{x: 0, y: 0}];
                const Y = computeMaxDist(worstCaseQuestion);

                // Confidence: (Y - Z) / (Y - X)
                // When Z = Y (worst case), confidence = 0%
                // When Z = X (best case), confidence = 100%
                let confidence = 0;
                if (Y > X) {
                    confidence = (Y - Z) / (Y - X);
                    confidence = Math.max(0, Math.min(1, confidence));
                } else {
                    confidence = Z <= X ? 1.0 : 0.0;
                }

                return {
                    confidence: confidence,
                    maxDistCurrent: Z,
                    maxDistBest: X,
                    maxDistWorst: Y
                };
            }

            getStats() {
                const avgMinDist = this._calculateCoverageDensity();
                const confidenceData = this._computeConfidence();

                // Return per-level coverage data
                const perLevelCoverage = {};
                for (let level = 0; level <= 4; level++) {
                    perLevelCoverage[level] = {
                        coverage: this.perLevelState[level].coverage,
                        questionsAsked: this.perLevelState[level].askedIndices.length,
                        questionsPending: this.perLevelState[level].pendingIndices.length
                    };
                }

                return {
                    questionsAsked: this.askedQuestionIndices.length,
                    currentLevel: this.currentLevel,
                    avgMinDistance: avgMinDist,
                    levelTransitions: this.levelTransitions.length,
                    confidence: confidenceData.confidence,
                    maxDistCurrent: confidenceData.maxDistCurrent,
                    maxDistBest: confidenceData.maxDistBest,
                    maxDistWorst: confidenceData.maxDistWorst,
                    perLevelCoverage: perLevelCoverage
                };
            }

            reset() {
                this.askedQuestionIndices = [];
                this.pendingQuestionIndices = [];
                this.responses = {};
                this.currentLevel = 4;
                this.levelTransitions = [];

                // Reset per-level tracking
                for (let level = 0; level <= 4; level++) {
                    this.perLevelState[level] = {
                        askedIndices: [],
                        pendingIndices: [],
                        coverage: 0
                    };
                }
            }
        }

        // Load cell distances
        async function loadCellDistances() {
            try {
                const response = await fetch('cell_distances.json');
                if (!response.ok) {
                    console.warn('Cell distances not found - will use random sampling');
                    return null;
                }
                const data = await response.json();
                console.log(`Loaded ${data.metadata.num_cells}Ã—${data.metadata.num_cells} distance matrix`);
                return data;
            } catch (error) {
                console.warn('Could not load cell distances:', error);
                return null;
            }
        }

        // Load questions and initialize
        async function loadQuestions() {
            try {
                // Use cell_questions_sample.json as placeholder (will be cell_questions.json when generation completes)
                const response = await fetch('cell_questions.json');
                if (!response.ok) {
                    throw new Error(`Failed to load questions: ${response.status}`);
                }
                const data = await response.json();

                // Flatten all questions from all cells into the pool
                allQuestionsPool = [];
                // Calculate cell dimensions for jitter
                const gridSize = 40;
                const cellWidth = 1.0 / (gridSize - 1);  // Normalized [0,1] space
                const cellHeight = 1.0 / (gridSize - 1);

                data.cells.forEach(cellData => {
                    cellData.questions.forEach(q => {
                        // Convert correct_answer letter (e.g., "D") to index (e.g., 3)
                        let correctIndex;
                        if (q.correct_index !== undefined) {
                            correctIndex = q.correct_index;  // Already a number
                        } else if (q.correct_answer !== undefined) {
                            // Convert letter to index: "A" â†’ 0, "B" â†’ 1, "C" â†’ 2, "D" â†’ 3
                            correctIndex = q.correct_answer.charCodeAt(0) - 65;
                        } else {
                            console.error('Question missing correct answer:', q);
                            correctIndex = 0;  // Fallback
                        }

                        // Convert options from dict {A: "...", B: "...", C: "...", D: "..."} to array
                        let optionsArray;
                        if (Array.isArray(q.options)) {
                            optionsArray = q.options;
                        } else if (typeof q.options === 'object') {
                            // Convert dict to array in correct order
                            optionsArray = [
                                q.options.A || q.options['A'],
                                q.options.B || q.options['B'],
                                q.options.C || q.options['C'],
                                q.options.D || q.options['D']
                            ];
                        } else {
                            console.error('Question has invalid options format:', q);
                            optionsArray = [];
                        }

                        // Questions already have x,y coordinates from merge script
                        allQuestionsPool.push({
                            question: q.question,
                            options: optionsArray,
                            correctIndex: correctIndex,
                            x: q.x,
                            y: q.y,
                            topic: q.topic || 'general',
                            cell_gx: cellData.cell.gx,
                            cell_gy: cellData.cell.gy
                        });
                    });
                });

                console.log(`Loaded ${allQuestionsPool.length} total questions from ${data.cells.length} cells`);

                // Store original cell-based data for adaptive sampler
                cellQuestionsData = data;

                // Load cell distances and initialize adaptive sampler
                cellDistances = await loadCellDistances();
                if (cellDistances) {
                    adaptiveSampler = new AdaptiveSampler(cellQuestionsData, cellDistances, {
                        maxQuestions: 10,
                        minQuestionsBeforeExit: 3,
                        confidenceThreshold: 0.85
                    });
                    console.log('Adaptive sampling enabled');
                } else {
                    console.log('Using random sampling (distances not available)');
                }

                // Start first quiz round (select 10 random questions)
                startNewQuizRound();
            } catch (error) {
                console.error('Error loading questions:', error);
                questionContainer.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #e74c3c;">
                        <h3>Error Loading Questions</h3>
                        <p>Could not load cell_questions_sample.json. Please ensure the file exists and the page is served via HTTP(S).</p>
                        <p style="font-size: 0.9em; color: #666; margin-top: 20px;">
                            If testing locally, use a local server like: <code>python -m http.server 8000</code>
                        </p>
                    </div>
                `;
            }
        }

        // Start a new quiz round by selecting 10 new questions (adaptive or random)
        function startNewQuizRound() {
            // Reset for new round
            currentQuestion = 0;
            currentRound++;
            userResponses = []; // Clear current round responses

            if (adaptiveSampler) {
                // Clear pending questions from previous round
                adaptiveSampler.clearPendingQuestions();

                // Use adaptive sampling
                questionsData = [];
                const maxQuestions = adaptiveSampler.config.maxQuestions;

                // Select questions one at a time using adaptive algorithm
                for (let i = 0; i < maxQuestions; i++) {
                    const selectedQuestion = adaptiveSampler.selectNextQuestion();
                    if (!selectedQuestion) {
                        console.log(`No more questions available after ${i} questions`);
                        break;
                    }

                    // Convert to questionsData format
                    let correctIndex;
                    if (selectedQuestion.correct_index !== undefined) {
                        correctIndex = selectedQuestion.correct_index;
                    } else if (selectedQuestion.correct_answer !== undefined) {
                        correctIndex = selectedQuestion.correct_answer.charCodeAt(0) - 65;
                    } else {
                        console.error('Question missing correct answer:', selectedQuestion);
                        correctIndex = 0;
                    }

                    // Convert options from dict to array if needed
                    let optionsArray;
                    if (Array.isArray(selectedQuestion.options)) {
                        optionsArray = selectedQuestion.options;
                    } else if (typeof selectedQuestion.options === 'object') {
                        optionsArray = [
                            selectedQuestion.options.A || selectedQuestion.options['A'],
                            selectedQuestion.options.B || selectedQuestion.options['B'],
                            selectedQuestion.options.C || selectedQuestion.options['C'],
                            selectedQuestion.options.D || selectedQuestion.options['D']
                        ];
                    } else {
                        console.error('Question has invalid options format:', selectedQuestion);
                        optionsArray = [];
                    }

                    const question = {
                        question: selectedQuestion.question,
                        options: optionsArray,
                        correctIndex: correctIndex,
                        x: selectedQuestion.x,
                        y: selectedQuestion.y,
                        level: selectedQuestion.level !== undefined ? selectedQuestion.level : 0,  // Preserve level for rendering
                        topic: selectedQuestion.topic || 'general',
                        cell_gx: selectedQuestion.cellData.cell.gx,
                        cell_gy: selectedQuestion.cellData.cell.gy,
                        cellKey: selectedQuestion.cellKey,
                        index: selectedQuestion.index  // IMPORTANT: preserve index for recordResponse()
                    };

                    questionsData.push(question);
                }

                console.log(`Round ${currentRound}: Selected ${questionsData.length} questions using adaptive sampling`);
                const stats = adaptiveSampler.getStats();
                console.log(`Coverage: ${(stats.coverageConfidence * 100).toFixed(1)}%, ` +
                           `Uncertainty confidence: ${(stats.uncertaintyConfidence * 100).toFixed(1)}%`);
            } else {
                // Fall back to random sampling
                const availableIndices = [];
                for (let i = 0; i < allQuestionsPool.length; i++) {
                    if (!askedQuestionIndices.includes(i)) {
                        availableIndices.push(i);
                    }
                }

                if (availableIndices.length < 10) {
                    console.log(`Only ${availableIndices.length} questions remaining. Resetting question pool.`);
                    askedQuestionIndices = [];
                    availableIndices.length = 0;
                    for (let i = 0; i < allQuestionsPool.length; i++) {
                        availableIndices.push(i);
                    }
                }

                const shuffled = availableIndices.sort(() => Math.random() - 0.5);
                const selectedIndices = shuffled.slice(0, 10);
                questionsData = selectedIndices.map(i => allQuestionsPool[i]);
                askedQuestionIndices.push(...selectedIndices);

                console.log(`Round ${currentRound}: Selected ${questionsData.length} questions (random sampling)`);
            }

            renderQuestion();
        }

        // Load cell labels for heatmap tooltips
        async function loadCellLabels() {
            try {
                const response = await fetch('heatmap_cell_labels.json');
                if (!response.ok) {
                    console.warn('Cell labels not found - tooltips will show basic info only');
                    return;
                }
                const data = await response.json();
                cellLabelsData = data.cells;
                console.log(`Loaded ${cellLabelsData.length} cell labels`);
            } catch (error) {
                console.warn('Could not load cell labels:', error);
            }
        }

        // Load Wikipedia articles
        async function loadWikipediaArticles() {
            try {
                const response = await fetch('wikipedia_articles.json');
                if (!response.ok) {
                    console.warn('Wikipedia articles not found - visualization will show questions only');
                    return;
                }
                wikipediaArticles = await response.json();
                console.log(`Loaded ${wikipediaArticles.length} Wikipedia articles`);
            } catch (error) {
                console.warn('Could not load Wikipedia articles:', error);
            }
        }

        // Calculate inferred knowledge percentage for a cell
        function calculateCellKnowledge(centerX, centerY) {
            const sigma = 0.15; // Same as drawKnowledgeHeatmap
            let knowledge = 0;
            let totalWeight = 0;

            questionsData.forEach((q, idx) => {
                const dx = centerX - q.x;
                const dy = centerY - q.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const weight = Math.exp(-(dist * dist) / (2 * sigma * sigma));

                if (userResponses[idx] !== undefined && userResponses[idx] !== null) {
                    let correctness;
                    if (userResponses[idx] === -1 || q.skipped) {
                        // "I Don't Know" - 0.1 correctness
                        correctness = 0.1;
                    } else {
                        const isCorrect = userResponses[idx] === q.correctIndex;
                        correctness = isCorrect ? 1 : 0;
                    }
                    knowledge += weight * correctness;
                    totalWeight += weight;
                }
            });

            const value = totalWeight > 0 ? knowledge / totalWeight : 0.5;
            return Math.round(value * 100);
        }

        function knowledgePercentToLabel(knowledgePct) {
            // Convert percentage to categorical label
            // Low (<= 25%), Low-Intermediate (25-50%), High-Intermediate (50-75%), High (>= 75%)
            if (knowledgePct <= 25) {
                return 'Low';
            } else if (knowledgePct <= 50) {
                return 'Low-Intermediate';
            } else if (knowledgePct <= 75) {
                return 'High-Intermediate';
            } else {
                return 'High';
            }
        }

        // Initialize
        loadQuestions();
        loadCellLabels();
        loadWikipediaArticles();

        // Event listeners
        nextBtn.addEventListener('click', handleNext);
        prevBtn.addEventListener('click', handlePrevious);
        dontKnowBtn.addEventListener('click', handleDontKnow);
        showMapBtn.addEventListener('click', handleShowMap);
        restartBtn.addEventListener('click', restart);
        anotherRoundBtn.addEventListener('click', startAnotherRound);
        startQuizBtn.addEventListener('click', startQuiz);
        aboutBtn.addEventListener('click', openAbout);
        closeAboutBtn.addEventListener('click', closeAbout);
        copyCitationBtn.addEventListener('click', copyCitation);

        // About modal functions
        function openAbout() {
            aboutModal.classList.remove('hidden');
            document.body.style.overflow = 'hidden';
        }

        function closeAbout() {
            aboutModal.classList.add('hidden');
            document.body.style.overflow = '';
        }

        // Close modal on backdrop click
        aboutModal.addEventListener('click', (e) => {
            if (e.target.classList.contains('modal-backdrop')) {
                closeAbout();
            }
        });

        // Close modal on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && !aboutModal.classList.contains('hidden')) {
                closeAbout();
            }
        });

        // Copy citation to clipboard
        function copyCitation() {
            const citationText = document.getElementById('citation-text').innerText;
            navigator.clipboard.writeText(citationText).then(() => {
                const btn = copyCitationBtn;
                const originalHTML = btn.innerHTML;
                btn.innerHTML = '<i class="fas fa-check"></i> Copied!';
                btn.classList.add('copied');
                setTimeout(() => {
                    btn.innerHTML = originalHTML;
                    btn.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy citation:', err);
                alert('Failed to copy citation. Please copy manually.');
            });
        }

        // Handle contact form submission
        contactForm.addEventListener('submit', (e) => {
            e.preventDefault();

            // Get form values
            const firstName = document.getElementById('contact-first-name').value.trim();
            const lastName = document.getElementById('contact-last-name').value.trim();
            const email = document.getElementById('contact-email').value.trim();
            const subject = document.getElementById('contact-subject').value.trim();
            const message = document.getElementById('contact-message').value.trim();

            // Build mailto link
            const to = 'contextualdynamics@gmail.com';
            const fullSubject = `[MAPPER] ${subject}`;
            const body = `From: ${firstName} ${lastName}\nEmail: ${email}\n\n${message}`;

            const mailtoLink = `mailto:${to}?subject=${encodeURIComponent(fullSubject)}&body=${encodeURIComponent(body)}`;

            // Open mailto link
            window.location.href = mailtoLink;

            // Reset form after slight delay
            setTimeout(() => {
                contactForm.reset();
            }, 100);
        });

        // Start quiz (hide intro, show quiz)
        function startQuiz() {
            introSection.classList.add('hidden');
            quizSection.classList.remove('hidden');

            // Show confidence display if adaptive sampling is enabled
            if (adaptiveSampler) {
                confidenceDisplay.classList.remove('hidden');
                updateConfidenceDisplay(); // Initialize display to 0%
            }
        }

        // Update confidence display
        function updateConfidenceDisplay() {
            if (!adaptiveSampler) return;

            const stats = adaptiveSampler.getStats();

            // Update per-level coverage bars (levels 0-4)
            for (let level = 0; level <= 4; level++) {
                const levelData = stats.perLevelCoverage[level];
                const percent = Math.round(levelData.coverage * 100);

                // Update quiz section bars
                const fillElement = document.getElementById(`confidence-fill-${level}`);
                const percentElement = document.getElementById(`level-percent-${level}`);
                if (fillElement) {
                    fillElement.style.width = `${percent}%`;
                }
                if (percentElement) {
                    percentElement.textContent = `${percent}%`;
                }

                // Update map section bars
                const mapFillElement = document.getElementById(`map-confidence-fill-${level}`);
                const mapPercentElement = document.getElementById(`map-level-percent-${level}`);
                if (mapFillElement) {
                    mapFillElement.style.width = `${percent}%`;
                }
                if (mapPercentElement) {
                    mapPercentElement.textContent = `${percent}%`;
                }
            }

            console.log(`Level ${stats.currentLevel}, Per-Level Coverage: ` +
                       `L4=${Math.round(stats.perLevelCoverage[4].coverage * 100)}%, ` +
                       `L3=${Math.round(stats.perLevelCoverage[3].coverage * 100)}%, ` +
                       `L2=${Math.round(stats.perLevelCoverage[2].coverage * 100)}%, ` +
                       `L1=${Math.round(stats.perLevelCoverage[1].coverage * 100)}%, ` +
                       `L0=${Math.round(stats.perLevelCoverage[0].coverage * 100)}%`);
        }

        function renderQuestion() {
            const q = questionsData[currentQuestion];
            questionNumber.textContent = `Question ${currentQuestion + 1} of ${questionsData.length}`;
            questionText.innerHTML = q.question;

            optionsContainer.innerHTML = '';
            // Convert options object {A: "...", B: "...", C: "...", D: "..."} to array
            const optionsArray = Object.values(q.options);
            optionsArray.forEach((option, index) => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'option';

                const savedResponse = userResponses[currentQuestion];
                if (savedResponse !== undefined && savedResponse === index) {
                    optionDiv.classList.add('selected');
                    selectedOption = index;
                }

                optionDiv.innerHTML = `
                    <span class="option-label">${String.fromCharCode(65 + index)}</span>
                    <span class="option-text">${option}</span>
                `;

                optionDiv.addEventListener('click', () => selectOption(index, optionDiv));
                optionsContainer.appendChild(optionDiv);
            });

            prevBtn.classList.toggle('hidden', currentQuestion === 0);
            nextBtn.disabled = selectedOption === null;
            nextBtn.innerHTML = 'Next <i class="fas fa-arrow-right"></i>';

            questionContainer.classList.remove('fade-in');
            void questionContainer.offsetWidth;
            questionContainer.classList.add('fade-in');

            // Render LaTeX with KaTeX after DOM update
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(questionText, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false}
                    ],
                    throwOnError: false
                });
                // Render LaTeX in all option texts
                document.querySelectorAll('.option-text').forEach(el => {
                    renderMathInElement(el, {
                        delimiters: [
                            {left: '$$', right: '$$', display: true},
                            {left: '$', right: '$', display: false}
                        ],
                        throwOnError: false
                    });
                });
            }
        }

        function selectOption(index, optionElement) {
            document.querySelectorAll('.option').forEach(opt => {
                opt.classList.remove('selected');
            });

            optionElement.classList.add('selected');
            selectedOption = index;
            nextBtn.disabled = false;
        }

        function handleNext() {
            userResponses[currentQuestion] = selectedOption;
            let shouldStartNewRound = false;  // Declare here so it's accessible throughout the function

            // Record response in adaptive sampler if available
            if (adaptiveSampler && questionsData[currentQuestion].index !== undefined) {
                const isCorrect = selectedOption === questionsData[currentQuestion].correctIndex;
                const previousLevel = adaptiveSampler.currentLevel;
                const previousCoverage = adaptiveSampler.perLevelState[previousLevel].coverage;

                adaptiveSampler.recordResponse(questionsData[currentQuestion].index, isCorrect);

                // Update confidence display
                updateConfidenceDisplay();

                // Check if we just crossed the threshold for this level
                const newCoverage = adaptiveSampler.perLevelState[previousLevel].coverage;
                if (previousCoverage < adaptiveSampler.coverageThreshold &&
                    newCoverage >= adaptiveSampler.coverageThreshold) {
                    // Threshold crossed! Highlight the Show Map button
                    showMapBtn.classList.add('high-confidence');
                    console.log(`ðŸŽ¯ Level ${previousLevel} threshold reached! Coverage: ${Math.round(newCoverage * 100)}%`);

                    // Trigger level transition check
                    const transitioned = adaptiveSampler._checkAndTransitionLevel();
                    if (transitioned) {
                        // Level changed - start new round immediately with new level questions
                        shouldStartNewRound = true;
                        console.log(`âš¡ Starting new round immediately at level ${adaptiveSampler.currentLevel}`);
                    }
                }

                // Log stats
                const stats = adaptiveSampler.getStats();
                console.log(`Question ${currentQuestion + 1}: ${isCorrect ? 'Correct' : 'Incorrect'} | ` +
                           `Level: ${stats.currentLevel} | Density: ${stats.avgMinDistance.toFixed(4)}`);
            }

            if (shouldStartNewRound) {
                // Save answered questions from this partial round before starting new round
                for (let i = 0; i <= currentQuestion; i++) {
                    if (userResponses[i] !== undefined) {
                        allQuestionsShown.push(questionsData[i]);
                        allUserResponses.push(userResponses[i]);
                    }
                }

                // Skip remaining questions and start new round
                selectedOption = null;  // Reset selection for new round
                startNewQuizRound();
                return;  // Exit handleNext() to prevent further processing
            } else if (currentQuestion < questionsData.length - 1) {
                currentQuestion++;
                selectedOption = null;
                renderQuestion();
            } else {
                // Reached end of current batch - automatically load more questions
                if (adaptiveSampler) {
                    const selectedQuestion = adaptiveSampler.selectNextQuestion();
                    if (selectedQuestion) {
                        // Add new question to questionsData
                        let correctIndex;
                        if (selectedQuestion.correct_index !== undefined) {
                            correctIndex = selectedQuestion.correct_index;
                        } else if (selectedQuestion.correct_answer !== undefined) {
                            correctIndex = selectedQuestion.correct_answer.charCodeAt(0) - 65;
                        } else {
                            correctIndex = 0;
                        }

                        let optionsArray;
                        if (Array.isArray(selectedQuestion.options)) {
                            optionsArray = selectedQuestion.options;
                        } else if (typeof selectedQuestion.options === 'object') {
                            optionsArray = [
                                selectedQuestion.options.A || selectedQuestion.options['A'],
                                selectedQuestion.options.B || selectedQuestion.options['B'],
                                selectedQuestion.options.C || selectedQuestion.options['C'],
                                selectedQuestion.options.D || selectedQuestion.options['D']
                            ];
                        } else {
                            optionsArray = [];
                        }

                        const question = {
                            question: selectedQuestion.question,
                            options: optionsArray,
                            correctIndex: correctIndex,
                            x: selectedQuestion.x,
                            y: selectedQuestion.y,
                            topic: selectedQuestion.topic || 'general',
                            cell_gx: selectedQuestion.cellData.cell.gx,
                            cell_gy: selectedQuestion.cellData.cell.gy,
                            cellKey: selectedQuestion.cellKey,
                            index: selectedQuestion.index
                        };

                        questionsData.push(question);
                        userResponses.push(undefined);
                        currentQuestion++;
                        selectedOption = null;
                        renderQuestion();
                    } else {
                        // No more questions available
                        questionContainer.innerHTML = '<p style="text-align: center; padding: 40px; font-size: 1.2em;">No more questions available. Click "Show Map" to view your results.</p>';
                        nextBtn.disabled = true;
                    }
                }
            }
        }

        function handlePrevious() {
            if (currentQuestion > 0) {
                currentQuestion--;
                selectedOption = userResponses[currentQuestion] ?? null;
                renderQuestion();
            }
        }

        function handleDontKnow() {
            // Record "I Don't Know" response with correctness=0.1
            const skippedIndex = -1; // Special marker for "I Don't Know"
            userResponses[currentQuestion] = skippedIndex;

            // Mark this question as skipped
            questionsData[currentQuestion].skipped = true;

            // Record response in adaptive sampler with low correctness
            if (adaptiveSampler && questionsData[currentQuestion].index !== undefined) {
                const previousLevel = adaptiveSampler.currentLevel;
                const previousCoverage = adaptiveSampler.perLevelState[previousLevel].coverage;

                adaptiveSampler.recordResponse(questionsData[currentQuestion].index, false, 0.1);

                // Update confidence display
                updateConfidenceDisplay();

                // Check if we just crossed the threshold for this level
                const newCoverage = adaptiveSampler.perLevelState[previousLevel].coverage;
                if (previousCoverage < adaptiveSampler.coverageThreshold &&
                    newCoverage >= adaptiveSampler.coverageThreshold) {
                    // Threshold crossed! Highlight the Show Map button
                    showMapBtn.classList.add('high-confidence');
                    console.log(`ðŸŽ¯ Level ${previousLevel} threshold reached! Coverage: ${Math.round(newCoverage * 100)}%`);
                }

                // Log stats
                const stats = adaptiveSampler.getStats();
                console.log(`Question ${currentQuestion + 1}: I Don't Know (0.1 correctness) | ` +
                           `Level: ${stats.currentLevel} | Density: ${stats.avgMinDistance.toFixed(4)}`);
            }

            // Move to next question or load more
            if (currentQuestion < questionsData.length - 1) {
                currentQuestion++;
                selectedOption = null;
                renderQuestion();
            } else {
                // Reached end of current batch - automatically load more questions
                if (adaptiveSampler) {
                    const selectedQuestion = adaptiveSampler.selectNextQuestion();
                    if (selectedQuestion) {
                        // Add new question to questionsData
                        let correctIndex;
                        if (selectedQuestion.correct_index !== undefined) {
                            correctIndex = selectedQuestion.correct_index;
                        } else if (selectedQuestion.correct_answer !== undefined) {
                            correctIndex = selectedQuestion.correct_answer.charCodeAt(0) - 65;
                        } else {
                            correctIndex = 0;
                        }

                        let optionsArray;
                        if (Array.isArray(selectedQuestion.options)) {
                            optionsArray = selectedQuestion.options;
                        } else if (typeof selectedQuestion.options === 'object') {
                            optionsArray = [
                                selectedQuestion.options.A || selectedQuestion.options['A'],
                                selectedQuestion.options.B || selectedQuestion.options['B'],
                                selectedQuestion.options.C || selectedQuestion.options['C'],
                                selectedQuestion.options.D || selectedQuestion.options['D']
                            ];
                        } else {
                            optionsArray = [];
                        }

                        const question = {
                            question: selectedQuestion.question,
                            options: optionsArray,
                            correctIndex: correctIndex,
                            x: selectedQuestion.x,
                            y: selectedQuestion.y,
                            topic: selectedQuestion.topic || 'general',
                            cell_gx: selectedQuestion.cellData.cell.gx,
                            cell_gy: selectedQuestion.cellData.cell.gy,
                            cellKey: selectedQuestion.cellKey,
                            index: selectedQuestion.index
                        };

                        questionsData.push(question);
                        userResponses.push(undefined);
                        currentQuestion++;
                        selectedOption = null;
                        renderQuestion();
                    } else {
                        // No more questions available
                        questionContainer.innerHTML = '<p style="text-align: center; padding: 40px; font-size: 1.2em;">No more questions available. Click "Show Map" to view your results.</p>';
                        nextBtn.disabled = true;
                    }
                }
            }
        }

        function handleShowMap() {
            // Reset the Show Map button color when clicked
            showMapBtn.classList.remove('high-confidence');

            // Show map at any time, even if no questions answered (will show all 0.5)
            showResults();
        }

        function showResults() {
            quizSection.classList.add('hidden');
            mapSection.classList.remove('hidden');
            loading.classList.remove('hidden');

            // Show coverage display on map if adaptive sampling is enabled
            if (adaptiveSampler) {
                const mapConfidenceDisplay = document.getElementById('map-confidence-display');
                mapConfidenceDisplay.classList.remove('hidden');

                // Update per-level coverage bars on map
                updateConfidenceDisplay();

                // Check if all questions are exhausted at current level
                const availableQuestions = adaptiveSampler._getAvailableQuestions();
                if (availableQuestions.length === 0 && adaptiveSampler.currentLevel === 0) {
                    anotherRoundBtn.disabled = true;
                    anotherRoundBtn.innerHTML = '<i class="fas fa-check"></i> All Questions Completed';
                } else {
                    anotherRoundBtn.disabled = false;
                    anotherRoundBtn.innerHTML = '<i class="fas fa-play"></i> Answer More Questions';
                }
            }

            // Add current round questions and responses to full history
            // Only include questions that have actually been answered (have a response)
            const answeredQuestions = [];
            const answeredResponses = [];

            for (let i = 0; i < questionsData.length; i++) {
                if (userResponses[i] !== undefined) {
                    answeredQuestions.push(questionsData[i]);
                    answeredResponses.push(userResponses[i]);
                }
            }

            allUserResponses.push(...answeredResponses);
            allQuestionsShown.push(...answeredQuestions);

            // Calculate accuracy for current round
            let correct = 0;
            answeredResponses.forEach((response, index) => {
                if (response !== undefined && response === answeredQuestions[index].correctIndex) {
                    correct++;
                }
            });

            // Stats will be removed from display, but keeping calculation for potential future use
            document.getElementById('correct-count').textContent = correct;
            document.getElementById('accuracy-pct').textContent = answeredResponses.length > 0 ? `${Math.round((correct / answeredResponses.length) * 100)}%` : '0%';
            document.getElementById('total-count').textContent = answeredResponses.length;

            setTimeout(() => {
                loading.classList.add('hidden');
                // Generate map using ALL responses from all rounds
                generateKnowledgeMapWithHistory();
            }, 1500);
        }

        // Generate knowledge map using full response history (all rounds)
        function generateKnowledgeMapWithHistory() {
            // Use the accumulated questions and responses from all rounds
            // No need to rebuild - allQuestionsShown and allUserResponses already have everything

            // Update global arrays to show full accumulated history
            // Don't restore - we want these to persist for animation frames and future redraws
            questionsData = allQuestionsShown;
            userResponses = allUserResponses;

            // Generate map with full history
            generateKnowledgeMap();
        }

        function generateKnowledgeMap() {
            const container = canvas.parentElement;
            const dpr = window.devicePixelRatio || 1;
            canvas.width = container.clientWidth * dpr;
            canvas.height = container.clientHeight * dpr;
            canvas.style.width = container.clientWidth + 'px';
            canvas.style.height = container.clientHeight + 'px';
            ctx.scale(dpr, dpr);

            const width = container.clientWidth;
            const height = container.clientHeight;

            // Hide canvas until everything is rendered
            canvas.style.visibility = 'hidden';

            // Create knowledge heatmap
            drawKnowledgeHeatmap(width, height);

            // Defer drawing markers until next frame to ensure canvas is properly sized
            // This prevents the visual glitch where dots appear in wrong positions during heatmap generation
            requestAnimationFrame(() => {
                // Draw Wikipedia article dots (between heatmap and questions)
                drawWikipediaArticles(width, height);

                // Draw question markers
                drawQuestionMarkers(width, height);

                // Show canvas now that everything is rendered
                canvas.style.visibility = 'visible';
            });

            // Add interactivity
            addInteractivity(width, height);

            // Make legend and colorbar draggable (only initialize once)
            if (!canvas.dataset.draggableInitialized) {
                const legend = document.querySelector('.legend');
                const colorbar = document.querySelector('.colorbar');
                if (legend) makeDraggable(legend);
                if (colorbar) makeDraggable(colorbar);
                canvas.dataset.draggableInitialized = 'true';
            }
        }

        function redrawCanvas() {
            // Get current canvas dimensions
            const container = canvas.parentElement;
            const width = canvas.width / window.devicePixelRatio;
            const height = canvas.height / window.devicePixelRatio;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Redraw heatmap, articles, and markers
            drawKnowledgeHeatmap(width, height);
            drawWikipediaArticles(width, height);
            drawQuestionMarkers(width, height);
        }

        function animateCanvas() {
            const currentTime = performance.now();
            const deltaTime = currentTime - lastFrameTime;
            lastFrameTime = currentTime;

            let needsRedraw = false;

            // Update animation progress for all question dots
            questionsData.forEach((q, idx) => {
                const isHovered = (hoveredDotIndex === idx);
                const target = isHovered ? 1 : 0;
                const current = dotAnimationProgress[idx] || 0;

                if (Math.abs(current - target) > 0.01) {
                    // Smooth transition (50ms duration - very snappy)
                    const speed = 1 / 50; // Progress per millisecond
                    const delta = (target - current) * Math.min(speed * deltaTime, 1);
                    dotAnimationProgress[idx] = Math.max(0, Math.min(1, current + delta));
                    needsRedraw = true;
                } else {
                    dotAnimationProgress[idx] = target;
                }
            });

            // Update animation progress for Wikipedia article dots
            wikipediaArticles.forEach((article, idx) => {
                const isHovered = (hoveredArticleIndex === idx);
                const target = isHovered ? 1 : 0;
                const current = articleAnimationProgress[idx] || 0;

                if (Math.abs(current - target) > 0.01) {
                    // Smooth transition (50ms duration - same as questions)
                    const speed = 1 / 50; // Progress per millisecond
                    const delta = (target - current) * Math.min(speed * deltaTime, 1);
                    articleAnimationProgress[idx] = Math.max(0, Math.min(1, current + delta));
                    needsRedraw = true;
                } else {
                    articleAnimationProgress[idx] = target;
                }
            });

            if (needsRedraw) {
                redrawCanvas();
                animationFrameId = requestAnimationFrame(animateCanvas);
            } else {
                animationFrameId = null;
            }
        }

        function startAnimation() {
            if (!animationFrameId) {
                lastFrameTime = performance.now();
                animationFrameId = requestAnimationFrame(animateCanvas);
            }
        }

        function drawKnowledgeHeatmap(width, height) {
            const gridSize = 40;
            const sigma = 0.15; // Gaussian kernel width

            // Create a 2D grid of knowledge values
            const grid = [];
            for (let gy = 0; gy < gridSize; gy++) {
                grid[gy] = [];
                for (let gx = 0; gx < gridSize; gx++) {
                    const x = gx / (gridSize - 1);
                    const y = gy / (gridSize - 1);
                    
                    // Calculate knowledge at this point based on nearby correct/incorrect answers
                    let knowledge = 0;
                    let totalWeight = 0;
                    
                    questionsData.forEach((q, idx) => {
                        const dx = x - q.x;
                        const dy = y - q.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const weight = Math.exp(-(dist * dist) / (2 * sigma * sigma));

                        if (userResponses[idx] !== undefined) {
                            let correctness;
                            if (userResponses[idx] === -1 || q.skipped) {
                                // "I Don't Know" - 0.1 correctness
                                correctness = 0.1;
                            } else {
                                const isCorrect = userResponses[idx] === q.correctIndex;
                                correctness = isCorrect ? 1 : 0;
                            }
                            knowledge += weight * correctness;
                            totalWeight += weight;
                        }
                    });
                    
                    grid[gy][gx] = totalWeight > 0 ? knowledge / totalWeight : 0.5;
                }
            }

            // Draw heatmap
            const cellWidth = width / (gridSize - 1);
            const cellHeight = height / (gridSize - 1);

            for (let gy = 0; gy < gridSize - 1; gy++) {
                for (let gx = 0; gx < gridSize - 1; gx++) {
                    const value = grid[gy][gx];
                    let color = mapToColor(value);

                    // Darken if this is the hovered cell
                    if (hoveredHeatmapCell && hoveredHeatmapCell.gx === gx && hoveredHeatmapCell.gy === gy) {
                        color = darkenColor(color, 0.15);
                    }

                    ctx.fillStyle = color;
                    ctx.fillRect(
                        gx * cellWidth,
                        gy * cellHeight,
                        cellWidth + 1,
                        cellHeight + 1
                    );
                }
            }
        }

        function mapToColor(value) {
            // Bronze-to-Green colormap (complementary to Dartmouth Green)
            const colors = [
                [139, 69, 19],    // Saddle Brown (low)
                [184, 134, 11],   // Dark Goldenrod
                [218, 165, 32],   // Goldenrod
                [0, 133, 66],     // Medium Green
                [0, 105, 62]      // Dartmouth Green (high)
            ];

            const scaled = value * (colors.length - 1);
            const idx = Math.floor(scaled);
            const t = scaled - idx;

            if (idx >= colors.length - 1) {
                const c = colors[colors.length - 1];
                return `rgba(${c[0]}, ${c[1]}, ${c[2]}, 0.8)`;
            }

            const c1 = colors[idx];
            const c2 = colors[idx + 1];
            
            const r = Math.round(c1[0] + (c2[0] - c1[0]) * t);
            const g = Math.round(c1[1] + (c2[1] - c1[1]) * t);
            const b = Math.round(c1[2] + (c2[2] - c1[2]) * t);

            return `rgba(${r}, ${g}, ${b}, 0.8)`;
        }

        function darkenColor(colorString, amount = 0.2) {
            // Parse RGB/RGBA color string and darken it
            const matches = colorString.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
            if (!matches) return colorString;

            const r = Math.floor(parseInt(matches[1]) * (1 - amount));
            const g = Math.floor(parseInt(matches[2]) * (1 - amount));
            const b = Math.floor(parseInt(matches[3]) * (1 - amount));
            const a = matches[4] !== undefined ? parseFloat(matches[4]) : 1;

            return `rgba(${r}, ${g}, ${b}, ${a})`;
        }

        /**
         * Calculate scaled font size for question markers based on number of digits
         * Ensures text fits within the circle regardless of question number
         *
         * @param {number} questionNumber - The question number to display
         * @param {number} baseFontSize - Base font size for this level
         * @param {number} radius - Circle radius for this level
         * @returns {number} Scaled font size in pixels
         */
        function getScaledFontSize(questionNumber, baseFontSize, radius) {
            const numDigits = questionNumber.toString().length;

            // Scale factor: reduce font size by ~15% per additional digit
            // This is empirically tuned to keep text within circle bounds
            const scaleFactor = Math.pow(0.85, numDigits - 1);

            // Calculate scaled font size
            let fontSize = baseFontSize * scaleFactor;

            // Enforce minimum readable size (4px)
            fontSize = Math.max(4, fontSize);

            // Ensure text width fits within circle diameter
            // Approximate: each digit is ~0.6 * fontSize wide
            const estimatedTextWidth = numDigits * 0.6 * fontSize;
            const maxWidth = radius * 2 * 0.8; // 80% of diameter for padding

            if (estimatedTextWidth > maxWidth) {
                fontSize = (maxWidth / (numDigits * 0.6));
            }

            return Math.round(fontSize);
        }

        function drawWikipediaArticles(width, height) {
            // Render articles in extended region (includes articles outside [0,1] for context)
            wikipediaArticles.forEach((article, idx) => {
                const x = article.x;
                const y = article.y;

                // Skip articles outside the extended region [-0.5, 1.5]
                // (matches the filtering in export script)
                if (x < -0.5 || x > 1.5 || y < -0.5 || y > 1.5) {
                    return;
                }

                const baseX = x * width;
                const baseY = y * height;

                // Get animation progress for this article (0 = not hovered, 1 = fully hovered)
                const animProgress = articleAnimationProgress[idx] || 0;

                // Get level-specific parameters (default to level 0 if undefined)
                const level = article.level !== undefined ? article.level : 0;
                const params = ARTICLE_PARAMS[level] || ARTICLE_PARAMS[0];

                // When hovered, grow proportionally to base radius
                const radius = params.baseRadius + (params.baseRadius * animProgress);

                // Interpolate alpha based on hover state
                const alpha = params.baseAlpha + (params.hoverAlpha - params.baseAlpha) * animProgress;

                // Draw article dot (black)
                ctx.beginPath();
                ctx.arc(baseX, baseY, radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(0, 0, 0, ${alpha})`;
                ctx.fill();
            });
        }

        function drawQuestionMarkers(width, height) {
            // Debug: Log first 5 questions to verify levels
            if (questionsData.length > 0 && !window.questionLevelsLogged) {
                console.log('DEBUG: Question levels (first 5):');
                questionsData.slice(0, 5).forEach((q, idx) => {
                    console.log(`  Question ${idx + 1}: level=${q.level}, x=${q.x?.toFixed(3)}, y=${q.y?.toFixed(3)}`);
                });
                window.questionLevelsLogged = true;
            }

            questionsData.forEach((q, idx) => {
                const baseX = q.x * width;
                const baseY = q.y * height;

                // Get level-specific parameters (default to level 0 if undefined)
                const level = q.level !== undefined ? q.level : 0;
                const params = QUESTION_PARAMS[level] || QUESTION_PARAMS[0];
                const radius = params.radius;

                // Debug: Log first few question parameters
                if (idx < 5 && !window.questionParamsLogged) {
                    console.log(`  Question ${idx + 1}: level=${level}, radius=${radius}, baseFontSize=${params.baseFontSize}`);
                    if (idx === 4) window.questionParamsLogged = true;
                }

                const wasAnswered = userResponses[idx] !== undefined;
                const isSkipped = userResponses[idx] === -1 || q.skipped;
                const isCorrect = userResponses[idx] === q.correctIndex;

                // Get animation progress for this dot (0 = not hovered, 1 = fully hovered)
                const animProgress = dotAnimationProgress[idx] || 0;

                // Calculate hover offset (3px up and right when fully hovered)
                const offsetX = 3 * animProgress;
                const offsetY = -3 * animProgress;
                const currentX = baseX + offsetX;
                const currentY = baseY + offsetY;

                let baseColor;
                if (!wasAnswered) {
                    // Unanswered - intermediate knowledge (goldenrod)
                    baseColor = 'rgb(218, 165, 32)';
                } else if (isSkipped) {
                    // "I Don't Know" - yellow
                    baseColor = 'rgb(255, 193, 7)';
                } else if (isCorrect) {
                    // Correct - high knowledge (Dartmouth Green)
                    baseColor = 'rgb(0, 105, 62)';
                } else {
                    // Incorrect - low knowledge (saddle brown)
                    baseColor = 'rgb(139, 69, 19)';
                }

                // Darken color when hovered
                const color = animProgress > 0 ? darkenColor(baseColor, 0.2 * animProgress) : baseColor;

                // Draw drop shadow at original position when hovered
                if (animProgress > 0) {
                    const shadowRadius = radius + (2 * animProgress);
                    ctx.save();
                    ctx.shadowColor = `rgba(0, 0, 0, ${0.15 * animProgress})`; // Very low alpha for soft edges
                    ctx.shadowBlur = 50 * animProgress; // Extra large blur radius for very diffuse, soft shadows
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;

                    ctx.beginPath();
                    ctx.arc(baseX, baseY, shadowRadius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(0, 0, 0, ${0.1 * animProgress})`; // Very low fill alpha for soft appearance
                    ctx.fill();
                    ctx.restore();
                }

                // Draw marker with white border (at current position with offset)
                ctx.beginPath();
                ctx.arc(currentX, currentY, radius + 2, 0, Math.PI * 2);
                ctx.fillStyle = 'white';
                ctx.fill();

                ctx.beginPath();
                ctx.arc(currentX, currentY, radius, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();

                // Draw question number with adaptive font size
                const questionNumber = idx + 1;
                const fontSize = getScaledFontSize(questionNumber, params.baseFontSize, radius);

                ctx.fillStyle = 'white';
                ctx.font = `bold ${fontSize}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(questionNumber.toString(), currentX, currentY);
            });
        }

        function getHeatmapCell(mouseX, mouseY, width, height) {
            const gridSize = 40;
            const cellWidth = width / (gridSize - 1);
            const cellHeight = height / (gridSize - 1);

            const gx = Math.floor(mouseX / cellWidth);
            const gy = Math.floor(mouseY / cellHeight);

            if (gx >= 0 && gx < gridSize - 1 && gy >= 0 && gy < gridSize - 1) {
                // Return cell center in normalized coordinates
                const centerX = (gx + 0.5) / (gridSize - 1);
                const centerY = (gy + 0.5) / (gridSize - 1);
                return { gx, gy, centerX, centerY };
            }
            return null;
        }

        function showHeatmapTooltip(canvasRect, cell) {
            // Find cell label if available
            let label = 'Unknown Region';
            if (cellLabelsData) {
                const cellData = cellLabelsData.find(c =>
                    Math.abs(c.center_x - cell.centerX) < 0.001 &&
                    Math.abs(c.center_y - cell.centerY) < 0.001
                );
                if (cellData && cellData.label) {
                    label = cellData.label;
                }
            }

            // Calculate knowledge percentage and convert to categorical label
            const knowledgePct = calculateCellKnowledge(cell.centerX, cell.centerY);
            const knowledgeLabel = knowledgePercentToLabel(knowledgePct);
            const knowledgeValue = knowledgePct / 100; // Normalize to [0, 1] for colormap

            // Get background color from custom colormap
            const bgColor = mapToColor(knowledgeValue);

            tooltip.innerHTML = `
                <div class="tooltip-question">${label}</div>
                <div class="tooltip-status">
                    <span>Inferred Knowledge: ${knowledgeLabel}</span>
                </div>
            `;

            // Apply colormap background color
            tooltip.style.backgroundColor = bgColor;

            tooltip.classList.remove('tooltip-hidden');
            setTimeout(() => tooltip.classList.add('visible'), 10);

            // Calculate cell center position on screen
            const cellCanvasX = cell.centerX * canvasRect.width;
            const cellCanvasY = cell.centerY * canvasRect.height;
            const cellScreenX = canvasRect.left + cellCanvasX;
            const cellScreenY = canvasRect.top + cellCanvasY;

            // Get tooltip dimensions
            const tooltipRect = tooltip.getBoundingClientRect();
            const offset = 15;

            // Determine quadrant based on normalized position
            const isLeftHalf = cell.centerX < 0.5;
            const isTopHalf = cell.centerY < 0.5;

            let left, top;

            // Position tooltip based on quadrant
            if (isLeftHalf) {
                left = cellScreenX + offset;
            } else {
                left = cellScreenX - tooltipRect.width - offset;
            }

            if (isTopHalf) {
                top = cellScreenY + offset;
            } else {
                top = cellScreenY - tooltipRect.height - offset;
            }

            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }

        function addInteractivity(width, height) {
            // Only add event listeners once to prevent duplicates
            if (canvas.dataset.interactivityInitialized) {
                return;
            }
            canvas.dataset.interactivityInitialized = 'true';

            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = (e.clientX - rect.left) / rect.width * width;
                const mouseY = (e.clientY - rect.top) / rect.height * height;

                // Check for question dot hover (highest priority)
                let hoveredQuestion = null;
                questionsData.forEach((q, idx) => {
                    const x = q.x * width;
                    const y = q.y * height;
                    const dist = Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2);

                    if (dist < 15) {
                        hoveredQuestion = { ...q, index: idx };
                    }
                });

                if (hoveredQuestion) {
                    // Question dot takes priority
                    hoveredDotIndex = hoveredQuestion.index;
                    hoveredArticleIndex = null;
                    hoveredHeatmapCell = null;
                    showTooltip(rect, hoveredQuestion);
                    canvas.style.cursor = 'pointer';
                    startAnimation();
                } else {
                    // Check for Wikipedia article hover (second priority)
                    let hoveredArticle = null;
                    wikipediaArticles.forEach((article, idx) => {
                        // Skip articles outside extended region
                        if (article.x < -0.5 || article.x > 1.5 || article.y < -0.5 || article.y > 1.5) {
                            return;
                        }

                        const x = article.x * width;
                        const y = article.y * height;
                        const dist = Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2);

                        // Use larger hover radius for easier interaction
                        if (dist < 8) {
                            hoveredArticle = { ...article, index: idx };
                        }
                    });

                    if (hoveredArticle) {
                        // Wikipedia article hover
                        hoveredDotIndex = null;
                        hoveredArticleIndex = hoveredArticle.index;
                        hoveredHeatmapCell = null;
                        showArticleTooltip(rect, hoveredArticle);
                        canvas.style.cursor = 'pointer';
                        startAnimation();
                    } else {
                        // Check for heatmap cell hover (lowest priority)
                        const cell = getHeatmapCell(mouseX, mouseY, width, height);

                        if (cell) {
                            hoveredDotIndex = null;
                            hoveredArticleIndex = null;
                            hoveredHeatmapCell = cell;
                            showHeatmapTooltip(rect, cell);
                            canvas.style.cursor = 'crosshair';
                            redrawCanvas(); // Immediate redraw to darken heatmap cell
                            startAnimation(); // Also ensure dots animate back if they were hovered
                        } else {
                            hoveredDotIndex = null;
                            hoveredArticleIndex = null;
                            hoveredHeatmapCell = null;
                            hideTooltip();
                            canvas.style.cursor = 'default';
                            redrawCanvas(); // Immediate redraw to un-darken heatmap cells
                            startAnimation(); // Animate dots back to normal
                        }
                    }
                }
            });

            canvas.addEventListener('mouseleave', () => {
                hoveredDotIndex = null;
                hoveredArticleIndex = null;
                hoveredHeatmapCell = null;
                hideTooltip();
                startAnimation();
            });

            // Add click handler for Wikipedia articles
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = (e.clientX - rect.left) / rect.width * width;
                const mouseY = (e.clientY - rect.top) / rect.height * height;

                // First, check if hovering over a question dot - if so, don't handle article clicks
                let hoveringQuestion = false;
                questionsData.forEach((q, idx) => {
                    const x = q.x * width;
                    const y = q.y * height;
                    const dist = Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2);
                    if (dist < 15) {
                        hoveringQuestion = true;
                    }
                });

                // If hovering over a question, don't process article clicks
                if (hoveringQuestion) {
                    return;
                }

                // Prefer the currently hovered article if one is being shown
                let clickedArticle = null;

                if (hoveredArticleIndex !== null && hoveredArticleIndex >= 0 && hoveredArticleIndex < wikipediaArticles.length) {
                    // Use the hovered article (whose tooltip is currently shown)
                    clickedArticle = wikipediaArticles[hoveredArticleIndex];
                } else {
                    // No hovered article - find closest one within threshold
                    let minDist = 8; // Threshold distance

                    wikipediaArticles.forEach((article, idx) => {
                        // Skip articles outside extended region
                        if (article.x < -0.5 || article.x > 1.5 || article.y < -0.5 || article.y > 1.5) {
                            return;
                        }

                        const x = article.x * width;
                        const y = article.y * height;
                        const dist = Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2);

                        // Only select if closer than current closest (prevents multiple opens)
                        if (dist < minDist) {
                            minDist = dist;
                            clickedArticle = article;
                        }
                    });
                }

                // Open Wikipedia article in new tab
                if (clickedArticle && clickedArticle.url) {
                    window.open(clickedArticle.url, '_blank');
                }
            });
        }

        function showTooltip(canvasRect, question) {
            const wasAnswered = userResponses[question.index] !== undefined;
            const isSkipped = userResponses[question.index] === -1 || question.skipped;
            const isCorrect = userResponses[question.index] === question.correctIndex;

            // Display question number (simple index, no offset needed since questionsData contains all questions via swap)
            const displayQuestionNumber = question.index + 1;

            let status, statusColor;
            if (!wasAnswered) {
                status = 'Unanswered';
                statusColor = 'rgb(218, 165, 32)';  // Intermediate knowledge (goldenrod)
            } else if (isSkipped) {
                status = "I Don't Know";
                statusColor = 'rgb(255, 193, 7)';  // Yellow
            } else if (isCorrect) {
                status = 'Correct';
                statusColor = 'rgb(0, 105, 62)';  // High knowledge (Dartmouth Green)
            } else {
                status = 'Incorrect';
                statusColor = 'rgb(139, 69, 19)';  // Low knowledge (saddle brown)
            }

            tooltip.innerHTML = `
                <div class="tooltip-question">Q${displayQuestionNumber}: ${question.question}</div>
                <div class="tooltip-status">
                    <div class="tooltip-dot" style="background: ${statusColor};"></div>
                    <span>${status}</span>
                </div>
            `;

            // Reset background to default black for question tooltips
            tooltip.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';

            tooltip.classList.remove('tooltip-hidden');
            setTimeout(() => tooltip.classList.add('visible'), 10);

            // Calculate dot position on screen
            const dotCanvasX = question.x * canvasRect.width;
            const dotCanvasY = question.y * canvasRect.height;
            const dotScreenX = canvasRect.left + dotCanvasX;
            const dotScreenY = canvasRect.top + dotCanvasY;

            // Get tooltip dimensions
            const tooltipRect = tooltip.getBoundingClientRect();
            const offset = 15;  // Offset from dot (in pixels)

            // Determine quadrant based on normalized position (0-1 range)
            // This ensures tooltips stay within heatmap bounds
            const isLeftHalf = question.x < 0.5;
            const isTopHalf = question.y < 0.5;

            let left, top;

            // Position tooltip based on quadrant
            if (isLeftHalf) {
                // Dot is on left side - show tooltip to the right
                left = dotScreenX + offset;
            } else {
                // Dot is on right side - show tooltip to the left
                left = dotScreenX - tooltipRect.width - offset;
            }

            if (isTopHalf) {
                // Dot is on top half - show tooltip below
                top = dotScreenY + offset;
            } else {
                // Dot is on bottom half - show tooltip above
                top = dotScreenY - tooltipRect.height - offset;
            }

            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }

        function showArticleTooltip(canvasRect, article) {
            // Calculate knowledge percentage and convert to categorical label
            const knowledgePct = calculateCellKnowledge(article.x, article.y);
            const knowledgeLabel = knowledgePercentToLabel(knowledgePct);
            const knowledgeValue = knowledgePct / 100; // Normalize to [0, 1] for colormap

            // Get background color from custom colormap
            const bgColor = mapToColor(knowledgeValue);

            // Display article title, excerpt, and knowledge
            tooltip.innerHTML = `
                <div class="tooltip-question">${article.title}</div>
                <div class="tooltip-status">
                    <span>${article.excerpt}</span>
                    <br>
                    <span>Inferred Knowledge: ${knowledgeLabel}</span>
                </div>
            `;

            // Apply colormap background color
            tooltip.style.backgroundColor = bgColor;

            tooltip.classList.remove('tooltip-hidden');
            setTimeout(() => tooltip.classList.add('visible'), 10);

            // Calculate article position on screen
            const articleCanvasX = article.x * canvasRect.width;
            const articleCanvasY = article.y * canvasRect.height;
            const articleScreenX = canvasRect.left + articleCanvasX;
            const articleScreenY = canvasRect.top + articleCanvasY;

            // Get tooltip dimensions
            const tooltipRect = tooltip.getBoundingClientRect();
            const offset = 15;  // Offset from dot (in pixels)

            // Determine quadrant based on normalized position (0-1 range)
            const isLeftHalf = article.x < 0.5;
            const isTopHalf = article.y < 0.5;

            let left, top;

            // Position tooltip based on quadrant to avoid overlap
            if (isLeftHalf) {
                // Article is on left side - show tooltip to the right
                left = articleScreenX + offset;
            } else {
                // Article is on right side - show tooltip to the left
                left = articleScreenX - tooltipRect.width - offset;
            }

            if (isTopHalf) {
                // Article is on top half - show tooltip below
                top = articleScreenY + offset;
            } else {
                // Article is on bottom half - show tooltip above
                top = articleScreenY - tooltipRect.height - offset;
            }

            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }

        function hideTooltip() {
            tooltip.classList.remove('visible');
            setTimeout(() => {
                tooltip.classList.add('tooltip-hidden');
                // Reset background to default when hiding
                tooltip.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
            }, 200); // Match CSS transition duration
        }

        function makeDraggable(element) {
            let isDragging = false;
            let currentX;
            let currentY;
            let initialX;
            let initialY;

            element.addEventListener('mousedown', (e) => {
                // Only start drag if clicking on the element itself, not child elements
                isDragging = true;
                element.classList.add('dragging');

                initialX = e.clientX - element.offsetLeft;
                initialY = e.clientY - element.offsetTop;

                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    e.preventDefault();

                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;

                    // Get parent container bounds
                    const parent = element.parentElement;
                    const parentRect = parent.getBoundingClientRect();
                    const elementRect = element.getBoundingClientRect();

                    // Constrain within parent bounds
                    const maxX = parentRect.width - elementRect.width;
                    const maxY = parentRect.height - elementRect.height;

                    currentX = Math.max(0, Math.min(currentX, maxX));
                    currentY = Math.max(0, Math.min(currentY, maxY));

                    // Update position (remove any existing top/bottom/left/right)
                    element.style.top = currentY + 'px';
                    element.style.left = currentX + 'px';
                    element.style.right = 'auto';
                    element.style.bottom = 'auto';
                }
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    element.classList.remove('dragging');
                }
            });
        }

        function startAnotherRound() {
            // Check if there are any questions left
            if (adaptiveSampler) {
                const availableQuestions = adaptiveSampler._getAvailableQuestions();
                if (availableQuestions.length === 0) {
                    alert('All questions have been asked! No more questions available.');
                    anotherRoundBtn.disabled = true;
                    return;
                }
            }

            // Reset Show Map button color when starting a new round
            showMapBtn.classList.remove('high-confidence');

            // Hide map, show quiz
            mapSection.classList.add('hidden');
            quizSection.classList.remove('hidden');
            hideTooltip();

            // Start a new quiz round with new questions
            startNewQuizRound();
        }

        function restart() {
            // Simply reload the page to fully reset all state
            location.reload();
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            if (!mapSection.classList.contains('hidden')) {
                // Use history version if we have accumulated questions, otherwise regular version
                if (allQuestionsShown.length > 0) {
                    generateKnowledgeMapWithHistory();
                } else {
                    generateKnowledgeMap();
                }
            }
        });
    </script>
</body>
</html>
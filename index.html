<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Knowledge Map Demo - Heatmap Visualization</title>
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #00693E 0%, #004d2c 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            width: 100%;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 80px rgba(0, 0, 0, 0.5);
            border: 3px solid rgba(255, 255, 255, 0.2);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #00693E 0%, #004d2c 100%);
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
        }

        .header h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .btn-about {
            position: absolute;
            top: 30px;
            right: 30px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-about:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-2px);
        }

        .btn-about i {
            font-size: 1.1em;
        }

        .content {
            padding: 40px;
        }

        .question-section {
            margin-bottom: 30px;
        }

        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .question-number {
            font-size: 0.9em;
            color: #00693E;
            font-weight: 600;
            display: none; /* Hidden per issue #4 */
        }

        .confidence-display {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border: 2px solid #00693E;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .confidence-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .confidence-label {
            font-size: 0.95em;
            font-weight: 600;
            color: #333;
        }

        .confidence-value {
            font-size: 1.1em;
            font-weight: 700;
            color: #00693E;
        }

        .confidence-bar {
            height: 8px;
            background: #dee2e6;
            border-radius: 4px;
            overflow: visible;
            margin-bottom: 28px;
            position: relative;
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #00693E 0%, #00a859 100%);
            width: 0%;
            transition: width 0.5s ease;
        }

        .confidence-threshold {
            position: absolute;
            left: 90%;
            top: -8px;
            bottom: -8px;
            width: 2px;
            background: #333;
            z-index: 10;
        }

        .confidence-threshold::after {
            content: 'High Confidence';
            position: absolute;
            bottom: -22px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75em;
            color: #333;
            white-space: nowrap;
            font-weight: 600;
        }

        .confidence-message {
            font-size: 0.85em;
            color: #666;
            margin: 0;
            text-align: center;
            display: none; /* Hidden per issue #5 */
        }

        .question-text {
            font-size: 1.3em;
            color: #333;
            margin-bottom: 25px;
            line-height: 1.6;
        }

        .options {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .option {
            padding: 18px 24px;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.05em;
            display: flex;
            align-items: center;
        }

        .option:hover {
            border-color: #00693E;
            background: #e8f5f1;
            transform: translateX(5px);
        }

        .option.selected {
            border-color: #00693E;
            background: #e8f5f1;
        }

        .option-label {
            display: inline-block;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: #00693E;
            color: white;
            text-align: center;
            line-height: 30px;
            margin-right: 15px;
            font-weight: 600;
            flex-shrink: 0;
        }

        .button-container {
            display: flex;
            gap: 15px;
            margin-top: 30px;
        }

        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 1.05em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            flex: 1;
        }

        .btn-primary {
            background: #dee2e6;
            color: #333;
        }

        .btn-primary:hover:not(:disabled) {
            background: #ced4da;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(108, 117, 125, 0.3);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #dee2e6;
            color: #333;
        }

        .btn-secondary:hover {
            background: #ced4da;
        }

        .btn-info {
            background: #dee2e6;
            color: #333;
        }

        .btn-info:hover:not(:disabled) {
            background: #ced4da;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(108, 117, 125, 0.3);
        }

        .btn-info:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-info.high-confidence {
            background: linear-gradient(135deg, #00693E, #004d2c);
            color: white;
        }

        .btn-info.high-confidence:hover:not(:disabled) {
            background: linear-gradient(135deg, #004d2c, #003520);
            box-shadow: 0 5px 15px rgba(0, 105, 62, 0.4);
        }

        .btn-skip {
            background: #dee2e6;
            color: #333;
            font-weight: 600;
        }

        .btn-skip:hover {
            background: #ced4da;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(108, 117, 125, 0.3);
        }

        .map-container {
            width: 100%;
            height: 700px;
            background: #f8f9fa;
            border-radius: 12px;
            position: relative;
            overflow: hidden;
        }

        .map-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .map-header h2 {
            font-size: 1.8em;
            color: #333;
            margin-bottom: 10px;
        }

        .map-header p {
            color: #666;
            font-size: 1.05em;
        }

        #map-canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 10;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #00693E;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 12px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: 700;
            color: #00693E;
        }

        .stat-label {
            color: #666;
            margin-top: 5px;
        }

        .hidden {
            display: none;
        }


        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.8);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            font-size: 0.9em;
            z-index: 5;
            cursor: move;
            user-select: none;
            transition: box-shadow 0.2s ease;
        }

        .legend:hover {
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        .legend.dragging {
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.3);
            cursor: grabbing;
        }

        .legend h4 {
            margin-bottom: 10px;
            color: #333;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .legend-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-right: 8px;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .colorbar {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.8);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 5;
            cursor: move;
            user-select: none;
            transition: box-shadow 0.2s ease;
        }

        .colorbar:hover {
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        .colorbar.dragging {
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.3);
            cursor: grabbing;
        }

        .colorbar h4 {
            margin-bottom: 8px;
            font-size: 0.9em;
            color: #333;
        }

        .colorbar-gradient {
            width: 200px;
            height: 20px;
            background: linear-gradient(to right,
                rgba(139, 69, 19, 0.8),
                rgba(184, 134, 11, 0.8),
                rgba(218, 165, 32, 0.8),
                rgba(0, 133, 66, 0.8),
                rgba(0, 105, 62, 0.8)
            );
            border-radius: 4px;
        }

        .colorbar-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.8em;
            color: #666;
            margin-top: 5px;
        }

        .tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 0.9em;
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            opacity: 0;
            transition: opacity 200ms ease-in-out;
        }

        .tooltip.visible {
            opacity: 1;
        }

        .tooltip-hidden {
            display: none;
        }

        .tooltip-question {
            font-weight: 600;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
        }

        .tooltip-status {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tooltip-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        @media (max-width: 768px) {
            .content {
                padding: 20px;
            }

            .header h1 {
                font-size: 1.5em;
            }

            .question-text {
                font-size: 1.1em;
            }

            .map-container {
                height: 400px;
            }

            .stats {
                flex-direction: column;
                gap: 20px;
            }

            .legend, .colorbar {
                font-size: 0.8em;
                padding: 10px;
            }

            .colorbar-gradient {
                width: 150px;
            }
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Introduction Screen */
        .intro-section {
            text-align: center;
            padding: 60px 40px;
        }

        .intro-section h1 {
            font-size: 2.5em;
            color: #00693E;
            margin-bottom: 20px;
        }

        .intro-description {
            font-size: 1.2em;
            color: #666;
            line-height: 1.8;
            max-width: 700px;
            margin: 0 auto 40px;
        }

        .intro-instructions {
            max-width: 600px;
            margin: 0 auto 40px;
            text-align: left;
            background: #f8f9fa;
            padding: 30px;
            border-radius: 12px;
        }

        .intro-instructions h3 {
            font-size: 1.3em;
            color: #333;
            margin-bottom: 15px;
        }

        .intro-instructions ol {
            font-size: 1.1em;
            color: #666;
            line-height: 2;
            padding-left: 25px;
        }

        .intro-instructions li {
            margin-bottom: 10px;
        }

        /* About Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2000;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .modal.hidden {
            display: none !important;
        }

        .modal-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
        }

        .modal-content {
            position: relative;
            background: white;
            border-radius: 16px;
            max-width: 700px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            z-index: 2001;
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-30px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .modal-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: transparent;
            border: none;
            font-size: 1.5em;
            color: #999;
            cursor: pointer;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close:hover {
            background: #f0f0f0;
            color: #333;
        }

        .modal-content h2 {
            font-size: 2em;
            color: #00693E;
            margin-bottom: 30px;
        }

        .about-section {
            margin-bottom: 35px;
        }

        .about-section h3 {
            font-size: 1.4em;
            color: #333;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e0e0e0;
        }

        .about-link {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 15px;
            margin: 6px 0;
            border-radius: 8px;
            text-decoration: none;
            color: #333;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .about-link:hover {
            background: #f8f9fa;
            border-color: #00693E;
            transform: translateX(5px);
        }

        .link-logo {
            height: 24px;
            width: auto;
            flex-shrink: 0;
        }

        .citation {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            font-size: 0.95em;
            line-height: 1.8;
            color: #555;
            margin: 15px 0;
            position: relative;
        }

        .citation strong {
            color: #333;
        }

        .citation-text {
            margin-bottom: 15px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .copy-citation-btn {
            background: #00693E;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .copy-citation-btn:hover {
            background: #004d2c;
            transform: translateY(-1px);
        }

        .copy-citation-btn.copied {
            background: #28a745;
        }

        .note {
            font-size: 0.9em;
            color: #888;
            font-style: italic;
            margin-top: 10px;
        }

        /* Contact Form */
        .contact-form {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .form-group {
            margin-bottom: 18px;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 18px;
        }

        .form-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: 600;
            color: #333;
            font-size: 0.95em;
        }

        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 1em;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            transition: border-color 0.2s ease;
        }

        .form-group input:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #00693E;
        }

        .form-group textarea {
            resize: vertical;
            min-height: 120px;
        }

        .form-submit-btn {
            background: #00693E;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .form-submit-btn:hover {
            background: #004d2c;
            transform: translateY(-1px);
        }

        .form-submit-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .contact-info {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
            line-height: 1.8;
        }

        .contact-info p {
            margin: 4px 0;
            color: #555;
        }

        .contact-info strong {
            color: #00693E;
            display: block;
            margin-bottom: 8px;
            font-size: 1.05em;
        }

        .contact-info a {
            color: #00693E;
            text-decoration: none;
        }

        .contact-info a:hover {
            text-decoration: underline;
        }

        /* Responsive Adjustments */
        @media (max-width: 768px) {
            .btn-about {
                top: 20px;
                right: 20px;
                padding: 8px 16px;
                font-size: 0.9em;
            }

            .intro-section {
                padding: 40px 20px;
            }

            .intro-section h1 {
                font-size: 1.8em;
            }

            .intro-instructions {
                padding: 20px;
            }

            .modal-content {
                padding: 30px 20px;
                max-height: 90vh;
            }

            .modal-content h2 {
                font-size: 1.6em;
                margin-bottom: 20px;
            }

            .about-link {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }

            .link-logo {
                height: 20px;
            }

            .form-row {
                grid-template-columns: 1fr;
                gap: 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1><i class="fas fa-brain"></i> Knowledge Map Explorer</h1>
            <p>Answer questions to visualize your conceptual understanding</p>
            <button class="btn-about" id="about-btn">
                <i class="fas fa-info-circle"></i> About
            </button>
        </div>

        <div class="content">
            <!-- Introduction Section -->
            <div id="intro-section" class="intro-section">
                <h1>Welcome!</h1>
                <p class="intro-description">
                    This interactive demo maps out an approximation of your knowledge across all topics,
                    using Wikipedia as a reference and LLM text embeddings to define a coordinate system for the map.
                    Answer quiz questions to visualize your conceptual understanding in a 2D semantic space.
                </p>
                <div class="intro-instructions">
                    <h3>How it works:</h3>
                    <ol>
                        <li>Answer questions about various topics at your own pace</li>
                        <li>View your personalized 2D knowledge map</li>
                        <li>Explore areas of strength and opportunities to learn</li>
                    </ol>
                </div>
                <button class="btn btn-primary" id="start-quiz-btn">
                    Start Quiz <i class="fas fa-play"></i>
                </button>
            </div>

            <!-- Quiz Section -->
            <div id="quiz-section" class="quiz-section hidden">
                <div class="question-section fade-in" id="question-container">
                    <div class="question-header">
                        <span class="question-number" id="question-number">Question 1 of 10</span>
                    </div>

                    <!-- Confidence Display (for adaptive sampling) -->
                    <div class="confidence-display hidden" id="confidence-display">
                        <div class="confidence-header">
                            <span class="confidence-label">Map Coverage Confidence</span>
                            <span class="confidence-value" id="confidence-value">0%</span>
                        </div>
                        <div class="confidence-bar">
                            <div class="confidence-fill" id="confidence-fill"></div>
                            <div class="confidence-threshold"></div>
                        </div>
                        <p class="confidence-message" id="confidence-message">Answer more questions to build confidence...</p>
                    </div>

                    <div class="question-text" id="question-text"></div>
                    <div class="options" id="options-container"></div>
                </div>

                <div class="button-container">
                    <button class="btn btn-secondary hidden" id="prev-btn"><i class="fas fa-arrow-left"></i> Previous</button>
                    <button class="btn btn-skip" id="dont-know-btn"><i class="fas fa-question-circle"></i> I Don't Know</button>
                    <button class="btn btn-info" id="show-map-btn"><i class="fas fa-map"></i> Show Map</button>
                    <button class="btn btn-primary" id="next-btn" disabled>Next <i class="fas fa-arrow-right"></i></button>
                </div>
            </div>

            <!-- Map Section -->
            <div id="map-section" class="map-section hidden">
                <div class="map-header">
                    <h2>Your Knowledge Map</h2>
                    <p>Hover to explore your knowledge map</p>
                </div>

                <!-- Confidence Display (also shown on map when adaptive sampling is active) -->
                <div class="confidence-display hidden" id="map-confidence-display">
                    <div class="confidence-header">
                        <span class="confidence-label">Map Coverage Confidence</span>
                        <span class="confidence-value" id="map-confidence-value">0%</span>
                    </div>
                    <div class="confidence-bar">
                        <div class="confidence-fill" id="map-confidence-fill"></div>
                        <div class="confidence-threshold"></div>
                    </div>
                    <p class="confidence-message" id="map-confidence-message">Answer more questions to build confidence...</p>
                </div>

                <div class="map-container">
                    <canvas id="map-canvas"></canvas>
                    
                    <div class="legend">
                        <h4>Legend</h4>
                        <div class="legend-item">
                            <div class="legend-dot" style="background: rgb(0, 105, 62);"></div>
                            <span>Correct response</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-dot" style="background: rgb(255, 193, 7);"></div>
                            <span>Skipped/Unsure</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-dot" style="background: rgb(139, 69, 19);"></div>
                            <span>Incorrect response</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-dot" style="background: rgba(0, 0, 0, 0.1); border: 1px solid rgba(0, 0, 0, 0.3); width: 6px; height: 6px; margin-left: 5px; margin-right: 13px;"></div>
                            <span>Wikipedia article</span>
                        </div>
                    </div>

                    <div class="colorbar">
                        <h4>Inferred Knowledge</h4>
                        <div class="colorbar-gradient"></div>
                        <div class="colorbar-labels">
                            <span>Low</span>
                            <span>High</span>
                        </div>
                    </div>

                    <div class="tooltip tooltip-hidden" id="tooltip"></div>
                    
                    <div class="loading hidden" id="loading">
                        <div class="spinner"></div>
                        <p>Generating your knowledge map...</p>
                    </div>
                </div>

                <!-- Hidden stats elements (kept for JavaScript compatibility) -->
                <div class="stats hidden">
                    <div class="stat-item">
                        <div class="stat-value" id="correct-count">0</div>
                        <div class="stat-label">Correct</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="accuracy-pct">0%</div>
                        <div class="stat-label">Accuracy</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="total-count">10</div>
                        <div class="stat-label">Total Questions</div>
                    </div>
                </div>

                <div class="button-container">
                    <button class="btn btn-primary" id="another-round-btn"><i class="fas fa-play"></i> Answer More Questions</button>
                    <button class="btn btn-secondary" id="restart-btn"><i class="fas fa-rotate-right"></i> Start Over</button>
                </div>
            </div>
        </div>
    </div>

    <!-- About Modal -->
    <div id="about-modal" class="modal hidden">
        <div class="modal-backdrop"></div>
        <div class="modal-content">
            <button class="modal-close" id="close-about" aria-label="Close">
                <i class="fas fa-times"></i>
            </button>

            <h2>About This Project</h2>

            <section class="about-section">
                <h3>Research Paper</h3>
                <a href="https://osf.io/preprints/psyarxiv/dh3q2_v2" target="_blank" rel="noopener noreferrer" class="about-link">
                    <img src="logos/nature.png" alt="Nature Communications logo" class="link-logo">
                    <span>Text embedding models yield high-resolution insights into conceptual knowledge</span>
                </a>
                <div class="citation">
                    <div class="citation-text" id="citation-text">
                        Fitzpatrick, P. C., Heusser, A. C., & Manning, J. R. (2025). Text embedding models yield high-resolution insights into conceptual knowledge from short multiple-choice quizzes. <em>Nature Communications</em>: In press.
                    </div>
                    <button class="copy-citation-btn" id="copy-citation-btn">
                        <i class="fas fa-copy"></i> Copy Citation
                    </button>
                </div>
                <p class="note">
                    Note: This paper is currently in press. The link above leads to the preprint version. Once published in Nature Communications, this link will be updated with the official DOI.
                </p>
            </section>

            <section class="about-section">
                <h3>Related Resources</h3>
                <a href="https://github.com/ContextLab/efficient-learning-khan" target="_blank" rel="noopener noreferrer" class="about-link">
                    <img src="logos/github.svg" alt="GitHub logo" class="link-logo">
                    <span>Khan Academy Efficient Learning Repository</span>
                </a>
                <a href="https://www.nsf.gov/awardsearch/show-award/?AWD_ID=2145172&HistoricalAwards=false" target="_blank" rel="noopener noreferrer" class="about-link">
                    <img src="logos/nsf.png" alt="National Science Foundation logo" class="link-logo">
                    <span>NSF Award #2145172 - Supporting this research</span>
                </a>
                <a href="https://context-lab.com" target="_blank" rel="noopener noreferrer" class="about-link">
                    <img src="logos/cdl.png" alt="Context Lab logo" class="link-logo">
                    <span>Context Dynamics Lab at Dartmouth College</span>
                </a>
            </section>

            <section class="about-section">
                <h3>Contact</h3>

                <div class="contact-info">
                    <strong>Contextual Dynamics Lab</strong>
                    <p>Department of Psychological and Brain Sciences</p>
                    <p>Dartmouth College</p>
                    <p>349 Moore Hall, HB 6207</p>
                    <p>Hanover, NH 03755</p>
                    <p style="margin-top: 12px;">
                        <a href="mailto:contextualdynamics@gmail.com">contextualdynamics@gmail.com</a><br>
                        <a href="tel:6036460070">603.646.0070</a>
                    </p>
                </div>

                <form class="contact-form" id="contact-form">
                    <div class="form-row">
                        <div class="form-group">
                            <label for="contact-first-name">First Name *</label>
                            <input type="text" id="contact-first-name" name="firstName" required>
                        </div>
                        <div class="form-group">
                            <label for="contact-last-name">Last Name *</label>
                            <input type="text" id="contact-last-name" name="lastName" required>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="contact-email">Email Address *</label>
                        <input type="email" id="contact-email" name="email" required>
                    </div>
                    <div class="form-group">
                        <label for="contact-subject">Subject *</label>
                        <input type="text" id="contact-subject" name="subject" required>
                    </div>
                    <div class="form-group">
                        <label for="contact-message">Message *</label>
                        <textarea id="contact-message" name="message" required></textarea>
                    </div>
                    <button type="submit" class="form-submit-btn">
                        <i class="fas fa-paper-plane"></i> Send Message
                    </button>
                </form>
            </section>
        </div>
    </div>

    <script>
        // Questions data loaded from external file
        let questionsData = []; // Current round's questions (10 questions)
        let allQuestionsPool = []; // All available questions loaded from JSON
        let cellLabelsData = null; // Cell labels for heatmap tooltips
        let wikipediaArticles = []; // Wikipedia articles with coordinates

        // Application state
        let currentQuestion = 0;
        let userResponses = []; // Current round responses
        let allUserResponses = []; // Full history across all rounds
        let allQuestionsShown = []; // All questions shown across all rounds (for cumulative map display)
        let askedQuestionIndices = []; // Track which questions have been asked
        let currentRound = 0; // Current round number
        let selectedOption = null;

        // Adaptive sampling state
        let cellDistances = null; // Precomputed distance matrix
        let adaptiveSampler = null; // AdaptiveSampler instance
        let cellQuestionsData = null; // Original cell-based questions structure

        // DOM elements
        const introSection = document.getElementById('intro-section');
        const quizSection = document.getElementById('quiz-section');
        const mapSection = document.getElementById('map-section');
        const questionContainer = document.getElementById('question-container');
        const questionNumber = document.getElementById('question-number');
        const questionText = document.getElementById('question-text');
        const optionsContainer = document.getElementById('options-container');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const dontKnowBtn = document.getElementById('dont-know-btn');
        const showMapBtn = document.getElementById('show-map-btn');
        const restartBtn = document.getElementById('restart-btn');
        const anotherRoundBtn = document.getElementById('another-round-btn');
        const startQuizBtn = document.getElementById('start-quiz-btn');
        const aboutBtn = document.getElementById('about-btn');
        const aboutModal = document.getElementById('about-modal');
        const closeAboutBtn = document.getElementById('close-about');
        const copyCitationBtn = document.getElementById('copy-citation-btn');
        const contactForm = document.getElementById('contact-form');
        const confidenceDisplay = document.getElementById('confidence-display');
        const confidenceValue = document.getElementById('confidence-value');
        const confidenceFill = document.getElementById('confidence-fill');
        const confidenceMessage = document.getElementById('confidence-message');
        const canvas = document.getElementById('map-canvas');
        const ctx = canvas.getContext('2d');
        const loading = document.getElementById('loading');
        const tooltip = document.getElementById('tooltip');

        // Hover state for animations
        let hoveredDotIndex = null;
        let hoveredHeatmapCell = null;
        let hoveredArticleIndex = null; // Wikipedia article hover state
        let dotAnimationProgress = {}; // Maps dot index to animation progress (0-1)
        let articleAnimationProgress = {}; // Maps article index to animation progress (0-1)
        let animationFrameId = null;
        let lastFrameTime = performance.now();

        // ====== AdaptiveSampler Class ======
        class AdaptiveSampler {
            constructor(questionsPool, distances, config) {
                this.questionsPool = questionsPool;
                this.distances = distances.distances;  // 2D array
                this.cellKeys = distances.cell_keys;   // Array of "gx_gy" strings
                this.config = {
                    mode: 'adaptive-uncertainty',
                    initialRandomQuestions: 2,
                    minQuestionsBeforeExit: 3,
                    confidenceThreshold: 0.85,
                    maxQuestions: 10,
                    K: 5,
                    sigma: 0.15,
                    alpha: 1.0,
                    beta: 1.0,
                    coverageDistance: 0.15,
                    ...config  // Allow override
                };

                // Build cell index mappings
                this.cellKeyToIndex = {};
                this.indexToCellKey = {};
                this.cellKeys.forEach((key, idx) => {
                    this.cellKeyToIndex[key] = idx;
                    this.indexToCellKey[idx] = key;
                });

                this.allCellKeys = this.cellKeys;

                // State
                this.askedCells = [];
                this.responses = {};  // cellKey â†’ true/false
                this.uncertaintyMap = {};
                this.askedQuestions = new Set();  // Track individual question IDs to prevent re-asking
            }

            // === Phase 1: Infrastructure ===

            _getAvailableQuestions() {
                // Return all questions from cells that haven't been fully exhausted
                const available = [];
                for (const cellData of this.questionsPool.cells) {
                    const cellKey = `${cellData.cell.gx}_${cellData.cell.gy}`;
                    // Include cells even if asked before, but filter individual questions
                    for (let i = 0; i < cellData.questions.length; i++) {
                        const question = cellData.questions[i];
                        const questionId = `${cellKey}_${i}`;
                        // Only include questions that haven't been asked
                        if (!this.askedQuestions.has(questionId)) {
                            available.push({ ...question, cellKey, cellData, questionId });
                        }
                    }
                }
                return available;
            }

            _groupByCell(questions) {
                const grouped = {};
                for (const q of questions) {
                    if (!grouped[q.cellKey]) {
                        grouped[q.cellKey] = [];
                    }
                    grouped[q.cellKey].push(q);
                }
                return grouped;
            }

            _selectRandom(items) {
                return items[Math.floor(Math.random() * items.length)];
            }

            // === Phase 2: Uncertainty Estimation ===

            findKNearestAsked(cellKey, askedCells, K) {
                const cellIdx = this.cellKeyToIndex[cellKey];
                const distances = [];

                for (const askedCell of askedCells) {
                    const askedIdx = this.cellKeyToIndex[askedCell];
                    const dist = this.distances[cellIdx][askedIdx];
                    distances.push({ cellKey: askedCell, distance: dist });
                }

                distances.sort((a, b) => a.distance - b.distance);
                return distances.slice(0, K);
            }

            estimateUncertainty(cellKey, askedCells, responses) {
                const sigma = this.config.sigma;

                // If no questions answered, return default values
                if (askedCells.length === 0) {
                    return {
                        predictedCorrectness: 0.5,
                        uncertainty: 1.0,
                        confidence: 0.0
                    };
                }

                // Use ALL answered questions with Gaussian kernel weighting
                const cellIdx = this.cellKeyToIndex[cellKey];
                let totalWeight = 0;
                let weightedCorrectness = 0;

                for (const askedCell of askedCells) {
                    const askedIdx = this.cellKeyToIndex[askedCell];
                    const dist = this.distances[cellIdx][askedIdx];
                    const weight = Math.exp(-dist * dist / (2 * sigma * sigma));

                    // Handle fractional correctness values
                    const correct = typeof responses[askedCell] === 'number' ?
                                    responses[askedCell] :
                                    (responses[askedCell] ? 1.0 : 0.0);

                    weightedCorrectness += weight * correct;
                    totalWeight += weight;
                }

                const p = totalWeight > 0 ? weightedCorrectness / totalWeight : 0.5;

                const epsilon = 1e-10;
                const pClipped = Math.max(epsilon, Math.min(1 - epsilon, p));
                const uncertainty = -(pClipped * Math.log2(pClipped) +
                                     (1 - pClipped) * Math.log2(1 - pClipped));

                return {
                    predictedCorrectness: p,
                    uncertainty: uncertainty,
                    confidence: 1 - uncertainty,
                    numNeighbors: askedCells.length
                };
            }

            updateUncertaintyMap(askedCells, responses) {
                const uncertaintyMap = {};

                for (const cellKey of this.allCellKeys) {
                    if (!askedCells.includes(cellKey)) {
                        uncertaintyMap[cellKey] = this.estimateUncertainty(
                            cellKey,
                            askedCells,
                            responses
                        );
                    } else {
                        // Handle fractional correctness values
                        const correctness = typeof responses[cellKey] === 'number' ?
                                          responses[cellKey] :
                                          (responses[cellKey] ? 1.0 : 0.0);
                        uncertaintyMap[cellKey] = {
                            predictedCorrectness: correctness,
                            uncertainty: 0.0,
                            confidence: 1.0
                        };
                    }
                }

                return uncertaintyMap;
            }

            // === Phase 3: Uncertainty-Weighted Selection ===

            scoreCell(cellKey, askedCells, uncertaintyMap) {
                // Calculate alpha and beta dynamically based on confidence
                // When confidence is low: prioritize spreading out (high alpha, low beta)
                // When confidence is high: prioritize uncertainty reduction (low alpha, high beta)
                const confidence = this.computeConfidence().overallConfidence;
                const alpha = 2 * (1 - confidence);
                const beta = 2 * confidence;

                let minDistance = 1.0;
                if (askedCells.length > 0) {
                    const cellIdx = this.cellKeyToIndex[cellKey];
                    minDistance = Math.min(...askedCells.map(asked => {
                        const askedIdx = this.cellKeyToIndex[asked];
                        return this.distances[cellIdx][askedIdx];
                    }));
                }

                const uncertainty = uncertaintyMap[cellKey]?.uncertainty || 1.0;
                const score = Math.pow(minDistance, alpha) * Math.pow(uncertainty, beta);

                return score;
            }

            _selectGeometric(availableQuestions) {
                // Fallback to geometric sampling for first N questions
                const questionsByCell = this._groupByCell(availableQuestions);
                let maxMinDistance = -Infinity;
                let bestQuestion = null;

                for (const [cellKey, questions] of Object.entries(questionsByCell)) {
                    if (this.askedCells.includes(cellKey)) continue;

                    const cellIdx = this.cellKeyToIndex[cellKey];
                    let minDist = Infinity;

                    if (this.askedCells.length > 0) {
                        minDist = Math.min(...this.askedCells.map(asked => {
                            const askedIdx = this.cellKeyToIndex[asked];
                            return this.distances[cellIdx][askedIdx];
                        }));
                    } else {
                        minDist = Math.random();  // Random for very first question
                    }

                    if (minDist > maxMinDistance) {
                        maxMinDistance = minDist;
                        bestQuestion = this._selectRandom(questions);
                    }
                }

                return bestQuestion;
            }

            _selectUncertaintyWeighted(availableQuestions) {
                this.uncertaintyMap = this.updateUncertaintyMap(
                    this.askedCells,
                    this.responses
                );

                const questionsByCell = this._groupByCell(availableQuestions);
                let bestScore = -Infinity;
                let bestQuestion = null;
                let bestCellKey = null;

                for (const [cellKey, questions] of Object.entries(questionsByCell)) {
                    if (this.askedCells.includes(cellKey)) continue;

                    const score = this.scoreCell(cellKey, this.askedCells, this.uncertaintyMap);

                    if (score > bestScore) {
                        bestScore = score;
                        bestCellKey = cellKey;
                        bestQuestion = this._selectRandom(questions);
                    }
                }

                console.log(`Selected cell ${bestCellKey}, score: ${bestScore.toFixed(3)}, ` +
                            `uncertainty: ${this.uncertaintyMap[bestCellKey]?.uncertainty.toFixed(3)}`);

                return bestQuestion;
            }

            selectNextQuestion() {
                const availableQuestions = this._getAvailableQuestions();

                if (availableQuestions.length === 0) {
                    return null;
                }

                let selectedQuestion;
                if (this.askedCells.length < this.config.initialRandomQuestions) {
                    selectedQuestion = this._selectGeometric(availableQuestions);
                } else {
                    selectedQuestion = this._selectUncertaintyWeighted(availableQuestions);
                }

                // Mark question as asked
                if (selectedQuestion && selectedQuestion.questionId) {
                    this.askedQuestions.add(selectedQuestion.questionId);
                }

                return selectedQuestion;
            }

            recordResponse(cellKey, isCorrect, fractionalCorrectness = null) {
                if (!this.askedCells.includes(cellKey)) {
                    this.askedCells.push(cellKey);
                }
                // Support fractional correctness (e.g., 0.1 for "I Don't Know")
                if (fractionalCorrectness !== null) {
                    this.responses[cellKey] = fractionalCorrectness;
                } else {
                    this.responses[cellKey] = isCorrect ? 1.0 : 0.0;
                }
            }

            // === Phase 4: Confidence Metrics ===

            computeConfidence() {
                if (this.askedCells.length === 0) {
                    return {
                        overallConfidence: 0,
                        coverageConfidence: 0,
                        uncertaintyConfidence: 0,
                        coveredCells: 0,
                        totalCells: this.allCellKeys.length
                    };
                }

                let coveredCells = 0;
                const threshold = this.config.coverageDistance;

                for (const cellKey of this.allCellKeys) {
                    const cellIdx = this.cellKeyToIndex[cellKey];
                    let minDist = Infinity;

                    for (const askedCell of this.askedCells) {
                        const askedIdx = this.cellKeyToIndex[askedCell];
                        const dist = this.distances[cellIdx][askedIdx];
                        minDist = Math.min(minDist, dist);
                    }

                    if (minDist < threshold) {
                        coveredCells++;
                    }
                }

                const coverageConfidence = coveredCells / this.allCellKeys.length;

                // Update uncertainty map if not already updated
                if (Object.keys(this.uncertaintyMap).length === 0) {
                    this.uncertaintyMap = this.updateUncertaintyMap(
                        this.askedCells,
                        this.responses
                    );
                }

                let totalConfidence = 0;
                for (const cellKey of this.allCellKeys) {
                    totalConfidence += this.uncertaintyMap[cellKey]?.confidence || 0;
                }
                const uncertaintyConfidence = totalConfidence / this.allCellKeys.length;

                const combinedConfidence = (coverageConfidence + uncertaintyConfidence) / 2;

                return {
                    overallConfidence: combinedConfidence,
                    coverageConfidence: coverageConfidence,
                    uncertaintyConfidence: uncertaintyConfidence,
                    coveredCells: coveredCells,
                    totalCells: this.allCellKeys.length
                };
            }

            canEarlyExit() {
                const confidence = this.computeConfidence();
                return (
                    this.askedCells.length >= this.config.minQuestionsBeforeExit &&
                    confidence.overallConfidence >= this.config.confidenceThreshold
                );
            }

            // === Utility Methods ===

            getUncertaintyMap() {
                return this.uncertaintyMap;
            }

            getStats() {
                const confidence = this.computeConfidence();
                return {
                    questionsAsked: this.askedCells.length,
                    ...confidence,
                    canExit: this.canEarlyExit()
                };
            }

            reset() {
                this.askedCells = [];
                this.responses = {};
                this.uncertaintyMap = {};
                this.askedQuestions = new Set();
            }
        }

        // Load cell distances
        async function loadCellDistances() {
            try {
                const response = await fetch('cell_distances.json');
                if (!response.ok) {
                    console.warn('Cell distances not found - will use random sampling');
                    return null;
                }
                const data = await response.json();
                console.log(`Loaded ${data.metadata.num_cells}Ã—${data.metadata.num_cells} distance matrix`);
                return data;
            } catch (error) {
                console.warn('Could not load cell distances:', error);
                return null;
            }
        }

        // Load questions and initialize
        async function loadQuestions() {
            try {
                // Use cell_questions_sample.json as placeholder (will be cell_questions.json when generation completes)
                const response = await fetch('cell_questions.json');
                if (!response.ok) {
                    throw new Error(`Failed to load questions: ${response.status}`);
                }
                const data = await response.json();

                // Flatten all questions from all cells into the pool
                allQuestionsPool = [];
                // Calculate cell dimensions for jitter
                const gridSize = 40;
                const cellWidth = 1.0 / (gridSize - 1);  // Normalized [0,1] space
                const cellHeight = 1.0 / (gridSize - 1);

                data.cells.forEach(cellData => {
                    cellData.questions.forEach(q => {
                        // Add uniform random jitter within cell bounds
                        // Place question uniformly at random within its cell
                        const jitterX = (Math.random() - 0.5) * cellWidth;  // Uniform within cell
                        const jitterY = (Math.random() - 0.5) * cellHeight;

                        // Convert correct_answer letter (e.g., "D") to index (e.g., 3)
                        let correctIndex;
                        if (q.correct_index !== undefined) {
                            correctIndex = q.correct_index;  // Already a number
                        } else if (q.correct_answer !== undefined) {
                            // Convert letter to index: "A" â†’ 0, "B" â†’ 1, "C" â†’ 2, "D" â†’ 3
                            correctIndex = q.correct_answer.charCodeAt(0) - 65;
                        } else {
                            console.error('Question missing correct answer:', q);
                            correctIndex = 0;  // Fallback
                        }

                        allQuestionsPool.push({
                            question: q.question,
                            options: q.options,
                            correctIndex: correctIndex,
                            x: cellData.cell.center_x + jitterX,
                            y: cellData.cell.center_y + jitterY,
                            topic: q.topic || 'general',
                            cell_gx: cellData.cell.gx,
                            cell_gy: cellData.cell.gy
                        });
                    });
                });

                console.log(`Loaded ${allQuestionsPool.length} total questions from ${data.cells.length} cells`);

                // Store original cell-based data for adaptive sampler
                cellQuestionsData = data;

                // Load cell distances and initialize adaptive sampler
                cellDistances = await loadCellDistances();
                if (cellDistances) {
                    adaptiveSampler = new AdaptiveSampler(cellQuestionsData, cellDistances, {
                        maxQuestions: 10,
                        minQuestionsBeforeExit: 3,
                        confidenceThreshold: 0.85
                    });
                    console.log('Adaptive sampling enabled');
                } else {
                    console.log('Using random sampling (distances not available)');
                }

                // Start first quiz round (select 10 random questions)
                startNewQuizRound();
            } catch (error) {
                console.error('Error loading questions:', error);
                questionContainer.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #e74c3c;">
                        <h3>Error Loading Questions</h3>
                        <p>Could not load cell_questions_sample.json. Please ensure the file exists and the page is served via HTTP(S).</p>
                        <p style="font-size: 0.9em; color: #666; margin-top: 20px;">
                            If testing locally, use a local server like: <code>python -m http.server 8000</code>
                        </p>
                    </div>
                `;
            }
        }

        // Start a new quiz round by selecting 10 new questions (adaptive or random)
        function startNewQuizRound() {
            // Reset for new round
            currentQuestion = 0;
            currentRound++;
            userResponses = []; // Clear current round responses

            if (adaptiveSampler) {
                // Use adaptive sampling
                questionsData = [];
                const maxQuestions = adaptiveSampler.config.maxQuestions;

                // Select questions one at a time using adaptive algorithm
                for (let i = 0; i < maxQuestions; i++) {
                    const selectedQuestion = adaptiveSampler.selectNextQuestion();
                    if (!selectedQuestion) {
                        console.log(`No more questions available after ${i} questions`);
                        break;
                    }

                    // Convert to allQuestionsPool format
                    const cellData = selectedQuestion.cellData;
                    const gridSize = 40;
                    const cellWidth = 1.0 / (gridSize - 1);
                    const cellHeight = 1.0 / (gridSize - 1);
                    const jitterX = (Math.random() - 0.5) * cellWidth;
                    const jitterY = (Math.random() - 0.5) * cellHeight;

                    let correctIndex;
                    if (selectedQuestion.correct_index !== undefined) {
                        correctIndex = selectedQuestion.correct_index;
                    } else if (selectedQuestion.correct_answer !== undefined) {
                        correctIndex = selectedQuestion.correct_answer.charCodeAt(0) - 65;
                    } else {
                        console.error('Question missing correct answer:', selectedQuestion);
                        correctIndex = 0;
                    }

                    const question = {
                        question: selectedQuestion.question,
                        options: selectedQuestion.options,
                        correctIndex: correctIndex,
                        x: cellData.cell.center_x + jitterX,
                        y: cellData.cell.center_y + jitterY,
                        topic: selectedQuestion.topic || 'general',
                        cell_gx: cellData.cell.gx,
                        cell_gy: cellData.cell.gy,
                        cellKey: selectedQuestion.cellKey
                    };

                    questionsData.push(question);
                }

                console.log(`Round ${currentRound}: Selected ${questionsData.length} questions using adaptive sampling`);
                const stats = adaptiveSampler.getStats();
                console.log(`Coverage: ${(stats.coverageConfidence * 100).toFixed(1)}%, ` +
                           `Uncertainty confidence: ${(stats.uncertaintyConfidence * 100).toFixed(1)}%`);
            } else {
                // Fall back to random sampling
                const availableIndices = [];
                for (let i = 0; i < allQuestionsPool.length; i++) {
                    if (!askedQuestionIndices.includes(i)) {
                        availableIndices.push(i);
                    }
                }

                if (availableIndices.length < 10) {
                    console.log(`Only ${availableIndices.length} questions remaining. Resetting question pool.`);
                    askedQuestionIndices = [];
                    availableIndices.length = 0;
                    for (let i = 0; i < allQuestionsPool.length; i++) {
                        availableIndices.push(i);
                    }
                }

                const shuffled = availableIndices.sort(() => Math.random() - 0.5);
                const selectedIndices = shuffled.slice(0, 10);
                questionsData = selectedIndices.map(i => allQuestionsPool[i]);
                askedQuestionIndices.push(...selectedIndices);

                console.log(`Round ${currentRound}: Selected ${questionsData.length} questions (random sampling)`);
            }

            renderQuestion();
        }

        // Load cell labels for heatmap tooltips
        async function loadCellLabels() {
            try {
                const response = await fetch('heatmap_cell_labels.json');
                if (!response.ok) {
                    console.warn('Cell labels not found - tooltips will show basic info only');
                    return;
                }
                const data = await response.json();
                cellLabelsData = data.cells;
                console.log(`Loaded ${cellLabelsData.length} cell labels`);
            } catch (error) {
                console.warn('Could not load cell labels:', error);
            }
        }

        // Load Wikipedia articles
        async function loadWikipediaArticles() {
            try {
                const response = await fetch('wikipedia_articles.json');
                if (!response.ok) {
                    console.warn('Wikipedia articles not found - visualization will show questions only');
                    return;
                }
                wikipediaArticles = await response.json();
                console.log(`Loaded ${wikipediaArticles.length} Wikipedia articles`);
            } catch (error) {
                console.warn('Could not load Wikipedia articles:', error);
            }
        }

        // Calculate inferred knowledge percentage for a cell
        function calculateCellKnowledge(centerX, centerY) {
            const sigma = 0.15; // Same as drawKnowledgeHeatmap
            let knowledge = 0;
            let totalWeight = 0;

            questionsData.forEach((q, idx) => {
                const dx = centerX - q.x;
                const dy = centerY - q.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const weight = Math.exp(-(dist * dist) / (2 * sigma * sigma));

                if (userResponses[idx] !== undefined && userResponses[idx] !== null) {
                    let correctness;
                    if (userResponses[idx] === -1 || q.skipped) {
                        // "I Don't Know" - 0.1 correctness
                        correctness = 0.1;
                    } else {
                        const isCorrect = userResponses[idx] === q.correctIndex;
                        correctness = isCorrect ? 1 : 0;
                    }
                    knowledge += weight * correctness;
                    totalWeight += weight;
                }
            });

            const value = totalWeight > 0 ? knowledge / totalWeight : 0.5;
            return Math.round(value * 100);
        }

        function knowledgePercentToLabel(knowledgePct) {
            // Convert percentage to categorical label
            // Low (<= 25%), Low-Intermediate (25-50%), High-Intermediate (50-75%), High (>= 75%)
            if (knowledgePct <= 25) {
                return 'Low';
            } else if (knowledgePct <= 50) {
                return 'Low-Intermediate';
            } else if (knowledgePct <= 75) {
                return 'High-Intermediate';
            } else {
                return 'High';
            }
        }

        // Initialize
        loadQuestions();
        loadCellLabels();
        loadWikipediaArticles();

        // Event listeners
        nextBtn.addEventListener('click', handleNext);
        prevBtn.addEventListener('click', handlePrevious);
        dontKnowBtn.addEventListener('click', handleDontKnow);
        showMapBtn.addEventListener('click', handleShowMap);
        restartBtn.addEventListener('click', restart);
        anotherRoundBtn.addEventListener('click', startAnotherRound);
        startQuizBtn.addEventListener('click', startQuiz);
        aboutBtn.addEventListener('click', openAbout);
        closeAboutBtn.addEventListener('click', closeAbout);
        copyCitationBtn.addEventListener('click', copyCitation);

        // About modal functions
        function openAbout() {
            aboutModal.classList.remove('hidden');
            document.body.style.overflow = 'hidden';
        }

        function closeAbout() {
            aboutModal.classList.add('hidden');
            document.body.style.overflow = '';
        }

        // Close modal on backdrop click
        aboutModal.addEventListener('click', (e) => {
            if (e.target.classList.contains('modal-backdrop')) {
                closeAbout();
            }
        });

        // Close modal on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && !aboutModal.classList.contains('hidden')) {
                closeAbout();
            }
        });

        // Copy citation to clipboard
        function copyCitation() {
            const citationText = document.getElementById('citation-text').innerText;
            navigator.clipboard.writeText(citationText).then(() => {
                const btn = copyCitationBtn;
                const originalHTML = btn.innerHTML;
                btn.innerHTML = '<i class="fas fa-check"></i> Copied!';
                btn.classList.add('copied');
                setTimeout(() => {
                    btn.innerHTML = originalHTML;
                    btn.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy citation:', err);
                alert('Failed to copy citation. Please copy manually.');
            });
        }

        // Handle contact form submission
        contactForm.addEventListener('submit', (e) => {
            e.preventDefault();

            // Get form values
            const firstName = document.getElementById('contact-first-name').value.trim();
            const lastName = document.getElementById('contact-last-name').value.trim();
            const email = document.getElementById('contact-email').value.trim();
            const subject = document.getElementById('contact-subject').value.trim();
            const message = document.getElementById('contact-message').value.trim();

            // Build mailto link
            const to = 'contextualdynamics@gmail.com';
            const fullSubject = `[MAPPER] ${subject}`;
            const body = `From: ${firstName} ${lastName}\nEmail: ${email}\n\n${message}`;

            const mailtoLink = `mailto:${to}?subject=${encodeURIComponent(fullSubject)}&body=${encodeURIComponent(body)}`;

            // Open mailto link
            window.location.href = mailtoLink;

            // Reset form after slight delay
            setTimeout(() => {
                contactForm.reset();
            }, 100);
        });

        // Start quiz (hide intro, show quiz)
        function startQuiz() {
            introSection.classList.add('hidden');
            quizSection.classList.remove('hidden');

            // Show confidence display if adaptive sampling is enabled
            if (adaptiveSampler) {
                confidenceDisplay.classList.remove('hidden');
            }
        }

        // Update confidence display
        function updateConfidenceDisplay() {
            if (!adaptiveSampler) return;

            const stats = adaptiveSampler.getStats();
            const percent = Math.round(stats.overallConfidence * 100);
            const threshold = Math.round(adaptiveSampler.config.confidenceThreshold * 100);
            const minQuestions = adaptiveSampler.config.minQuestionsBeforeExit;

            // Update display
            confidenceValue.textContent = `${percent}%`;
            confidenceFill.style.width = `${percent}%`;

            // Update "Show Map" button color based on confidence
            const showMapBtn = document.getElementById('show-map-btn');
            if (showMapBtn) {
                if (percent >= 90) {
                    showMapBtn.classList.add('high-confidence');
                } else {
                    showMapBtn.classList.remove('high-confidence');
                }
            }

            // Update message based on confidence level
            if (stats.canExit) {
                confidenceMessage.textContent = `${percent}% confidence - You can view your results now!`;
                confidenceMessage.style.color = '#00693E';
                confidenceMessage.style.fontWeight = '600';
            } else if (stats.questionsAsked < minQuestions) {
                const remaining = minQuestions - stats.questionsAsked;
                confidenceMessage.textContent = `Answer ${remaining} more question${remaining > 1 ? 's' : ''} to view results`;
                confidenceMessage.style.color = '#666';
                confidenceMessage.style.fontWeight = 'normal';
            } else {
                const needed = threshold - percent;
                confidenceMessage.textContent = `${percent}% confidence - ${needed}% more needed for high confidence`;
                confidenceMessage.style.color = '#666';
                confidenceMessage.style.fontWeight = 'normal';
            }
        }

        function renderQuestion() {
            const q = questionsData[currentQuestion];
            questionNumber.textContent = `Question ${currentQuestion + 1} of ${questionsData.length}`;
            questionText.textContent = q.question;

            optionsContainer.innerHTML = '';
            // Convert options object {A: "...", B: "...", C: "...", D: "..."} to array
            const optionsArray = Object.values(q.options);
            optionsArray.forEach((option, index) => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'option';

                const savedResponse = userResponses[currentQuestion];
                if (savedResponse !== undefined && savedResponse === index) {
                    optionDiv.classList.add('selected');
                    selectedOption = index;
                }

                optionDiv.innerHTML = `
                    <span class="option-label">${String.fromCharCode(65 + index)}</span>
                    ${option}
                `;

                optionDiv.addEventListener('click', () => selectOption(index, optionDiv));
                optionsContainer.appendChild(optionDiv);
            });

            prevBtn.classList.toggle('hidden', currentQuestion === 0);
            nextBtn.disabled = selectedOption === null;
            nextBtn.innerHTML = 'Next <i class="fas fa-arrow-right"></i>';

            questionContainer.classList.remove('fade-in');
            void questionContainer.offsetWidth;
            questionContainer.classList.add('fade-in');
        }

        function selectOption(index, optionElement) {
            document.querySelectorAll('.option').forEach(opt => {
                opt.classList.remove('selected');
            });

            optionElement.classList.add('selected');
            selectedOption = index;
            nextBtn.disabled = false;
        }

        function handleNext() {
            userResponses[currentQuestion] = selectedOption;

            // Record response in adaptive sampler if available
            if (adaptiveSampler && questionsData[currentQuestion].cellKey) {
                const isCorrect = selectedOption === questionsData[currentQuestion].correctIndex;
                adaptiveSampler.recordResponse(questionsData[currentQuestion].cellKey, isCorrect);

                // Update confidence display
                updateConfidenceDisplay();

                // Log confidence stats
                const stats = adaptiveSampler.getStats();
                console.log(`Question ${currentQuestion + 1}: ${isCorrect ? 'Correct' : 'Incorrect'} | ` +
                           `Confidence: ${(stats.overallConfidence * 100).toFixed(1)}% | ` +
                           `Coverage: ${(stats.coverageConfidence * 100).toFixed(1)}%`);
            }

            if (currentQuestion < questionsData.length - 1) {
                currentQuestion++;
                selectedOption = null;
                renderQuestion();
            } else {
                showResults();
            }
        }

        function handlePrevious() {
            if (currentQuestion > 0) {
                currentQuestion--;
                selectedOption = userResponses[currentQuestion] ?? null;
                renderQuestion();
            }
        }

        function handleDontKnow() {
            // Record "I Don't Know" response with correctness=0.1
            const skippedIndex = -1; // Special marker for "I Don't Know"
            userResponses[currentQuestion] = skippedIndex;

            // Mark this question as skipped
            questionsData[currentQuestion].skipped = true;

            // Record response in adaptive sampler with low correctness
            if (adaptiveSampler && questionsData[currentQuestion].cellKey) {
                adaptiveSampler.recordResponse(questionsData[currentQuestion].cellKey, false, 0.1);

                // Update confidence display
                updateConfidenceDisplay();

                // Log confidence stats
                const stats = adaptiveSampler.getStats();
                console.log(`Question ${currentQuestion + 1}: I Don't Know (0.1 correctness) | ` +
                           `Confidence: ${(stats.overallConfidence * 100).toFixed(1)}% | ` +
                           `Coverage: ${(stats.coverageConfidence * 100).toFixed(1)}%`);
            }

            // Move to next question or show results
            if (currentQuestion < questionsData.length - 1) {
                currentQuestion++;
                selectedOption = null;
                renderQuestion();
            } else {
                showResults();
            }
        }

        function handleShowMap() {
            // Show map at any time, even if no questions answered (will show all 0.5)
            showResults();
        }

        function showResults() {
            quizSection.classList.add('hidden');
            mapSection.classList.remove('hidden');
            loading.classList.remove('hidden');

            // Show confidence display on map if adaptive sampling is enabled
            if (adaptiveSampler) {
                const mapConfidenceDisplay = document.getElementById('map-confidence-display');
                const mapConfidenceValue = document.getElementById('map-confidence-value');
                const mapConfidenceFill = document.getElementById('map-confidence-fill');

                const stats = adaptiveSampler.getStats();
                const percent = Math.round(stats.overallConfidence * 100);

                mapConfidenceValue.textContent = `${percent}%`;
                mapConfidenceFill.style.width = `${percent}%`;
                mapConfidenceDisplay.classList.remove('hidden');

                // Check if all questions are exhausted
                const availableQuestions = adaptiveSampler._getAvailableQuestions();
                if (availableQuestions.length === 0) {
                    anotherRoundBtn.disabled = true;
                    anotherRoundBtn.innerHTML = '<i class="fas fa-check"></i> All Questions Completed';
                } else {
                    anotherRoundBtn.disabled = false;
                    anotherRoundBtn.innerHTML = '<i class="fas fa-play"></i> Answer More Questions';
                }
            }

            // Add current round questions and responses to full history
            // Only include questions that have actually been answered (have a response)
            const answeredQuestions = [];
            const answeredResponses = [];

            for (let i = 0; i < questionsData.length; i++) {
                if (userResponses[i] !== undefined) {
                    answeredQuestions.push(questionsData[i]);
                    answeredResponses.push(userResponses[i]);
                }
            }

            allUserResponses.push(...answeredResponses);
            allQuestionsShown.push(...answeredQuestions);

            // Calculate accuracy for current round
            let correct = 0;
            answeredResponses.forEach((response, index) => {
                if (response !== undefined && response === answeredQuestions[index].correctIndex) {
                    correct++;
                }
            });

            // Stats will be removed from display, but keeping calculation for potential future use
            document.getElementById('correct-count').textContent = correct;
            document.getElementById('accuracy-pct').textContent = answeredResponses.length > 0 ? `${Math.round((correct / answeredResponses.length) * 100)}%` : '0%';
            document.getElementById('total-count').textContent = answeredResponses.length;

            setTimeout(() => {
                loading.classList.add('hidden');
                // Generate map using ALL responses from all rounds
                generateKnowledgeMapWithHistory();
            }, 1500);
        }

        // Generate knowledge map using full response history (all rounds)
        function generateKnowledgeMapWithHistory() {
            // Use the accumulated questions and responses from all rounds
            // No need to rebuild - allQuestionsShown and allUserResponses already have everything

            // Update global arrays to show full accumulated history
            // Don't restore - we want these to persist for animation frames and future redraws
            questionsData = allQuestionsShown;
            userResponses = allUserResponses;

            // Generate map with full history
            generateKnowledgeMap();
        }

        function generateKnowledgeMap() {
            const container = canvas.parentElement;
            const dpr = window.devicePixelRatio || 1;
            canvas.width = container.clientWidth * dpr;
            canvas.height = container.clientHeight * dpr;
            canvas.style.width = container.clientWidth + 'px';
            canvas.style.height = container.clientHeight + 'px';
            ctx.scale(dpr, dpr);

            const width = container.clientWidth;
            const height = container.clientHeight;

            // Create knowledge heatmap
            drawKnowledgeHeatmap(width, height);

            // Defer drawing markers until next frame to ensure canvas is properly sized
            // This prevents the visual glitch where dots appear in wrong positions during heatmap generation
            requestAnimationFrame(() => {
                // Draw Wikipedia article dots (between heatmap and questions)
                drawWikipediaArticles(width, height);

                // Draw question markers
                drawQuestionMarkers(width, height);
            });

            // Add interactivity
            addInteractivity(width, height);

            // Make legend and colorbar draggable (only initialize once)
            if (!canvas.dataset.draggableInitialized) {
                const legend = document.querySelector('.legend');
                const colorbar = document.querySelector('.colorbar');
                if (legend) makeDraggable(legend);
                if (colorbar) makeDraggable(colorbar);
                canvas.dataset.draggableInitialized = 'true';
            }
        }

        function redrawCanvas() {
            // Get current canvas dimensions
            const container = canvas.parentElement;
            const width = canvas.width / window.devicePixelRatio;
            const height = canvas.height / window.devicePixelRatio;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Redraw heatmap, articles, and markers
            drawKnowledgeHeatmap(width, height);
            drawWikipediaArticles(width, height);
            drawQuestionMarkers(width, height);
        }

        function animateCanvas() {
            const currentTime = performance.now();
            const deltaTime = currentTime - lastFrameTime;
            lastFrameTime = currentTime;

            let needsRedraw = false;

            // Update animation progress for all question dots
            questionsData.forEach((q, idx) => {
                const isHovered = (hoveredDotIndex === idx);
                const target = isHovered ? 1 : 0;
                const current = dotAnimationProgress[idx] || 0;

                if (Math.abs(current - target) > 0.01) {
                    // Smooth transition (50ms duration - very snappy)
                    const speed = 1 / 50; // Progress per millisecond
                    const delta = (target - current) * Math.min(speed * deltaTime, 1);
                    dotAnimationProgress[idx] = Math.max(0, Math.min(1, current + delta));
                    needsRedraw = true;
                } else {
                    dotAnimationProgress[idx] = target;
                }
            });

            // Update animation progress for Wikipedia article dots
            wikipediaArticles.forEach((article, idx) => {
                const isHovered = (hoveredArticleIndex === idx);
                const target = isHovered ? 1 : 0;
                const current = articleAnimationProgress[idx] || 0;

                if (Math.abs(current - target) > 0.01) {
                    // Smooth transition (50ms duration - same as questions)
                    const speed = 1 / 50; // Progress per millisecond
                    const delta = (target - current) * Math.min(speed * deltaTime, 1);
                    articleAnimationProgress[idx] = Math.max(0, Math.min(1, current + delta));
                    needsRedraw = true;
                } else {
                    articleAnimationProgress[idx] = target;
                }
            });

            if (needsRedraw) {
                redrawCanvas();
                animationFrameId = requestAnimationFrame(animateCanvas);
            } else {
                animationFrameId = null;
            }
        }

        function startAnimation() {
            if (!animationFrameId) {
                lastFrameTime = performance.now();
                animationFrameId = requestAnimationFrame(animateCanvas);
            }
        }

        function drawKnowledgeHeatmap(width, height) {
            const gridSize = 40;
            const sigma = 0.15; // Gaussian kernel width

            // Create a 2D grid of knowledge values
            const grid = [];
            for (let gy = 0; gy < gridSize; gy++) {
                grid[gy] = [];
                for (let gx = 0; gx < gridSize; gx++) {
                    const x = gx / (gridSize - 1);
                    const y = gy / (gridSize - 1);
                    
                    // Calculate knowledge at this point based on nearby correct/incorrect answers
                    let knowledge = 0;
                    let totalWeight = 0;
                    
                    questionsData.forEach((q, idx) => {
                        const dx = x - q.x;
                        const dy = y - q.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const weight = Math.exp(-(dist * dist) / (2 * sigma * sigma));

                        if (userResponses[idx] !== undefined) {
                            let correctness;
                            if (userResponses[idx] === -1 || q.skipped) {
                                // "I Don't Know" - 0.1 correctness
                                correctness = 0.1;
                            } else {
                                const isCorrect = userResponses[idx] === q.correctIndex;
                                correctness = isCorrect ? 1 : 0;
                            }
                            knowledge += weight * correctness;
                            totalWeight += weight;
                        }
                    });
                    
                    grid[gy][gx] = totalWeight > 0 ? knowledge / totalWeight : 0.5;
                }
            }

            // Draw heatmap
            const cellWidth = width / (gridSize - 1);
            const cellHeight = height / (gridSize - 1);

            for (let gy = 0; gy < gridSize - 1; gy++) {
                for (let gx = 0; gx < gridSize - 1; gx++) {
                    const value = grid[gy][gx];
                    let color = mapToColor(value);

                    // Darken if this is the hovered cell
                    if (hoveredHeatmapCell && hoveredHeatmapCell.gx === gx && hoveredHeatmapCell.gy === gy) {
                        color = darkenColor(color, 0.15);
                    }

                    ctx.fillStyle = color;
                    ctx.fillRect(
                        gx * cellWidth,
                        gy * cellHeight,
                        cellWidth + 1,
                        cellHeight + 1
                    );
                }
            }
        }

        function mapToColor(value) {
            // Bronze-to-Green colormap (complementary to Dartmouth Green)
            const colors = [
                [139, 69, 19],    // Saddle Brown (low)
                [184, 134, 11],   // Dark Goldenrod
                [218, 165, 32],   // Goldenrod
                [0, 133, 66],     // Medium Green
                [0, 105, 62]      // Dartmouth Green (high)
            ];

            const scaled = value * (colors.length - 1);
            const idx = Math.floor(scaled);
            const t = scaled - idx;

            if (idx >= colors.length - 1) {
                const c = colors[colors.length - 1];
                return `rgba(${c[0]}, ${c[1]}, ${c[2]}, 0.8)`;
            }

            const c1 = colors[idx];
            const c2 = colors[idx + 1];
            
            const r = Math.round(c1[0] + (c2[0] - c1[0]) * t);
            const g = Math.round(c1[1] + (c2[1] - c1[1]) * t);
            const b = Math.round(c1[2] + (c2[2] - c1[2]) * t);

            return `rgba(${r}, ${g}, ${b}, 0.8)`;
        }

        function darkenColor(colorString, amount = 0.2) {
            // Parse RGB/RGBA color string and darken it
            const matches = colorString.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
            if (!matches) return colorString;

            const r = Math.floor(parseInt(matches[1]) * (1 - amount));
            const g = Math.floor(parseInt(matches[2]) * (1 - amount));
            const b = Math.floor(parseInt(matches[3]) * (1 - amount));
            const a = matches[4] !== undefined ? parseFloat(matches[4]) : 1;

            return `rgba(${r}, ${g}, ${b}, ${a})`;
        }

        function drawWikipediaArticles(width, height) {
            // Render articles in extended region (includes articles outside [0,1] for context)
            wikipediaArticles.forEach((article, idx) => {
                const x = article.x;
                const y = article.y;

                // Skip articles outside the extended region [-0.5, 1.5]
                // (matches the filtering in export script)
                if (x < -0.5 || x > 1.5 || y < -0.5 || y > 1.5) {
                    return;
                }

                const baseX = x * width;
                const baseY = y * height;

                // Get animation progress for this article (0 = not hovered, 1 = fully hovered)
                const animProgress = articleAnimationProgress[idx] || 0;

                // Base radius for article dots (small, as specified)
                const baseRadius = 1;

                // When hovered, grow slightly
                const radius = baseRadius + (1 * animProgress);

                // Base alpha (very subtle when not hovered)
                const baseAlpha = 0.05;
                const hoverAlpha = 0.5;
                const alpha = baseAlpha + (hoverAlpha - baseAlpha) * animProgress;

                // Draw article dot (black)
                ctx.beginPath();
                ctx.arc(baseX, baseY, radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(0, 0, 0, ${alpha})`;
                ctx.fill();
            });
        }

        function drawQuestionMarkers(width, height) {
            questionsData.forEach((q, idx) => {
                const baseX = q.x * width;
                const baseY = q.y * height;
                const radius = 12;

                const wasAnswered = userResponses[idx] !== undefined;
                const isSkipped = userResponses[idx] === -1 || q.skipped;
                const isCorrect = userResponses[idx] === q.correctIndex;

                // Get animation progress for this dot (0 = not hovered, 1 = fully hovered)
                const animProgress = dotAnimationProgress[idx] || 0;

                // Calculate hover offset (3px up and right when fully hovered)
                const offsetX = 3 * animProgress;
                const offsetY = -3 * animProgress;
                const currentX = baseX + offsetX;
                const currentY = baseY + offsetY;

                let baseColor;
                if (!wasAnswered) {
                    // Unanswered - intermediate knowledge (goldenrod)
                    baseColor = 'rgb(218, 165, 32)';
                } else if (isSkipped) {
                    // "I Don't Know" - yellow
                    baseColor = 'rgb(255, 193, 7)';
                } else if (isCorrect) {
                    // Correct - high knowledge (Dartmouth Green)
                    baseColor = 'rgb(0, 105, 62)';
                } else {
                    // Incorrect - low knowledge (saddle brown)
                    baseColor = 'rgb(139, 69, 19)';
                }

                // Darken color when hovered
                const color = animProgress > 0 ? darkenColor(baseColor, 0.2 * animProgress) : baseColor;

                // Draw drop shadow at original position when hovered
                if (animProgress > 0) {
                    const shadowRadius = radius + (2 * animProgress);
                    ctx.save();
                    ctx.shadowColor = `rgba(0, 0, 0, ${0.15 * animProgress})`; // Very low alpha for soft edges
                    ctx.shadowBlur = 50 * animProgress; // Extra large blur radius for very diffuse, soft shadows
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;

                    ctx.beginPath();
                    ctx.arc(baseX, baseY, shadowRadius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(0, 0, 0, ${0.1 * animProgress})`; // Very low fill alpha for soft appearance
                    ctx.fill();
                    ctx.restore();
                }

                // Draw marker with white border (at current position with offset)
                ctx.beginPath();
                ctx.arc(currentX, currentY, radius + 2, 0, Math.PI * 2);
                ctx.fillStyle = 'white';
                ctx.fill();

                ctx.beginPath();
                ctx.arc(currentX, currentY, radius, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();

                // Draw question number (simple index, no offset needed since questionsData contains all questions via swap)
                ctx.fillStyle = 'white';
                ctx.font = 'bold 11px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText((idx + 1).toString(), currentX, currentY);
            });
        }

        function getHeatmapCell(mouseX, mouseY, width, height) {
            const gridSize = 40;
            const cellWidth = width / (gridSize - 1);
            const cellHeight = height / (gridSize - 1);

            const gx = Math.floor(mouseX / cellWidth);
            const gy = Math.floor(mouseY / cellHeight);

            if (gx >= 0 && gx < gridSize - 1 && gy >= 0 && gy < gridSize - 1) {
                // Return cell center in normalized coordinates
                const centerX = (gx + 0.5) / (gridSize - 1);
                const centerY = (gy + 0.5) / (gridSize - 1);
                return { gx, gy, centerX, centerY };
            }
            return null;
        }

        function showHeatmapTooltip(canvasRect, cell) {
            // Find cell label if available
            let label = 'Unknown Region';
            if (cellLabelsData) {
                const cellData = cellLabelsData.find(c =>
                    Math.abs(c.center_x - cell.centerX) < 0.001 &&
                    Math.abs(c.center_y - cell.centerY) < 0.001
                );
                if (cellData && cellData.label) {
                    label = cellData.label;
                }
            }

            // Calculate knowledge percentage and convert to categorical label
            const knowledgePct = calculateCellKnowledge(cell.centerX, cell.centerY);
            const knowledgeLabel = knowledgePercentToLabel(knowledgePct);
            const knowledgeValue = knowledgePct / 100; // Normalize to [0, 1] for colormap

            // Get background color from custom colormap
            const bgColor = mapToColor(knowledgeValue);

            tooltip.innerHTML = `
                <div class="tooltip-question">${label}</div>
                <div class="tooltip-status">
                    <span>Inferred Knowledge: ${knowledgeLabel}</span>
                </div>
            `;

            // Apply colormap background color
            tooltip.style.backgroundColor = bgColor;

            tooltip.classList.remove('tooltip-hidden');
            setTimeout(() => tooltip.classList.add('visible'), 10);

            // Calculate cell center position on screen
            const cellCanvasX = cell.centerX * canvasRect.width;
            const cellCanvasY = cell.centerY * canvasRect.height;
            const cellScreenX = canvasRect.left + cellCanvasX;
            const cellScreenY = canvasRect.top + cellCanvasY;

            // Get tooltip dimensions
            const tooltipRect = tooltip.getBoundingClientRect();
            const offset = 15;

            // Determine quadrant based on normalized position
            const isLeftHalf = cell.centerX < 0.5;
            const isTopHalf = cell.centerY < 0.5;

            let left, top;

            // Position tooltip based on quadrant
            if (isLeftHalf) {
                left = cellScreenX + offset;
            } else {
                left = cellScreenX - tooltipRect.width - offset;
            }

            if (isTopHalf) {
                top = cellScreenY + offset;
            } else {
                top = cellScreenY - tooltipRect.height - offset;
            }

            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }

        function addInteractivity(width, height) {
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = (e.clientX - rect.left) / rect.width * width;
                const mouseY = (e.clientY - rect.top) / rect.height * height;

                // Check for question dot hover (highest priority)
                let hoveredQuestion = null;
                questionsData.forEach((q, idx) => {
                    const x = q.x * width;
                    const y = q.y * height;
                    const dist = Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2);

                    if (dist < 15) {
                        hoveredQuestion = { ...q, index: idx };
                    }
                });

                if (hoveredQuestion) {
                    // Question dot takes priority
                    hoveredDotIndex = hoveredQuestion.index;
                    hoveredArticleIndex = null;
                    hoveredHeatmapCell = null;
                    showTooltip(rect, hoveredQuestion);
                    canvas.style.cursor = 'pointer';
                    startAnimation();
                } else {
                    // Check for Wikipedia article hover (second priority)
                    let hoveredArticle = null;
                    wikipediaArticles.forEach((article, idx) => {
                        // Skip articles outside extended region
                        if (article.x < -0.5 || article.x > 1.5 || article.y < -0.5 || article.y > 1.5) {
                            return;
                        }

                        const x = article.x * width;
                        const y = article.y * height;
                        const dist = Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2);

                        // Use larger hover radius for easier interaction
                        if (dist < 8) {
                            hoveredArticle = { ...article, index: idx };
                        }
                    });

                    if (hoveredArticle) {
                        // Wikipedia article hover
                        hoveredDotIndex = null;
                        hoveredArticleIndex = hoveredArticle.index;
                        hoveredHeatmapCell = null;
                        showArticleTooltip(rect, hoveredArticle);
                        canvas.style.cursor = 'pointer';
                        startAnimation();
                    } else {
                        // Check for heatmap cell hover (lowest priority)
                        const cell = getHeatmapCell(mouseX, mouseY, width, height);

                        if (cell) {
                            hoveredDotIndex = null;
                            hoveredArticleIndex = null;
                            hoveredHeatmapCell = cell;
                            showHeatmapTooltip(rect, cell);
                            canvas.style.cursor = 'crosshair';
                            redrawCanvas(); // Immediate redraw to darken heatmap cell
                            startAnimation(); // Also ensure dots animate back if they were hovered
                        } else {
                            hoveredDotIndex = null;
                            hoveredArticleIndex = null;
                            hoveredHeatmapCell = null;
                            hideTooltip();
                            canvas.style.cursor = 'default';
                            redrawCanvas(); // Immediate redraw to un-darken heatmap cells
                            startAnimation(); // Animate dots back to normal
                        }
                    }
                }
            });

            canvas.addEventListener('mouseleave', () => {
                hoveredDotIndex = null;
                hoveredArticleIndex = null;
                hoveredHeatmapCell = null;
                hideTooltip();
                startAnimation();
            });

            // Add click handler for Wikipedia articles
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = (e.clientX - rect.left) / rect.width * width;
                const mouseY = (e.clientY - rect.top) / rect.height * height;

                // First, check if hovering over a question dot - if so, don't handle article clicks
                let hoveringQuestion = false;
                questionsData.forEach((q, idx) => {
                    const x = q.x * width;
                    const y = q.y * height;
                    const dist = Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2);
                    if (dist < 15) {
                        hoveringQuestion = true;
                    }
                });

                // If hovering over a question, don't process article clicks
                if (hoveringQuestion) {
                    return;
                }

                // Check if clicking on a Wikipedia article (find closest one within threshold)
                let clickedArticle = null;
                let minDist = 8; // Threshold distance

                wikipediaArticles.forEach((article, idx) => {
                    // Skip articles outside extended region
                    if (article.x < -0.5 || article.x > 1.5 || article.y < -0.5 || article.y > 1.5) {
                        return;
                    }

                    const x = article.x * width;
                    const y = article.y * height;
                    const dist = Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2);

                    // Only select if closer than current closest (prevents multiple opens)
                    if (dist < minDist) {
                        minDist = dist;
                        clickedArticle = article;
                    }
                });

                // Open Wikipedia article in new tab (only opens one article - the closest)
                if (clickedArticle && clickedArticle.url) {
                    window.open(clickedArticle.url, '_blank');
                }
            });
        }

        function showTooltip(canvasRect, question) {
            const wasAnswered = userResponses[question.index] !== undefined;
            const isSkipped = userResponses[question.index] === -1 || question.skipped;
            const isCorrect = userResponses[question.index] === question.correctIndex;

            // Display question number (simple index, no offset needed since questionsData contains all questions via swap)
            const displayQuestionNumber = question.index + 1;

            let status, statusColor;
            if (!wasAnswered) {
                status = 'Unanswered';
                statusColor = 'rgb(218, 165, 32)';  // Intermediate knowledge (goldenrod)
            } else if (isSkipped) {
                status = "I Don't Know";
                statusColor = 'rgb(255, 193, 7)';  // Yellow
            } else if (isCorrect) {
                status = 'Correct';
                statusColor = 'rgb(0, 105, 62)';  // High knowledge (Dartmouth Green)
            } else {
                status = 'Incorrect';
                statusColor = 'rgb(139, 69, 19)';  // Low knowledge (saddle brown)
            }

            tooltip.innerHTML = `
                <div class="tooltip-question">Q${displayQuestionNumber}: ${question.question}</div>
                <div class="tooltip-status">
                    <div class="tooltip-dot" style="background: ${statusColor};"></div>
                    <span>${status}</span>
                </div>
            `;

            // Reset background to default black for question tooltips
            tooltip.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';

            tooltip.classList.remove('tooltip-hidden');
            setTimeout(() => tooltip.classList.add('visible'), 10);

            // Calculate dot position on screen
            const dotCanvasX = question.x * canvasRect.width;
            const dotCanvasY = question.y * canvasRect.height;
            const dotScreenX = canvasRect.left + dotCanvasX;
            const dotScreenY = canvasRect.top + dotCanvasY;

            // Get tooltip dimensions
            const tooltipRect = tooltip.getBoundingClientRect();
            const offset = 15;  // Offset from dot (in pixels)

            // Determine quadrant based on normalized position (0-1 range)
            // This ensures tooltips stay within heatmap bounds
            const isLeftHalf = question.x < 0.5;
            const isTopHalf = question.y < 0.5;

            let left, top;

            // Position tooltip based on quadrant
            if (isLeftHalf) {
                // Dot is on left side - show tooltip to the right
                left = dotScreenX + offset;
            } else {
                // Dot is on right side - show tooltip to the left
                left = dotScreenX - tooltipRect.width - offset;
            }

            if (isTopHalf) {
                // Dot is on top half - show tooltip below
                top = dotScreenY + offset;
            } else {
                // Dot is on bottom half - show tooltip above
                top = dotScreenY - tooltipRect.height - offset;
            }

            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }

        function showArticleTooltip(canvasRect, article) {
            // Calculate knowledge percentage and convert to categorical label
            const knowledgePct = calculateCellKnowledge(article.x, article.y);
            const knowledgeLabel = knowledgePercentToLabel(knowledgePct);
            const knowledgeValue = knowledgePct / 100; // Normalize to [0, 1] for colormap

            // Get background color from custom colormap
            const bgColor = mapToColor(knowledgeValue);

            // Display article title, excerpt, and knowledge
            tooltip.innerHTML = `
                <div class="tooltip-question">${article.title}</div>
                <div class="tooltip-status">
                    <span>${article.excerpt}</span>
                    <br>
                    <span>Inferred Knowledge: ${knowledgeLabel}</span>
                </div>
            `;

            // Apply colormap background color
            tooltip.style.backgroundColor = bgColor;

            tooltip.classList.remove('tooltip-hidden');
            setTimeout(() => tooltip.classList.add('visible'), 10);

            // Calculate article position on screen
            const articleCanvasX = article.x * canvasRect.width;
            const articleCanvasY = article.y * canvasRect.height;
            const articleScreenX = canvasRect.left + articleCanvasX;
            const articleScreenY = canvasRect.top + articleCanvasY;

            // Get tooltip dimensions
            const tooltipRect = tooltip.getBoundingClientRect();
            const offset = 15;  // Offset from dot (in pixels)

            // Determine quadrant based on normalized position (0-1 range)
            const isLeftHalf = article.x < 0.5;
            const isTopHalf = article.y < 0.5;

            let left, top;

            // Position tooltip based on quadrant to avoid overlap
            if (isLeftHalf) {
                // Article is on left side - show tooltip to the right
                left = articleScreenX + offset;
            } else {
                // Article is on right side - show tooltip to the left
                left = articleScreenX - tooltipRect.width - offset;
            }

            if (isTopHalf) {
                // Article is on top half - show tooltip below
                top = articleScreenY + offset;
            } else {
                // Article is on bottom half - show tooltip above
                top = articleScreenY - tooltipRect.height - offset;
            }

            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }

        function hideTooltip() {
            tooltip.classList.remove('visible');
            setTimeout(() => {
                tooltip.classList.add('tooltip-hidden');
                // Reset background to default when hiding
                tooltip.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
            }, 200); // Match CSS transition duration
        }

        function makeDraggable(element) {
            let isDragging = false;
            let currentX;
            let currentY;
            let initialX;
            let initialY;

            element.addEventListener('mousedown', (e) => {
                // Only start drag if clicking on the element itself, not child elements
                isDragging = true;
                element.classList.add('dragging');

                initialX = e.clientX - element.offsetLeft;
                initialY = e.clientY - element.offsetTop;

                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    e.preventDefault();

                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;

                    // Get parent container bounds
                    const parent = element.parentElement;
                    const parentRect = parent.getBoundingClientRect();
                    const elementRect = element.getBoundingClientRect();

                    // Constrain within parent bounds
                    const maxX = parentRect.width - elementRect.width;
                    const maxY = parentRect.height - elementRect.height;

                    currentX = Math.max(0, Math.min(currentX, maxX));
                    currentY = Math.max(0, Math.min(currentY, maxY));

                    // Update position (remove any existing top/bottom/left/right)
                    element.style.top = currentY + 'px';
                    element.style.left = currentX + 'px';
                    element.style.right = 'auto';
                    element.style.bottom = 'auto';
                }
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    element.classList.remove('dragging');
                }
            });
        }

        function startAnotherRound() {
            // Check if there are any questions left
            if (adaptiveSampler) {
                const availableQuestions = adaptiveSampler._getAvailableQuestions();
                if (availableQuestions.length === 0) {
                    alert('All questions have been asked! No more questions available.');
                    anotherRoundBtn.disabled = true;
                    return;
                }
            }

            // Hide map, show quiz
            mapSection.classList.add('hidden');
            quizSection.classList.remove('hidden');
            hideTooltip();

            // Start a new quiz round with new questions
            startNewQuizRound();
        }

        function restart() {
            // Simply reload the page to fully reset all state
            location.reload();
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            if (!mapSection.classList.contains('hidden')) {
                // Use history version if we have accumulated questions, otherwise regular version
                if (allQuestionsShown.length > 0) {
                    generateKnowledgeMapWithHistory();
                } else {
                    generateKnowledgeMap();
                }
            }
        });
    </script>
</body>
</html>
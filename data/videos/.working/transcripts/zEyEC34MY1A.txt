In this video, I want to introduce you to the idea of a list in Python. It's one of the most powerful data structures in Python, and it really is just a sequence of a bunch of other stuff. So a list in Python would look something like this. So this would be a list of integers, maybe 1, negative 7, 0, 0, 5, and 10. And we could have some variable refer to it, so that we can refer back to it later on in a program. So maybe we say a is equal to all of this. And so if we run this in the interpreter, or if we run this in a program, now we can refer to the elements of a. And you do that by... So let's say I have a... Let me write it the same pink color. You do that by referring to the index of the element inside of the list. So if I say a and then in brackets, I put a 0 here. This says the zeroth element in a. Zeroth element. And the general convention in Python, and this is true in most programming languages, is what some people would consider the first item in an array, or inside of a list, you would call it the zeroth item, or the index of this item right here is 0. So if you were to type this in an interpreter, or if you were to type this in a program, it would evaluate as this item right over here. It would be this item right over there. And let me do another example. If I were to say a of... I should say a of. If I were to say the second element in a, this would be zeroth element, first element, second element. It would be this 0 right over there. So that's how you refer to elements in lists, and you can maybe already imagine doing interesting things with that, but what's really cool with lists is that they don't all have to be the same data type. They could be all integers, or all floats, or all strings, but you could mix it up. So you could... Actually, you could take a right over here, and you could redefine one of the elements. So you could say... You could say a... You could say, let's reset... I'll do that same pink color. Let's reset the... I don't know. Let's say the fourth element. Let's reset the fourth element in a to be equal to this text. So literally, this text. Literally, this text. And so if you did that, if you set the fourth element of a to be this text, and then you were in your program, say print a, then a would look like this. The zeroth element wouldn't change. Still be a one. The first element would still be a negative seven. So this is zero, first. The two-index element would still be a zero. This would be the third. So this is zeroth index, first, second, third, fourth. We replaced the fourth element. So the fourth element will now be this text. It would now be this text. And in a second, we're actually going to try it out with the Python interpreter. And then the last element will still be 10. And this will be completely valid to do in Python. You can mix data types like this. In fact, you could even... After you did this, you could even say that a... Let's redefine the zeroth element of a to be another list. To be the list negative one, negative two. And if you did this, then this zero element over here will, in the list, the zeroth element will now refer to this thing. So the list will now look like this. So the first element, or the zeroth element, I should say, will now be this thing, negative one, negative two. And then you'd have your negative seven, zero, zero, this text, this text. And then you'll have your 10, just like that. So when you define it this way, it literally replaces, or the zeroth element will now refer to this data structure right over here. And you can maybe already imagine useful ways to use this in programs. If you can't, don't worry about it. We'll see useful ways. Now there's one thing that I want to make very clear here. Is that when I... Let's say that I have... Let me define some new... Let's say I have some list that I have the variable B referred to. And let's say I make this list 7, 7, 13, 15. So that's my list. And let's say that I... The next line in my program, or maybe using the Python interpreter, I say that C is equal to B. And sometimes you might be tempted to do this, so it's like, look, I want a copy of B. And what I want to make clear is, at this point, C and B are actually pointing at the same thing. They're referring to the same thing. So if you wanted to think about what's happening, there's some entity in memory that looks like this. 7, 13, 15. And when you execute this... Well, when you execute this first line over here, that says that, look, B is going to definitely refer to that. If the variable B refers to this entity. And when you say C is equal to B, this is actually saying that C is going to refer to the same thing that B is referring to. So C is also going to refer to this exact same thing. C is not a copy of it. We didn't make a copy of it and make C refer to that. And what's relevant here is, if we now change C, we're also going to change... Or if we change what C is referring to, we'll also change what B is referring to. And I'll show you that in a second with the interpreter, but let me show you what I'm talking about. So at this point, I say that C... If I... The next line, I say that C, the zeroth element in C, needs to be equal to 1. And if I were to tell you then, print C, you would get... You would get 1, 13, and 15. But if you were to say print B, you would also get 1, 13, and 15. And that's because this call right over here, or this statement right over here, it changes what the zeroth element in this list refers to. So it won't refer to a 7 anymore, it'll refer to a 1. So now if you say B of 0, this will be equal to 1 and not 7. So you might say, well, okay, I understand that. So if I set a variable equal to another variable that refers to a list, they're actually referring to the same list. And if I change one of the items in the list that this is referring to, it's actually changing what this is referring to. So how could I copy lists? How could I actually copy it? And there, you use the notion that you can actually... And I'll write it right over here. If you actually wanted to copy things, you would do this. You would write C is equal to B, and this might look a little funny for you, but you'd put this colon sign over here. And what this does is it tells you, copy everything in B from the beginning of B all the way to the end of the B. So you could write C is equal to B, and then you could say 0, 0 all the way to up to, but not including, up to but not including the second element. So this right over here, this would create a new list that is the 0th and only the first element. It won't include the second element. So in this case, what you do... So this one right over here would create a new list that looks like this. That creates, that looks like... Well, if we assume we haven't changed B yet, if we assume that this was our definition of B, it'll create a new list that looks like this. And C will now refer to this new list. So C will now refer to this new list. So it created a copy of the first two elements, the 0th element and the first, not the second element. You would have to put 3 here if you wanted the second element. So up to but not including the second element. If you wanted all of the elements to copy, you would do this. So this is implicitly saying from the beginning all the way to the end. So it would create a separate list that looks just like B, but it's a separate one and then C could refer to that. And now if you change C, you won't change B. So enough of just talking about it. Let's actually play with it on our interpreter because this is the fun stuff right over here. So let's say that we have, let's say that, let me get rid of some of this text that I have there so you don't get confused. So let's say I define some list. A is equal to 1, 2, let me write it this way, 1, 2, negative 7, negative 7, 9, 11. So I've defined A and we can even verify that. Print A, you can see it right there. We can change one of the elements in A. We could say let's change the first element. And remember, when we have an index 1, we're not talking about this one here, this is the zeroth element, so we're changing this one right over here. So let's change that. Let's just for fun, let's change that to a string. So, sal's string. And now let's see what A looks like. Print A. So notice, it took this, this is the index 1, this is the first element, zeroth element, first element. It changed the first element to sal's string and we see it right there. Now let's do something interesting. Let's set B equal to A. And let's print B. Let's print B. So it looks just like A. And let me do something else. Let me let C equal to A, A, and then do what I talked about. So let me make C equal to a copy of A. So let's print C. So B and C look the same, but they're two different things. C is a copy of A, or C is a copy of the thing that A is referring to. B is the thing that A is referring to. And to see that, let's change the first element of both B and C. So if you change the first element of B, so B of the zeroth element in B, let's just make that, I don't know, let's make it equal to, let's make it equal to zero. So now if we print B, you see the first element is zero. And what you'll also see is if you print A, the first element will be zero now. Because they were referring to the same thing. So it said whatever B is referring to, the very zeroth element, make that equal to zero. Well A was referring to the same thing, so it also became zero. But C is referring to a copy, so C should not have changed. C did not change, the zeroth element here did not change a bit. So I'll leave you there, lists are super powerful, there's a ton of functions you can do with lists. In fact, I'll expose you to a few right here. So if that is A, you can add elements to A. So you can say A.append and you can add something to the end of A. So you can add a new element. And if you do that, it should add it to the end of A. So let's look at A. It added that element. Now B is referring to the same thing, so let's see what B looks like. It has a new element. C is referring to a copy of the old A. So let's see what that looks like. It didn't add it there, because it didn't add it to the copy. It added only to what A was referring to, which is the same thing that B is referring to. There's a ton of useful functions and we'll explore them as we do more and more programs. But there's a bunch of useful functions or methods that lists have to be able to manipulate them and change them in different ways.